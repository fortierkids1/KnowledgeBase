/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InlineCalloutsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/settings/index.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enableSuggester: true,
  enableTraiingSpace: true,
  enableEditing: true
};
var InlineCalloutsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Enable icon suggestions").setDesc("In editing view (source & live preview modes), enable inline icon auto-complete suggestions.").setClass("inline-callouts-enable-icon-suggestions").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableSuggester).onChange(async (newValue) => {
        this.plugin.settings.enableSuggester = newValue;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Enable editing command/menu").setDesc('In editing view (source & live preview modes), enable "Modify inline callout" command and context menu option.').addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableEditing).onChange(async (newValue) => {
        this.plugin.settings.enableEditing = newValue;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Include trailing space").setDesc("When inserting a new inline callout, append a trailing space immediately after the inline callout code.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableTraiingSpace).onChange(async (newValue) => {
        this.plugin.settings.enableTraiingSpace = newValue;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/modal/search.ts
var import_obsidian3 = require("obsidian");

// src/suggest/inputIcon.ts
var import_obsidian2 = require("obsidian");
var InputIconSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl, items) {
    super(app, inputEl);
    this.app = app;
    this.inputEl = inputEl;
    this.items = items;
  }
  getSuggestions(inputStr) {
    const inputLowerCase = inputStr.toLowerCase();
    const filtered = this.items.filter((item) => {
      if (item.replace("lucide-", "").toLowerCase().contains(inputLowerCase)) return item;
    });
    if (!filtered) this.close();
    return filtered;
  }
  renderSuggestion(value, el) {
    let span = el.createSpan();
    (0, import_obsidian2.setIcon)(span, value);
    span.setAttr("style", "display: inline-block; margin-right: .5em;");
    let label = el.createSpan({ text: " " + value.replace("lucide-", "") });
    label.setAttr("style", "display: inline-block; vertical-align: top;");
  }
  selectSuggestion(item) {
    this.textInputEl.value = item.replace("lucide-", "");
    this.textInputEl.trigger("input");
    this.close();
  }
};

// src/modal/search.ts
var SearchInlineCalloutsModal = class extends import_obsidian3.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.containerEl.addClass("search-inline-callouts-modal");
    this.onOpen = () => this.display(true);
  }
  async display(focus) {
    const { contentEl } = this;
    contentEl.empty();
    let input;
    this.titleEl.setText("Search inline callouts");
    new import_obsidian3.Setting(contentEl).setName("Icon name").setDesc("Enter text to find an icon to search for.").setClass("search-icon-input").addSearch((t) => {
      input = t;
      t.setValue("").onChange((v) => {
        this.calloutIcon = v;
      });
      new InputIconSuggest(
        this.app,
        t.inputEl,
        (0, import_obsidian3.getIconIds)().filter(
          (icon) => icon.replace("lucide-", "").toLowerCase().includes(icon.replace("lucide-", "").toLowerCase())
        )
      );
    });
    new import_obsidian3.Setting(contentEl).addButton(
      (b) => b.setButtonText("Search").setCta().onClick(() => {
        try {
          if (this.calloutIcon) {
            window.open(
              "obsidian://search?vault=" + encodeURIComponent(this.app.vault.getName()) + "&query=" + encodeURIComponent("/`\\[!![a-z-]*?" + this.calloutIcon.replace("lucide-", "") + "[a-z]*?/")
            );
          }
        } catch (e) {
          console.log(e);
          new import_obsidian3.Notice(
            "There was an issue with your search query. Please check the developer console for details.",
            5e3
          );
        }
        this.close();
      })
    );
  }
};

// src/modal/modify.ts
var import_obsidian6 = require("obsidian");

// src/suggest/icon.ts
var import_obsidian4 = require("obsidian");
var _IconSuggest = class _IconSuggest extends import_obsidian4.SuggestModal {
  constructor(plugin, callback) {
    super(plugin.app);
    this.modalEl.addClass("inline-callout-icon-select-modal");
    this.plugin = plugin;
    this.callback = callback;
    this.setPlaceholder("Search for an icon");
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "to navigate" },
      { command: "\u21B5", purpose: "to use" },
      { command: "esc", purpose: "to dismiss" }
    ]);
  }
  getSuggestions(inputStr) {
    const iconIds = (0, import_obsidian4.getIconIds)();
    const iconSuggestions = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    iconIds.forEach((icon) => {
      if (icon.toLowerCase().contains(lowerCaseInputStr)) {
        iconSuggestions.push(icon);
      }
    });
    return iconSuggestions;
  }
  renderSuggestion(icon, el) {
    el.addClass("inline-callout-icon-suggestion");
    let iconWrapper = el.createDiv();
    let iconName = el.createSpan();
    iconName.setAttr("style", "margin-left: .75em; vertical-align:top;");
    let iconGlyph = el.createSpan();
    if (icon === "No icon") {
      iconName.setText(icon);
    } else {
      iconName.setText((icon.startsWith("lucide-") ? icon.substring(7) : icon) + " ");
      (0, import_obsidian4.setIcon)(iconGlyph, icon);
    }
    iconWrapper.appendChild(iconGlyph);
    iconWrapper.appendChild(iconName);
  }
  onChooseSuggestion(item, evt) {
    (0, import_obsidian4.setIcon)(activeDocument.querySelector("[data-note-toolbar-no-icon]"), item);
    _IconSuggest.icon = item;
    this.callback(item);
    this.close();
  }
};
_IconSuggest.icon = "info";
var IconSuggest = _IconSuggest;

// src/callout/builder.ts
var import_obsidian5 = require("obsidian");
var InlineCallout = class {
  constructor() {
    this.newEl = document.createElement("span");
    this.iconEl = document.createElement("span");
    this.labelEl = document.createElement("span");
    this.textEl = document.createElement("span");
  }
  build(text) {
    let part = text.substring(3);
    let content = part.slice(0, -1);
    let parts = content.split("|");
    let calloutIcon = parts[0] ? parts[0].trim().replace(/\\+$/, "").toLowerCase() : null;
    let calloutLabel = parts[1] ? parts[1].trim().replace(/\\+$/, "") : null;
    let calloutColor = parts[2] ? parts[2].trim() : null;
    let calloutColorStyle;
    if (!content.length || parts.length === 0 || !calloutIcon || (0, import_obsidian5.getIconIds)().indexOf("lucide-" + calloutIcon) == -1 && (0, import_obsidian5.getIconIds)().indexOf(calloutIcon) == -1) {
      this.newEl = document.createElement("code");
      this.newEl.setText(text);
      return this.newEl;
    }
    this.newEl.addClass("inline-callout");
    this.newEl.setAttr("data-inline-callout", calloutIcon);
    this.iconEl.addClass("inline-callout-icon");
    this.iconEl.setAttr("data-tooltip-position", "top");
    this.labelEl.addClass("inline-callout-label");
    if (parts.length === 1) {
      this.iconEl.setAttr("aria-label", calloutIcon);
      (0, import_obsidian5.setIcon)(this.iconEl, calloutIcon);
      this.newEl.appendChild(this.iconEl);
      return this.newEl;
    }
    if (!calloutLabel && calloutColor) {
      calloutColorStyle = "color: rgba(" + calloutColor + ", 1);";
      this.iconEl.setAttr("style", calloutColorStyle);
      this.iconEl.setAttr("aria-label", calloutIcon);
      (0, import_obsidian5.setIcon)(this.iconEl, calloutIcon);
      this.newEl.appendChild(this.iconEl);
      return this.newEl;
    }
    this.iconEl.setAttr("aria-label", calloutIcon);
    (0, import_obsidian5.setIcon)(this.iconEl, calloutIcon);
    this.newEl.appendChild(this.iconEl);
    if (calloutLabel) {
      this.labelEl.setText(calloutLabel);
      this.newEl.appendChild(this.labelEl);
    }
    if (calloutLabel && calloutColor) {
      calloutColorStyle = "color: rgba(" + calloutColor + ", 1); background-color: rgba(" + calloutColor + ", var(--inline-callout-bg-transparency));";
      this.newEl.setAttr("style", calloutColorStyle);
    }
    return this.newEl;
  }
};

// src/modal/modify.ts
var _a;
var ModifyInlineCalloutModal = class extends import_obsidian6.Modal {
  constructor(plugin, editor, contextType) {
    super(plugin.app);
    this.plugin = plugin;
    this.editor = editor;
    this.contextType = contextType;
    this.document = (_a = window.activeDocument) != null ? _a : window.document;
    this.containerEl.addClass("modify-inline-callout-modal");
    this.onOpen = () => this.display(true);
  }
  async display(focus, clearColor, preserveIcon) {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Modify inline callout");
    let content = this.contextType.match.replace("[!!", "").replace("]", "");
    let parts = content.split("|");
    if (!clearColor) {
      if (!preserveIcon) {
        this.calloutIcon = parts[0] ? parts[0].trim().replace(/\\+$/, "").toLowerCase() : "info";
      }
    }
    if (!clearColor) {
      this.calloutLabel = this.calloutLabel ? this.calloutLabel : parts[1] ? parts[1].trim().replace(/\\+$/, "") : void 0;
    }
    if (clearColor) {
      this.calloutColor = "";
    } else {
      this.calloutColor = this.calloutColor ? this.calloutColor : parts[2] ? parts[2].trim() : void 0;
    }
    new import_obsidian6.Setting(contentEl).setName("Icon").setDesc("To select an icon, click the button. Default: info").addButton((cb) => {
      cb.setIcon(this.calloutIcon ? this.calloutIcon : "lucide-info").setTooltip("Select icon").onClick(async (e) => {
        e.preventDefault();
        const modal = new IconSuggest(this.plugin, async (icon) => {
          this.calloutIcon = icon;
          this.buildPreview();
        });
        modal.open();
      });
      cb.buttonEl.setAttribute("data-note-toolbar-no-icon", "false");
      this.plugin.registerDomEvent(
        cb.buttonEl,
        "keydown",
        (e) => {
          switch (e.key) {
            case "Enter":
            case " ":
              e.preventDefault();
              const modal = new IconSuggest(this.plugin, async (icon) => {
                this.calloutIcon = icon;
                this.buildPreview();
              });
              modal.open();
          }
        }
      );
    });
    new import_obsidian6.Setting(contentEl).setName("Label").setDesc("Default: blank").addText((t) => {
      t.setValue(this.calloutLabel ? this.calloutLabel : "");
      t.onChange((v) => {
        if (v === "") {
          this.calloutLabel = void 0;
        } else {
          this.calloutLabel = v;
        }
        this.buildPreview();
      });
    });
    const hexToRgb = (hex) => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `${r}, ${g}, ${b}`;
    };
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
    }
    new import_obsidian6.Setting(contentEl).setName("Color").setDesc("Pick a color using the dropdown or color picker. Default: Obsidian's base color").setClass("inline-callouts-color-dropdown").addDropdown((cb) => {
      var _a3;
      cb.addOptions({
        "": "",
        "var(--color-blue-rgb)": "Blue",
        "var(--color-cyan-rgb)": "Cyan",
        "var(--color-green-rgb)": "Green",
        "var(--color-orange-rgb)": "Orange",
        "var(--color-pink-rgb)": "Pink",
        "var(--color-purple-rgb)": "Purple",
        "var(--color-red-rgb)": "Red",
        "var(--color-yellow-rgb)": "Yellow"
      }).setValue(((_a3 = this.calloutColor) == null ? void 0 : _a3.startsWith("var(--color")) ? this.calloutColor : "").onChange((value) => {
        if (value !== "") {
          this.calloutColor = value;
          this.buildPreview();
          this.display(false, false, true);
          setTimeout(() => {
            let dropdown = this.document.querySelector(".modify-inline-callout-modal").querySelector(".inline-callouts-color-dropdown .dropdown");
            dropdown.focus();
          }, 10);
        }
      });
    }).addColorPicker((cb) => {
      var _a3;
      let r = 0;
      let g = 0;
      let b = 0;
      if (this.calloutColor) {
        let colorArr = (_a3 = this.calloutColor) == null ? void 0 : _a3.split(",");
        r = Number(colorArr[0]);
        g = Number(colorArr[1]);
        b = Number(colorArr[2]);
      }
      cb.setValue(rgbToHex(r, g, b)).onChange((value) => {
        this.calloutColor = hexToRgb(value);
        let dropdown = this.document.querySelector(".modify-inline-callout-modal").querySelector(".inline-callouts-color-dropdown .dropdown");
        dropdown.value = "";
        this.buildPreview();
        setTimeout(() => {
          let picker = this.document.querySelector(".modify-inline-callout-modal").querySelector('input[type="color"]');
          picker.focus();
        }, 10);
      });
    }).addExtraButton((ex) => {
      ex.setIcon("refresh-ccw").setTooltip("Reset to no color").onClick(() => {
        this.calloutColor = "";
        this.calloutIcon = this.calloutIcon;
        this.display(false, true);
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Preview");
    this.previewEl = this.contentEl.createDiv({
      cls: "inline-callouts-modal-preview"
    });
    this.buildPreview();
    new import_obsidian6.Setting(contentEl).addButton(
      (b) => b.setButtonText("Save").setCta().onClick(() => {
        var _a3, _b;
        try {
          let firstPipe = "";
          let secondPipe = "";
          if (this.calloutLabel !== void 0 || this.calloutColor !== void 0) {
            firstPipe = "|";
          }
          if (this.calloutLabel === void 0 && this.calloutColor !== void 0 || this.calloutLabel !== void 0 && this.calloutColor !== void 0) {
            secondPipe = "|";
          }
          let cursor = this.editor.getCursor();
          this.editor.replaceRange(
            `\`[!!${this.calloutIcon.replace("lucide-", "")}${firstPipe + (this.calloutLabel !== void 0 ? this.calloutLabel : "")}${this.calloutColor ? secondPipe + this.calloutColor : ""}]\``,
            { line: cursor.line, ch: (_a3 = this.contextType.range) == null ? void 0 : _a3[0] },
            { line: cursor.line, ch: (_b = this.contextType.range) == null ? void 0 : _b[1] }
          );
        } catch (e) {
          console.log(e);
          new import_obsidian6.Notice(
            "There was an issue saving the inline callout. Check the developer console for details."
          );
        }
        this.close();
      })
    );
  }
  buildPreview() {
    this.previewEl.empty();
    this.previewEl.setAttr("style", "margin-bottom: 1em;");
    const inlineCallout = new InlineCallout();
    let newEl = inlineCallout.build("[!!" + this.calloutIcon + "|" + (this.calloutLabel ? this.calloutLabel : "") + "|" + this.calloutColor + "]");
    this.previewEl.appendChild(newEl);
  }
};

// src/modal/new.ts
var import_obsidian7 = require("obsidian");
var _a2;
var NewInlineCalloutModal = class extends import_obsidian7.Modal {
  constructor(plugin, editor) {
    super(plugin.app);
    this.plugin = plugin;
    this.editor = editor;
    this.calloutIcon = "lucide-info";
    this.document = (_a2 = window.activeDocument) != null ? _a2 : window.document;
    this.containerEl.addClass("new-inline-callout-modal");
    this.onOpen = () => {
      if (this.editor.getSelection()) {
        this.calloutLabel = this.editor.getSelection();
      }
      this.display(true);
    };
  }
  async display(focus, clearColor) {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("New inline callout");
    new import_obsidian7.Setting(contentEl).setName("Icon").setDesc("To select an icon, click the button. Default: info").addButton((cb) => {
      cb.setIcon(this.calloutIcon).setTooltip("Select icon").onClick(async (e) => {
        e.preventDefault();
        const modal = new IconSuggest(this.plugin, async (icon) => {
          this.calloutIcon = icon;
          this.buildPreview();
        });
        modal.open();
      });
      cb.buttonEl.setAttribute("data-note-toolbar-no-icon", "false");
      this.plugin.registerDomEvent(
        cb.buttonEl,
        "keydown",
        (e) => {
          switch (e.key) {
            case "Enter":
            case " ":
              e.preventDefault();
              const modal = new IconSuggest(this.plugin, async (icon) => {
                this.calloutIcon = icon;
                this.buildPreview();
              });
              modal.open();
          }
        }
      );
    });
    new import_obsidian7.Setting(contentEl).setName("Label").setDesc("Default: blank").addText((t) => {
      t.setValue(this.calloutLabel);
      t.onChange((v) => {
        this.calloutLabel = v;
        this.buildPreview();
      });
    });
    const hexToRgb = (hex) => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `${r}, ${g}, ${b}`;
    };
    new import_obsidian7.Setting(contentEl).setName("Color").setDesc("Pick a color using the dropdown or color picker. Default: Obsidian's base color").setClass("inline-callouts-color-dropdown").addDropdown((cb) => {
      var _a3;
      cb.addOptions({
        "": "",
        "var(--color-blue-rgb)": "Blue",
        "var(--color-cyan-rgb)": "Cyan",
        "var(--color-green-rgb)": "Green",
        "var(--color-orange-rgb)": "Orange",
        "var(--color-pink-rgb)": "Pink",
        "var(--color-purple-rgb)": "Purple",
        "var(--color-red-rgb)": "Red",
        "var(--color-yellow-rgb)": "Yellow"
      }).setValue(((_a3 = this.calloutColor) == null ? void 0 : _a3.startsWith("var(--color")) ? this.calloutColor : "").onChange((value) => {
        if (value !== "") {
          this.calloutColor = value;
          this.buildPreview();
          this.display(false, false);
          setTimeout(() => {
            let dropdown = this.document.querySelector(".new-inline-callout-modal").querySelector(".inline-callouts-color-dropdown .dropdown");
            dropdown.focus();
          }, 10);
        }
      });
    }).addColorPicker((cb) => {
      var _a3;
      cb.setValue((_a3 = this.calloutColor) != null ? _a3 : "#000000").onChange((value) => {
        this.calloutColor = hexToRgb(value);
        let dropdown = this.document.querySelector(".new-inline-callout-modal").querySelector(".inline-callouts-color-dropdown .dropdown");
        dropdown.value = "";
        this.buildPreview();
        setTimeout(() => {
          let picker = this.document.querySelector(".new-inline-callout-modal").querySelector('input[type="color"]');
          picker.focus();
        }, 10);
      });
    }).addExtraButton((ex) => {
      ex.setIcon("refresh-ccw").setTooltip("Reset to no color").onClick(() => {
        this.calloutColor = "";
        this.calloutIcon = this.calloutIcon;
        this.display(false, true);
      });
    });
    new import_obsidian7.Setting(contentEl).setName("Preview");
    this.previewEl = this.contentEl.createDiv({
      cls: "inline-callouts-modal-preview"
    });
    this.buildPreview();
    new import_obsidian7.Setting(contentEl).addButton(
      (b) => b.setButtonText("Insert").setCta().onClick(() => {
        try {
          let firstPipe = "";
          let secondPipe = "";
          if (this.calloutLabel !== void 0 || this.calloutColor !== void 0) {
            firstPipe = "|";
          }
          if (this.calloutLabel === void 0 && this.calloutColor !== void 0 || this.calloutLabel !== void 0 && this.calloutColor !== void 0) {
            secondPipe = "|";
          }
          let trailingSpace = this.plugin.settings.enableTraiingSpace ? " " : "";
          this.editor.getDoc().replaceSelection(
            `\`[!!${this.calloutIcon.replace("lucide-", "")}${firstPipe + (this.calloutLabel !== void 0 ? this.calloutLabel : "")}${this.calloutColor ? secondPipe + this.calloutColor : ""}]\`${trailingSpace}`
          );
        } catch (e) {
          console.log(e);
          new import_obsidian7.Notice(
            "There was an issue inserting the inline callout. Please check the developer console for details."
          );
        }
        IconSuggest.icon = "info";
        this.close();
      })
    );
  }
  buildPreview() {
    this.previewEl.empty();
    this.previewEl.setAttr("style", "margin-bottom: 1em;");
    const inlineCallout = new InlineCallout();
    let newEl = inlineCallout.build("[!!" + this.calloutIcon + "|" + (this.calloutLabel ? this.calloutLabel : "") + "|" + this.calloutColor + "]");
    this.previewEl.appendChild(newEl);
  }
};

// src/suggest/editorIcon.ts
var import_obsidian8 = require("obsidian");
var EditorIconSuggest = class extends import_obsidian8.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "navigate" },
      { command: "\u21B5", purpose: "select" },
      { command: "esc", purpose: "dismiss" }
    ]);
  }
  onTrigger(cursor, editor, _) {
    var _a3;
    const sub = editor.getLine(cursor.line).substring(0, cursor.ch);
    const match = (_a3 = sub.match(/!!\S+$/)) == null ? void 0 : _a3.first();
    if (match) {
      return {
        end: cursor,
        start: {
          ch: sub.lastIndexOf(match),
          line: cursor.line
        },
        query: match
      };
    }
    return null;
  }
  getSuggestions(context) {
    let icon_query = context.query.replace("!!", "").toLowerCase();
    let iconNames = (0, import_obsidian8.getIconIds)().map((p) => p.replace("lucide-", ""));
    return iconNames.filter((p) => p.includes(icon_query));
  }
  renderSuggestion(suggestion, el) {
    const outer = el.createDiv({ cls: "icon-suggester-container" });
    (0, import_obsidian8.setIcon)(outer, suggestion);
    outer.createSpan({ cls: "icon-suggester-name" }, (cb) => {
      cb.setAttr("style", "margin-left: .75em; vertical-align:top;");
    }).setText(suggestion);
  }
  selectSuggestion(suggestion) {
    if (this.context) {
      this.context.editor.replaceRange("!!" + suggestion.replace("lucide-", ""), this.context.start, this.context.end);
    }
  }
};

// src/views/editor.ts
var import_obsidian9 = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var REGEXP = /(`\[!!([^\]]*)\]`)/gm;
var viewPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    this.decorations = this.buildDecorations(update.view);
  }
  destroy() {
  }
  buildDecorations(view) {
    if (!view.state.field(import_obsidian9.editorLivePreviewField)) {
      return import_view.Decoration.none;
    }
    let builder = new import_state.RangeSetBuilder();
    let lines = [];
    if (view.state.doc.length > 0) {
      lines = Array.from(
        { length: view.state.doc.lines },
        (_, i) => i + 1
      );
    }
    const currentSelections = [...view.state.selection.ranges];
    for (let n of lines) {
      const line = view.state.doc.line(n);
      const startOfLine = line.from;
      const endOfLine = line.to;
      let currentLine = false;
      currentSelections.forEach((r) => {
        if (r.to >= startOfLine && r.from <= endOfLine) {
          currentLine = true;
          return;
        }
      });
      let matches = Array.from(line.text.matchAll(REGEXP));
      for (const match of matches) {
        let add = true;
        const from = match.index != void 0 ? match.index + line.from : -1;
        const to = from + match[0].length;
        if (to - from === 6) {
          add = false;
        }
        currentSelections.forEach((r) => {
          if (r.to >= from && r.from <= to) {
            add = false;
          }
        });
        if (add) {
          builder.add(from, to, import_view.Decoration.widget({ widget: new InlineCalloutWidget(match) }));
        }
      }
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
var InlineCalloutWidget = class extends import_view.WidgetType {
  constructor(callout) {
    super();
    this.callout = callout;
  }
  toDOM(view) {
    let text = this.callout[0].substring(1).substring(this.callout[0].length - 2, 0);
    const inlineCallout = new InlineCallout();
    let newEl = inlineCallout.build(text);
    return newEl;
  }
};

// src/main.ts
var InlineCalloutsPlugin = class extends import_obsidian10.Plugin {
  constructor() {
    super(...arguments);
    this.postprocessor = (el, ctx) => {
      const blockToReplace = el.querySelectorAll("code");
      if (blockToReplace.length === 0) return;
      function replace(node) {
        const childrenToReplace = [];
        node.childNodes.forEach((child) => {
          if (child.nodeType === 3) {
            childrenToReplace.push(child);
          }
        });
        childrenToReplace.forEach((child) => {
          child.replaceWith(child);
        });
      }
      blockToReplace.forEach((block) => {
        replace(block);
      });
    };
  }
  async onload() {
    await this.loadSettings();
    this.registerMarkdownPostProcessor(
      this.buildPostProcessor()
    );
    this.registerEditorExtension(viewPlugin);
    if (this.settings.enableSuggester) {
      this.registerEditorSuggest(new EditorIconSuggest(this));
    }
    this.addCommand({
      id: "new-inline-callout",
      name: "New inline callout",
      icon: "form-input",
      editorCallback: (editor) => {
        let modal = new NewInlineCalloutModal(this, editor);
        modal.open();
      }
    });
    if (this.settings.enableEditing) {
      this.addCommand({
        id: "modify-inline-callout",
        name: "Modify inline callout",
        icon: "form-input",
        editorCheckCallback: (checking, editor, view) => {
          let res = this.checkContextType(editor, view);
          if (res) {
            if (!checking) {
              this.modifyInlineCallout(editor, view);
            }
            return true;
          }
          return false;
        }
      });
    }
    this.addCommand({
      id: "search-inline-callouts",
      name: "Search for inline callouts",
      icon: "text-search",
      callback: () => {
        let modal = new SearchInlineCalloutsModal(this);
        modal.open();
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (this.settings.enableEditing) {
          let res = this.checkContextType(editor, view);
          if (res) {
            menu.addItem((item) => {
              item.setTitle("Modify inline callout").setIcon("form-input").onClick(async () => {
                this.modifyInlineCallout(editor, view);
              });
            });
            return true;
          }
          return false;
        }
      })
    );
    this.addSettingTab(new InlineCalloutsSettingTab(this.app, this));
  }
  onunload() {
  }
  checkContextType(editor, view) {
    const file = view.file;
    if (!file) {
      new import_obsidian10.Notice("Cannot get current file");
      return { type: "null" /* NULL */, curLine: "", match: null, range: null };
    }
    const cursor = editor.getCursor();
    const curLine = editor.getLine(cursor.line);
    const curCh = cursor.ch;
    const beforeCursor = curLine.slice(0, curCh);
    const afterCursor = curLine.slice(curCh);
    let matcher = { type: "inline-code" /* INLINECODE */, regex: /`(\[\!\![^`]+\])`/g, enable: true };
    const matchInfo = this.getMatchInfo(beforeCursor, afterCursor, matcher.regex);
    if (matchInfo) {
      return true;
    }
    return false;
  }
  getMatchInfo(beforeCursor, afterCursor, regex) {
    let match;
    while ((match = regex.exec(beforeCursor + afterCursor)) !== null && afterCursor !== "") {
      const matchStart = match.index;
      const matchEnd = match.index + match[0].length;
      if (beforeCursor.length >= matchStart && beforeCursor.length <= matchEnd) {
        return {
          content: match[1],
          range: [matchStart, matchEnd]
        };
      }
    }
    return null;
  }
  determineContextType(editor, view) {
    const file = view.file;
    if (!file) {
      new import_obsidian10.Notice("Cannot get current file");
      return { type: "null" /* NULL */, curLine: "", match: null, range: [0, 0] };
    }
    const cursor = editor.getCursor();
    const curLine = editor.getLine(cursor.line);
    const curCh = cursor.ch;
    const beforeCursor = curLine.slice(0, curCh);
    const afterCursor = curLine.slice(curCh);
    let matcher = { type: "inline-code" /* INLINECODE */, regex: /`(\[\!\![^`]+\])`/g, enable: true };
    const matchInfo = this.getMatchInfo(beforeCursor, afterCursor, matcher.regex);
    if (matchInfo) {
      return {
        type: matcher.type,
        curLine,
        match: matchInfo.content,
        range: matchInfo.range
      };
    }
    return { type: "null" /* NULL */, curLine, match: null, range: [0, 0] };
  }
  modifyInlineCallout(editor, view) {
    const file = view.file;
    if (!file) {
      new import_obsidian10.Notice("Cannot get current file");
      return;
    }
    const filename = file.basename;
    const contextType = this.determineContextType(editor, view);
    if (contextType.type == "null" /* NULL */) {
      new import_obsidian10.Notice("No inline callout found at current cursor position");
      return;
    }
    const cursor = editor.getCursor();
    const curLine = cursor.line;
    if (contextType.type == "inline-code" /* INLINECODE */) {
      let modal = new ModifyInlineCalloutModal(this, editor, contextType);
      modal.open();
      return;
    }
  }
  buildPostProcessor() {
    return (el) => {
      el.findAll("code").forEach(
        (code) => {
          let text = code.innerText.trim();
          if (text !== void 0 && text.startsWith("[!!") && text.endsWith("]")) {
            const inlineCallout = new InlineCallout();
            let newEl = inlineCallout.build(text);
            if (newEl !== void 0) {
              code.replaceWith(newEl);
            }
          }
        }
      );
    };
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.reload();
  }
  /** Reloads the plugin */
  async reload() {
    await this.app.plugins.disablePlugin("inline-callouts");
    await this.app.plugins.enablePlugin("inline-callouts");
    this.app.setting.openTabById("inline-callouts").display();
  }
};

/* nosourcemap */