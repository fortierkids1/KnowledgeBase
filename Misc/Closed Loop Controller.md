https://docs.revrobotics.com/revlib/spark/closed-loop

Additional reading from [[PID]] 



## Bang Bang
as derived on the [[PID]] lecture, a Bang Bang controller looks at the error, and emits full output power depending on whether it's above or below. 

```java
class BangBang(){
	double max=1;
	double min=0;

	double calculate(double sensor, double setpoint){
		if(sensor < setpoint){ return max ; }
		else if(sensor >= setpoint){ return min; }
	}
}
```

This kind of controller tends to be sub-optimal on most systems, but is useful in situations where you have 
- Analog inputs
- Binary outputs
- Comparatively large inertia relative to system power. 

## Hysteresis

Hysteresis is a resistance to state changes, with numerous applications in physics and control theory, both advantageous and otherwise.

In control theory, hysteresis is often utilized intentionally to prevent rapid switching when a system is at setpoint, as shown in this modified bang-bang controller.

```java
class BangBangWithHysterisis(){
	double threshhold=1;
	double max=1;
	double min=0;
	double currentValue=0
	
	double calculate sensor, double setpoint){
		if(sensor < setpoint-threshhold){ currentValue=max}
		else if(sensor >= setpoint+threshhold){ currentvalue=min}
		return currentValue;
	}
}
```

In this code, you can see that if a setpoint is within 1 of the setpoint, it doesn't turn off _or_ turn on; It simply does what it was already doing.

This creates both slight overshoot and slight undershoot, but creates a range of acceptable values, which is often suitable for applications where a standard BangBang controller would be used.

This is something you'll commonly see on automatic heaters: As the room cools, they turn on when you're too cold, and only turn off once you're a bit too warm, and the cycle repeats. You're never quite _at_ the temperature you want, but generally pretty close to it. The hysteresis ensures that the heater always changes the temp by several degrees at once.

Hysteresis is also seen in automatic shifting algorithms in both cars and robots; This avoids unnecessary gear changes within ranges where either gearing is equally effective.

## Three-Point Controller

Similar to a Bang Bang (formally known as a two-point controller), a three-point controller has on/off/reverse.
```java
class BangBangWithHysterisis(){
	double threshhold=1;
	double max=1;
	double min=-1;
	double off=0
	double currentValue=0
	
	double calculate sensor, double setpoint){
		if(sensor < setpoint-threshhold){ currentValue=max}
		else if(sensor >= setpoint+threshhold){ currentvalue=min}
		return off;
	}
}
```

This looks a lot like the hysterisis control, but instead of overshooting through the middle zone, it simply turns off.

While not common in modern FRC, this control mode is very common in many real world applications due to the simple, cheap electronics needed to operate it. 

In past FRC seasons, this type of control was used for relay controlled motors. It can also be used alongside two-pole pnuematic systems for somewhat analog control in air positioned systems. 

## Sqrt(err)

This is an odd, but useful technique, as much as a specific algorithm. By taking the square root of the error, then applying a gain, you get a sharp, aggressive response for small errors, but decreasingly aggressive as the error increases further.

```java
class SquareRootError(){
	gain = 0.1
	
	double calculate(double sensor, double setpoint,){
		error = setpoint-sensor 
		output = gain * Math.signOf(error) * Math.sqrt(Math.abs(Error))
		return output;
	}
}
```

This simple algorithm tends to generate a "springy" response to disturbances, is simple to tune, and typically can hit the setpoint reliably under a wider variety of disturbance conditions.

This algorithm tends to work well for velocity systems like [[SuperStructure Rollers|Rollers]], [[Superstructure Shooter|Shooters]], or Drivetrains. When tuned effectively, disturbances will tend to generate the right amount of output to add momentum to the system, quickly getting things back to the velocity target.

The major flaw of this algorithm stems from the tendency to result in high frequency oscillation at the setpoint, especially for systems with notable backlash. Using a [[Slew Rate Limiting|Slew Rate Limiter]] on the output can improve response in these cases. 

It can be useful for manual control from joysticks, and can also be useful for following position or velocity targets generated by [[Motion Profiles]], but allowing sharp oscillations make it sub-optimal for holding position in steady state scenarios. 


## Take Back Half
An integrator-oriented control loop with an output back-off when the error changes to prevent overshoot and simplify tuning. In FRC, potentially useful for velocity control.

Detailed explanation + plots
https://wiki.purduesigbots.com/software/control-algorithms/take-back-half-tbh-controller

Reference implementation
https://github.com/team751/2013RobotCode/blob/master/src/org/team751/speedcontrol/TakeBackHalfSpeedController.java#L98


## State Space control + LQR
This is a more mathematically complex differential-equation based control system, but with many advantages in real-world applications.
https://docs.wpilib.org/en/stable/docs/software/advanced-controls/state-space/state-space-intro.html

These can model physical systems *extremely* accurately, and actually are what is used internally when using [[Physics Simulation|Simulation]] .