<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[CodeTest]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>CodeTest</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 19 Jun 2025 06:01:44 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 19 Jun 2025 06:01:36 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[README]]></title><description><![CDATA[ 
 <br>Placeholder file to make sure that the directory exists. <br>This folder is just used to keep images in, so they don't clutter up other documentation. ]]></description><link>assets/readme.html</link><guid isPermaLink="false">assets/README.md</guid><pubDate>Thu, 05 Jun 2025 03:01:08 GMT</pubDate></item><item><title><![CDATA[Absolute Encoders]]></title><description><![CDATA[ 
 <br><br><br>
<br>Advantages
<br>Disadvantages
<br>Discontinuity handling
<br>Integration with relative encoders
]]></description><link>hardware/absolute-encoders.html</link><guid isPermaLink="false">Hardware/Absolute Encoders.md</guid><pubDate>Mon, 02 Jun 2025 18:44:51 GMT</pubDate></item><item><title><![CDATA[LaserCan]]></title><description><![CDATA[<a class="tag" href="?query=tag:hardware" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#hardware</a> 
 <br><a href=".?query=tag:hardware" class="tag" target="_blank" rel="noopener nofollow">#hardware</a><br><br>
<br>Connect to the LaserCan using GrappleHook
<br>Create a new Lasercan sensor subsystem
<br>Create a Trigger that returns true while an object is within X" of the sensor
]]></description><link>hardware/lasercan.html</link><guid isPermaLink="false">Hardware/LaserCan.md</guid><pubDate>Mon, 02 Jun 2025 18:52:01 GMT</pubDate></item><item><title><![CDATA[Rev Hardware Client]]></title><description><![CDATA[ 
 <br><br>
<br>Run a motor using
<br>Plot the motor's position over time
<br>Configure a motor's ID and basic settings
<br>View an absolute encoder's output
]]></description><link>hardware/rev-hardware-client.html</link><guid isPermaLink="false">Hardware/Rev Hardware Client.md</guid><pubDate>Mon, 02 Jun 2025 05:01:14 GMT</pubDate></item><item><title><![CDATA[Coding Basics]]></title><description><![CDATA[ 
 <br><br>
<br>variables
<br>classes
<br>Functions
<br>"structs" or data classes
<br>Introduce enums (don't need to impliment)
<br>Explaining inherited classes as interfaces (because we deal with them).
<br>"null" objects -&gt; initialization (mostly avoided by minimizing indefinite declarations)
<br><br>
<br>Complex stuff involving inheritence or extending classes. Aside from creating new commands or triggers (which mostly act as an interface), we don't do anything with this, and the few places we could it creates confusion because of hidden, unexpected behaviors.
<br>Implimenting/using Arrays/Lists: Not especially common in simpler tasks, and java makes interacting messy. Handle as needed later.
<br>Error handling. Super gross in java, and we mostly need basics. Cover if necessary (mostly Lasercan), but prefer converting errors to Optionals and doing type checking instead of bubbling up (which lasercan also does).
<br><br>
<br>
Teach the "command/robotcontainer/subsystem" model early. If you do a ton of bot development before getting to "typical bot structure", code structure becomes a mess and it becomes harder to use any advanced features and reason through more complex tasks. It also gets the wrong habits engrained, which becomes an unlearning process later. It's OK to say "We'll get into the details of why this is" later, they'll figure things out.

<br>
Putting complex logic into a command is a great way to prototype all sorts of bot ideas, and should help them when doing "upgrades" to older code.

<br>
Consider one "trial project" for subsystems to house a single, simple system, and learn the basic java education. No need to get too deep beyond helping set up. Then, once they have it after a project or two, move into modelling "complex work" with commands.

<br>
It's helpful when "prototyping" complex things using "commands" because you can cycle through different ways of prototyping it easily by swapping out commands being selected.

<br>Subsystems

<br>Robot nouns.
<br>Containers for a single actuator or "resource"
<br>Allows "locks" and requires
<br>Organized place to keep associated code.


<br>Commands

<br>The robot "verbs", and actions systems can take.
<br>Can be basic and stil be useful when decorated
<br>Typical commands shouldn't end; Decorate or make shortcuts for ones that do




]]></description><link>level-0/coding-basics.html</link><guid isPermaLink="false">Level 0/Coding Basics.md</guid><pubDate>Sun, 01 Jun 2025 20:36:36 GMT</pubDate></item><item><title><![CDATA[Coding Basics]]></title><description><![CDATA[ 
 <br><br>
<br>variables
<br>classes
<br>Functions
<br>"structs" or data classes
<br>Introduce enums (don't need to impliment)
<br>Explaining inherited classes as interfaces (because we deal with them).
<br>"null" objects -&gt; initialization (mostly avoided by minimizing indefinite declarations)
<br><br>
<br>Complex stuff involving inheritence or extending classes. Aside from creating new commands or triggers (which mostly act as an interface), we don't do anything with this, and the few places we could it creates confusion because of hidden, unexpected behaviors.
<br>Implimenting/using Arrays/Lists: Not especially common in simpler tasks, and java makes interacting messy. Handle as needed later.
<br>Error handling. Super gross in java, and we mostly need basics. Cover if necessary (mostly Lasercan), but prefer converting errors to Optionals and doing type checking instead of bubbling up (which lasercan also does).
<br><br>
<br>
Teach the "command/robotcontainer/subsystem" model early. If you do a ton of bot development before getting to "typical bot structure", code structure becomes a mess and it becomes harder to use any advanced features and reason through more complex tasks. It also gets the wrong habits engrained, which becomes an unlearning process later. It's OK to say "We'll get into the details of why this is" later, they'll figure things out.

<br>
Putting complex logic into a command is a great way to prototype all sorts of bot ideas, and should help them when doing "upgrades" to older code.

<br>
Consider one "trial project" for subsystems to house a single, simple system, and learn the basic java education. No need to get too deep beyond helping set up. Then, once they have it after a project or two, move into modelling "complex work" with commands.

<br>
It's helpful when "prototyping" complex things using "commands" because you can cycle through different ways of prototyping it easily by swapping out commands being selected.

<br>Subsystems

<br>Robot nouns.
<br>Containers for a single actuator or "resource"
<br>Allows "locks" and requires
<br>Organized place to keep associated code.


<br>Commands

<br>The robot "verbs", and actions systems can take.
<br>Can be basic and stil be useful when decorated
<br>Typical commands shouldn't end; Decorate or make shortcuts for ones that do




Coding Basics]]></description><link>level-0/coding-basics.html</link><guid isPermaLink="false">Level 0/Coding Basics.canvas</guid><pubDate>Sun, 01 Jun 2025 19:51:11 GMT</pubDate></item><item><title><![CDATA[Safety]]></title><description><![CDATA[ 
 <br>Code safety:<br>
<br>Bugs on moving objects can be dangerous
<br>Bad control algorithms can damage hardware + game pieces
<br>Surprise motions can cause harm
<br>Operator safety<br>
<br>Programmers are often operators
<br>Unattended operation
<br>Changing operator muscle memory can result in harm
]]></description><link>level-0/safety.html</link><guid isPermaLink="false">Level 0/Safety.md</guid><pubDate>Thu, 12 Jun 2025 20:35:02 GMT</pubDate></item><item><title><![CDATA[Auto Differential]]></title><description><![CDATA[ 
 <br><br>
<br>Create a simple autonomous that drives forward and stops
<br>Create a two-step autonomous that drives forward and backward
<br>Create a four step autonomous that drives forward, runs a mock "place object" command, backs up, then turns around.
]]></description><link>level-1/auto-differential.html</link><guid isPermaLink="false">Level 1/Auto Differential.md</guid><pubDate>Mon, 02 Jun 2025 05:01:21 GMT</pubDate></item><item><title><![CDATA[Basic Telemetry]]></title><description><![CDATA[ 
 <br><br>Understand how to efficiently communicate to and from a robot for diagnostics and control <br><br>
<br>


<br><br><br>
<br>Graphs
<br>Field2D
<br>Poses
<br>Folders
<br>Mechanism2d
<br><br>
<br>Widget options
<br>Driverstation setup
]]></description><link>level-1/basic-telemetry.html</link><guid isPermaLink="false">Level 1/Basic Telemetry.md</guid><pubDate>Mon, 02 Jun 2025 05:01:26 GMT</pubDate></item><item><title><![CDATA[Commands]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Robot Code Basics" href="level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Create a command that runs indefinitely
<br>Have that command start+end on a joystick button
<br>Create a command that starts on a joystick press, and stop it with a different button
<br>Create a default command that lets you know when it's running through <a data-tooltip-position="top" aria-label="Basic Telemetry" data-href="Basic Telemetry" href="level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Telemetry</a>
<br>Create a runCommand using a function pointer
<br>Create a runCommand using a lambda
<br>Learning order
You can learn this without having done <a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>, but it's often more fun to learn alongside it in order to have more interesting, visual commands while experimenting.<br>
The commands provided as an example just print little messages visible in the RioLog, allowing this to be set up without motors
<br><br>A Command is an event driven code structure that allows you manage when code runs, what resources it uses, and when it ends. <br>In the context of a robot, it allows you to easily manage a lot of the complexity involved with managing multiple <a data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> <br>The code structure itself is fairly straightforward, and defines a few methods; Each method defines what code runs at what time. <br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){}
	public void initialize(){}
	public void execute(){}
	public boolean isFinished(){ return false; }
	public void end(boolean cancelled){}
}
<br>Behind the scenes, the robot runs a command scheduler, which helps manage what runs when. Once started, a command will run according to the following flowchart, more formally known as a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">state machine</a>. <br><br>This is the surface level complexity, which sets you up for how to view, read, and write commands. <br><br>A key aspect of Commands is their ability to claim temporary, exclusive  ownership over a <a data-href="Subsystem" href="Subsystem" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> .  This is done by passing the subsystem into a command, and then adding it as a requirement<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(ExampleSubsystem subsystemName){
		addRequirements(subsystemName);
	}
<br>Now, whenever the command is started, it will forcibly claim that subsystem. It'll release that claim when it runs it's end() block.<br>This ability of subsystems to hold a claim on a resource has a lot of utility. The main value is in preventing you from doing silly things like trying to tell a motor to go forward and backward at once.<br><br>Now that we've established subsystem ownership, what happens when you do try to tell your motor to go forward and then backward?<br>When you start the command, it will forcibly interrupt other commands that share a resource with it, ensuring that the new command has exclusive access. <br>It'll look like this<br><br>When a command is cancelled, the command scheduler runs the commands end(cancelled) block, passing in a value of true. Whole not typical, some commands will need to do different cleanup routines depending on whether they exited on a task completion, or if something else kicks em off a subsystem. <br><br>Commands can be started in one of 3 ways:<br>
<br>via a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>'s start condition
<br>Directly scheduling it via the command's .schedule() method.
<br>Automatically as a DefaultCommand
<br>They can be stopped via a few methods<br>
<br>When the command returns true from it's isFinished() method
<br>When launched by a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>, and the run condition is no longer met
<br>Calling a command's .cancel() method directly
<br>When the command is cancelled by a new command that claims a required subsystem.
<br><br>It's often the case that a subsystem will have a clear, preferred action when nothing else is going on. In some cases, it's stopping a spinning roller, intake, or shooter. In others it's retracting an intake. Maybe you want your lights to do a nice idle pattern. Maybe you want your chassis joystick to just start when the robot does.<br>Default commands are ideal for this. Default commands run just like normal commands, but are automatically re-started once nothing else requires the associated subsystem resource.<br>Just like normal command, they're automatically stopped when the robot is disable, and cancelled when something else requires it.<br>
Unlike normal commands, it's not allowed to have the command return true from isFinished(). The scheduler expects default commands to run until they're cancelled. <br>Also unlike other commands, a subsystem must require the associated subsystem, and cannot require other subsystems. <br>Command groups + default commands
It's worth making a note that a Default Command cannot start during a Command Group that contains a command requiring the subsystem! If you're planning complex command sequences like an auto, make sure they don't rely on DefaultCommands as part of their operation.
<br><br>As you're writing new subsystems, make sure you consider whether you should require a subsystem. <br>You'll always want to require subsystems that you will modify, or otherwise need exclusive access to. This commonly involves commands that direct a motor, change settings, or something of that sort. <br>In some cases, you'll have a subsystem that only reads from a subsystem. Maybe you have an LED subsystem, and want to change lights according to an Elevator subsystems's height.<br>
One way to do this is have a command that requires the LEDs (needs to change the lights), but does not require the Elevator (it's just reading the encoder).<br>As a general rule, most commands you write will simply require exactly one subsystem. Commands that need to require multiple subsystems can come up, but typically this is handled by command composition and command groups.<br><br>Every new project will have an example command in a dedicated file, which should look familiar<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){
		//Runs once when the command is created as the robot boots up.
		//Register required subsystems, if appropriate
		//addRequirements(subsystem1, subsystem2...);
	}
	public void initialize(){
		//Runs once when the command is started/scheduled
	}
	public void execute(){
		//Runs every code loop
	}
	public boolean isFinished(){
		//Returns true if the command considers it's task done, and should exit
		return false;
	}
	public void end(boolean cancelled){
		//Perform cleanup; Can do different things if it's cancelled
	}
}
<br>This form of command is mostly good for instructional purposes while you're getting started. <br>On more complex robot projects, trying to use the file-based Commands forces a lot of mess in your Subsystems; In order for these to work, you need to make many of your Subsystem details public, often requiring you to make a bunch of extra functions to support them. <br><br>Command factories are the optimal way to manage your commands. With this convention, you don't create a separate  Command files, but create methods in your <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> that build and return new Command objects. This convention is commonly called a "Factory" pattern.<br>
Here's a short example and reference layout:<br>//In your subsystem
Roller extends SubsystemBase{
	Roller(){}

	public Command spinForward(){
		return Commands.run(()-&gt;{
			System.out.println("Spin Forward!!");
		},this);
	}
}
<br>//In your robotContainer, let's create a copy of that command
RobotContainer{
	RobotContainer(){
		joystick.a().whileTrue(roller.spinForward());
	}
}

<br>That's it! Not a lot of code, but gives you a flexible base to start with.<br>This example uses Commands.run() one of the many options in the <a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" target="_blank">Commands Class</a>. These command shortcuts let you provide <a data-href="Lambdas" href="misc/lambdas.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas</a> representing some combination of a Command's normal Initialize, Execute, isFinished, or End functions. A couple notable examples are<br>
<br>Commands.run : Takes a single lambda for the Execute blocks
<br>Commands.startRun : Takes two lambdas for the Initialize and Execute blocks
<br>Commands.startEnd : Takes two lambdas for the Initialize and End Blocks
<br>Most commands you'll write can be written like this, making for simple and concise subsystems. <br>Watch the Requires
Many Commands helpers require you to provide the required subsystem after the lambdas. If you forget, you can end up with multiple commands fighting to modify the current subsystem
<br>Building on the above, Subsystems have several of these command helpers build in! You can see this.startRun(...), this.run(..) etc; These commands work the same as the Commands. versions, but automatically include the current subsystem.<br>There's a notable special case in new FunctionalCommand(...), which takes 4 lambdas for a full command, perfectly suitable for those odd use cases.<br><br>The real power of commands comes from the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" target="_blank">Command Compositions</a> , and "decorator" functions. These functions enable a lot of power, allowing you to change how/when commands run, and pairing them with other commands for complex sequencing and autos. <br>For now, let's focus on the two that are more immediately useful: <br>
<br>command.withTimeout(time) , which runs a command for a set duration. 
<br>command.until(()-&gt;someCondition) , which allows you to exit a command on things like sensor inputs. 
<br>Commands also has some helpful commands for hooking multiple commands together as well. The most useful is a simple sequence.<br>Commands.sequence(
	roller.spinForward().withTimeout(0.1),
	roller.spinBackward().withTimeout(0.1),
	roller.spinForward().withTimeout(0.5)
)
]]></description><link>level-1/commands.html</link><guid isPermaLink="false">Level 1/Commands.md</guid><pubDate>Sun, 08 Jun 2025 20:58:55 GMT</pubDate></item><item><title><![CDATA[Differential Drive]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a Differential Drivetrain
<br>Configure a Command to operate the drive using joysticks
<br>??? Add rate limiting to joysticks to make the system control better 
<br>??? Add  constraints to rotation to make robot drive better
]]></description><link>level-1/differential-drive.html</link><guid isPermaLink="false">Level 1/Differential Drive.md</guid><pubDate>Mon, 02 Jun 2025 05:01:33 GMT</pubDate></item><item><title><![CDATA[Encoder Basics]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Robot Code Basics" href="level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Configure a motor encoder
<br>Read an encoder
<br>Configure encoder range/units through gearing
<br>Enable/Disable Soft Limits
<br><br>
<br>Absolute vs Relative encoders
<br>Startup positioning
<br><a data-href="Homing" href="Homing" class="internal-link" target="_self" rel="noopener nofollow">Homing</a>
<br>Slew Rate Limiting
]]></description><link>level-1/encoder-basics.html</link><guid isPermaLink="false">Level 1/Encoder Basics.md</guid><pubDate>Mon, 02 Jun 2025 05:01:36 GMT</pubDate></item><item><title><![CDATA[FeedForwards]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a velocity FF for a roller system that enables you to set the output in RPM
<br>Create a gravity FF for a elevator system that holds the system in place without resisting external movement
<br>Create a gravity FF for an arm system that holds the system in place without resisting external movement
<br><br>Feedforwards model an expected motor output for a  system to hit specific target values.<br>
The easiest example is a motor roller. Let's say you want to run at ~3000 RPM. You know your motor has a top speed of ~6000 RPM at 100% output, so you'd correctly expect that driving the motor at 50% would get about 3000 RPM. This simple correlation is the essence of a feed-forward. The details are specific to the system at play. <br><br>The WPILib docs have good fundamentals on feedforwards that is worth reading.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br><br>Feed-forwards are specifically tuned to the system you're trying to operate, but helpfully fall into a few simple terms, and straightforward calculations. In many cases, the addition of one or two terms can be sufficient to improve and simplify control. <br><br>The simplest feedforward you'll encounter is the "static feed-forward". This term represents initial momentum, friction, and certain motor dynamics. <br>You can see this in systems by simply trying to move very slow. You'll often notice that the output doesn't move it until you hit a certain threshhold. That threshhold is approximately equal to kS.<br>The static feed-forward affects output according to the simple equation of  <br><br>a kG value effectively represents the value needed for a system to negate gravity. <br>Elevators are the simpler case: You can generally imagine that since an elevator has a constant weight, it should take a constant amount of force to hold it up. This means the elevator Gravity gain is simply a constant value, affecting the output as  ; You don't need any other considerations regarding the system motion, because gravity is always constant. <br>A more complex kG calculation is needed for pivot or arm system. You can get a good sense of this by grabbing a heavy book, and holding it at your side with your arm down. Then, rotate your arm outward, fully horizontal. Then, rotate your arm all the way upward. You'll probably notice that the book is much harder to hold steady when it's horizontal than up or down.<br>The same is true for these systems, where the force needed to counter gravity changes based on the angle of the system. To be precise, it's maximum at horizontal, zero when directly above or below the pivot. Mathematically, it follows the function  ratio, lending this version of the feed-forward the nickname kCos.<br>This form of the gravity constant affects the output according to<br>
, where  is is the maximum output, at horizontal. <a data-footref="kcos" href="about:blank#fn-1-259a90b8f416b3a1" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> <br><br>The velocity feed-forward represents the expected output to maintain a target velocity. This term accounts for physical effects like dynamic friction and air resistance, and a handful of  <br>This is most easily visualized on systems with a velocity goal state. In that case,  is easily known, and contributes to the output as  .<br>In contrast, for positional control systems, knowing the desired system velocity is quite a challenge. In general, you won't know the target velocity unless you're using a <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to to generate the instantaneous velocity target. <br><br>The acceleration feed-forward largely negates a few inertial effects. It simply provides a boost to output to achieve the target velocity quicker.<br>like ,  is typically only known when you're working with <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>. <br><br>Putting this all together, it's helpful to de-mystify the math happening behind the scenes.<br>A roller system will often simply be<br>
If you don't have a motion profile, kA will simply be zero, and and kS might also be negligible unless you plan to operate at very low RPM.<br>An elevator system will look similar:<br>
Without a motion profile, you cannot properly utilize kV and kA, which simplifies down to<br>
where  is generally derived by  (since you know the current and previous positions).<br>Lastly, elevator systems differ only by the cosine term to scale kG.<br>
Again simplifying for systems with no motion profile, you get<br>
It's helpful to recognize that because the angle is being fed to a  function, you cannot use degrees here! Make sure to convert. <br>Of course, the intent of a feed-forward is to model your mechanics to improve control. As your system increases in complexity, and demands for precision increase, optimal control might require additional complexity! A few common cases: <br>
<br>If you have a pivot arm that extends, your kG won't be constant! 
<br>Moving an empty system and one loaded with heavy objects might require different feed-forward models entirely.
<br>Long arms might be impacted by motion of systems they're mounted on, like elevators or the chassis itself! You can add that in and apply corrective forces right away.
<br><br>Since a feed-forward is prediction about how your system behaves, it works very well for fast, responsive control. However, it's not perfect; If something goes wrong, your feed-forward simply doesn't know about it, because it's not measuring what actually happens. <br>In contrast, feed-back controllers like a  <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> are designed to act on the error between a system's current state and target state, and make corrective actions based on the error. Without first encountering system error, it doesn't do anything.<br>The combination of a feed-forward along with a feed-back system is the power combo that provides robust, predictable motion.<br><br>WPILib has several classes that streamline the underlying math for common systems, although knowing the math still comes in handy! The docs explain them (and associated warnings) well.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br>Integrating in a robot project is as simple as crunching the numbers for your feed-forward and adding it to your motor value that you write every loop.<br>ExampleSystem extends SubsystemBase(){

	SparkMax motor = new SparkMax(...)
	// Declare our FF terms and our object to help us compute things.
	double kS = 0.0;
	double kG = 0.0;
	double kV = 0.0;
	double kA = 0.0;
	ElevatorFeedforward feedforward = new ElevatorFeedforward(kS, kG, kV, kA);
	
	ExampleSubsystem(){}

	Command moveManual(double percentOutput){
		return run(()-&gt;{
			var output ;
			//We don't have a motion profile or other velocity control
			//Therefore, we can only assert that the velocity and accel are zero
			output = percentOutput+feedforward.calculate(0,0);
			// If we check the math, this feedforward.calculate() thus 
			// evaluates as simply kg;
			
			// We can improve this by instead manually calculating a bit
			// since we known the direction we want to move in
			output = percentOutput + Math.signOf(percentOutput) + kG;
			motor.set(output);
		})
	}

	Command movePID(double targetPosition){
		return run(()-&gt;{
			//Same notes as moveManual's calculations 
			var feedforwardOutput = feedforward.calculate(0,0);
			// When using the Spark closed loop control, 
			// we can pass the feed-forward directly to the onboard PID
			motor
			.getClosedLoopController()
			.setReference(
				targetPosition,
				ControlType.kPosition,
				ClosedLoopSlot.kSlot0,
				feedforwardOutput, 
				ArbFFUnits.kPercentOut
			);
			//Note, the ArbFFUnits should match the units you calculated!
		})
	}

	Command moveProfiled(double targetPosition){
		// This is the only instance where we know all parameters to make 
		// full use of a feedforward.
		// Check [[Motion Profiles]] for further reading
	}
	
}
<br><br>High gains
When tuning feed-forwards, it's helpful to recognize that values being too high will result in notable problems, but gains being too low generally result in lower performance.<br>
Just remember that the lowest possible value is 0; Which is equivalent to not using that feed forward in the first place. Can only improve from there. 
<br><br>These two terms are defined at the boundary between "moving" and "not moving", and thus are closely intertwined. Or, in other words, they interfere with finding the other. So it's best to find them both at once.<br>It's easiest to find these with manual input, with your controller input scaled down to give you the most possible control.<br>Start by positioning your system so you have room to move both up and down. Then, hold the system perfectly steady, and increase output until it just barely moves upward. Record that value.<br>
Hold the system stable again, and then decrease output until it just barely starts moving down. Again, record the value. <br>Thinking back to what each term represents, if a system starts moving up, then the provided input must be equal to ; You've negated both gravity and the friction holding it in place. Similarly, to start moving down, you need to be applying . This insight means you can generate the following two equations  <br><br>Helpfully, for systems where  like roller systems, several terms cancel out and you just get  .<br>For pivot/arm systems, this routine works as described if you can calculate kG at approximately horizontal. It cannot work if the pivot is vertical. If your system cannot be held horizontal, you may need to be creative, or do a bit of trig to account for your recorded  being decreased by <br>Importantly, this routine actually returns a kS that's often slightly too high, resulting in undesired oscillation. That's because we recorded a minimum that causes motion, rather than the maximum value that doesn't cause motion. Simply put, it's easier to find this way. So, we can just compensate by reducing the calculated kS slightly; Usually multiplying it by 0.9 works great. <br><br>Because this type of system system is also relatively linear and simple, finding it is pretty simple. We know that , and expect . <br>We know  is going to be constrained by our motor's maximum RPM, and that maxOutput is defined by our api units (either +/-1.0 for "percentage" or +/-12 for "volt output"). <br>This means we can quickly assert that  should be pretty close to . <br><br>Beyond roller kV, kA and kV values are tricky to identify with simple routines, and require <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to take advantage of. As such, they're somewhat beyond the scope of this article.<br>The optimal option is using <a data-href="System Identification" href="level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a> to calculate the system response to inputs over time. This can provide optimal, easily repeatable results. However, it involves a lot of setup, and potentially hazardous to your robot when done without caution.<br>The other option is to tune by hand; This is not especially challenging, and mostly involves a process of moving between goal states, watching graphs, and twiddling numbers. It usually looks like this:<br>
<br>Identify two setpoints, away from hard stops but with sufficient range of motion you can hit target velocities. 
<br>While cycling between setpoints, ihen increase kV until the system generates velocities that match the target velocities. They'll generally lag behind during the accelleration phase. 
<br>Then, increase kA until the accelleration shifts and the system perfectly tracks your profile. 
<br>Increase profile constraints and and repeat until system performance is attained. Starting small and slow prevents damage to the mechanics of your system.
<br>This process benefits from a relatively low P gain, which helps keep the system stable. Once your system is tuned, you'll probably want a relatively high P gain, now that you can assert the feed-forward is keeping your error close to zero. <br><br>
<br>
<br>Note, you might observe that the kCos output,   is reading the current system state, and say "hey!  That's a feed back system, not a feed forward!" and you are technically correct; the best kind of correct. However, kCos is often implemented this way, as it's much more stable than the feed-forward version. In that version, you apply , regardless of what  happens to actually be. Feel free to do a thought experiment on how this might present problems in real-world systems.<a href="about:blank#fnref-1-259a90b8f416b3a1" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>level-1/feedforwards.html</link><guid isPermaLink="false">Level 1/FeedForwards.md</guid><pubDate>Sat, 07 Jun 2025 00:18:47 GMT</pubDate></item><item><title><![CDATA[Gyro Driving]]></title><description><![CDATA[ 
 <br>Requires<br>
<a data-href="Auto Differential" href="level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Gyro Sensing" href="level-1/gyro-sensing.html" class="internal-link" target="_self" rel="noopener nofollow">Gyro Sensing</a><br><br>
<br>Create a button that causes the robot to face a bearing of 0 degrees
<br>Create 3 additional buttons to face 90, 180, and 270. 
<br>Ensure that the drivers can hold those buttons and use the throttle to drive in the indicated direction
<br>Create an 4 step auto that traverses a predefined path using gyro headings and encoder distances
]]></description><link>level-1/gyro-driving.html</link><guid isPermaLink="false">Level 1/Gyro Driving.md</guid><pubDate>Mon, 02 Jun 2025 05:01:52 GMT</pubDate></item><item><title><![CDATA[Gyro Sensing]]></title><description><![CDATA[ 
 <br><br>
<br>
Configure a NavX or gyro on the robot

<br>
Find a way to zero the sensor when the robot is enabled in auto

<br>
Create a command that tells you when the robot is pointed the same way as when it started

<br>
Print the difference between the robot's starting angle and current angle

<br>
TODO

<br>
what's an mxp

<br>
what port/interface to use, usb

<br>
which axis are you reading

<br>
]]></description><link>level-1/gyro-sensing.html</link><guid isPermaLink="false">Level 1/Gyro Sensing.md</guid><pubDate>Wed, 18 Jun 2025 02:38:32 GMT</pubDate></item><item><title><![CDATA[Homing Sequences]]></title><description><![CDATA[ 
 <br><br><a data-href="SuperStructure Arm" href="level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br>
<a data-href="SuperStructure Elevator" href="level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
And will generally be done after most requirements for those systems<br><br>
<br>Home a subsystem using a Command-oriented method
<br>Home a subsystem using a state-based method
<br>Make a non-homed system refuse non-homing command operations
<br>Document the "expected startup configuration" of your robot, and how the homing sequence resolves potential issues.
<br><br>
<br>Configure encoders and other system configurations
<br>Construct a Command that homes the system
<br>Create a Trigger to represent if the system is homed or not
<br>Determine the best way to integrate the homing operation. This can be 

<br>Initial one-off sequence on enable
<br>As a blocking operation when attempting to command the system
<br>As a default command with a Conditional Command
<br>Idle re-homing (eg, correcting for slipped belts when system is not in use)
<br>


]]></description><link>level-1/homing-sequences.html</link><guid isPermaLink="false">Level 1/Homing Sequences.md</guid><pubDate>Mon, 02 Jun 2025 05:02:00 GMT</pubDate></item><item><title><![CDATA[Limelight Assist Driving]]></title><description><![CDATA[ 
 <br>requires<br>
<a data-href="Auto Differential" href="level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Limelight Basics" href="level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight Basics</a><br><br>
<br>Create a button that aims your chassis at a target
<br>Ensure the above button allows drivers to move toward and away from target while it's held
<br>Create a pipeline that allows you to drive to the left/right of the target instead of directly at it
<br>Create a button that aligns you with a game piece, and allows drivers to drive at it
]]></description><link>level-1/limelight-assist-driving.html</link><guid isPermaLink="false">Level 1/Limelight Assist Driving.md</guid><pubDate>Mon, 02 Jun 2025 05:02:07 GMT</pubDate></item><item><title><![CDATA[Limelight Basics]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>
<a data-href="NetworkTables" href="level-2/networktables.html" class="internal-link" target="_self" rel="noopener nofollow">NetworkTables</a><br><br>
<br>Configure a Limelight to 
<br>Identify an April Tag
<br>Create a trigger that returns true if a target is in view
<br>When a target is in view, print the offset between forward and the target
<br>Estimate the distance to the target
<br>Configure the LL to identify a game piece of your choice.
<br>Indicate angle between forward and game piece.
]]></description><link>level-1/limelight-basics.html</link><guid isPermaLink="false">Level 1/Limelight Basics.md</guid><pubDate>Mon, 02 Jun 2025 05:02:11 GMT</pubDate></item><item><title><![CDATA[Motor Control]]></title><description><![CDATA[ 
 <br>Requires:<a data-href="Robot Code Basics" href="level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br>
Recommends:<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br><br>
<br>Spin a motor
<br>Configure a motor with max current
<br>Control on/off via joystick button
<br>Control speed via joystick
<br><br>Learning order
This curriculum does not require or assume the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> structure; It's just about spinning motors.<br>
However, it's recommended to learn Motor Control alongside or after <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, as we'll use them for everything afterwards anyway.
<br>Rev Lib
This documentation assumes you have the third party Rev Library installed. You can find instructions here.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html</a>
<br>Wiring and Electrical
This document also assumes correct wiring and powering of a motor controller. This should be the case if you're using a testbench. 
<br><br>// Robot.java
public Robot extends TimedRobot{

	public void teleopPeriodic(){
		
	}
}
]]></description><link>level-1/motor-control.html</link><guid isPermaLink="false">Level 1/Motor Control.md</guid><pubDate>Sun, 08 Jun 2025 07:04:16 GMT</pubDate></item><item><title><![CDATA[PID]]></title><description><![CDATA[ 
 <br>Requires<br>
<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Create a PID system on a test bench
<br>Tune necessary PIDs using encoders
<br>Set a velocity using a PID
<br>Set a angular position using a PID
<br>Set a elevator position using a PID
<br>Plot the system's position, target, and error as you command it.
<br><br>TODO:<br>
Add some graphs<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/DylanHojnoski/obsidian-graphs" target="_blank">https://github.com/DylanHojnoski/obsidian-graphs</a><br>
Write synopsis<br><br>A PID system is a <a data-href="Closed Loop Controller" href="misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controller</a> designed to reduce system error through a simple, efficient mathematical approach.<br>You may also appreciate Chapter 1 and 2 from <a data-href="controls-engineering-in-frc.pdf" href="misc/controls-engineering-in-frc.pdf" class="internal-link" target="_self" rel="noopener nofollow">controls-engineering-in-frc.pdf</a> , which covers PIDs very well. <br><br>To get an an intuitive understanding about PIDs and feedback loops, it can help to start from scratch, and kind of recreating it from the basic assumptions and simple code.<br>Let's start from the core concept of "I want this system to go to a position and stay there". <br>Initially, you might simply say "OK, if we're below the target position, go up.  If we're above the target position, go down." This is a great starting point, with the following pseudo-code.<br>setpoint= 15  //your target position, in arbitrary units
sensor= 0 //Initial position
if(sensor &lt; setpoint){ output = 1 }
else if(sensor &gt; setpoint){ output = -1 }
motor.set(output)
<br>However, you might see a problem. What happens when setpoint and sensor are equal? <br>If you responded with "It rapidly switches between full forward and full reverse", you would be correct. If you also thought "This sounds like it might damage things", then you'll understand why this controller is named a "Bang-bang" controller, due to the name of the noises it tends to make.<br>Your instinct for this might be to simply not go full power. Which doesn't solve the problem, but reduces it's negative impacts. But it also creates a new problem. Now it's going to oscillate at the setpoint (but less loudly), and it's also going to take longer to get there.<br>So, let's complicate this a bit. Let's take our previous bang-bang, but split the response into two different regions: Far away, and closer. This is easier if we introduce a new term: Error. Error just represents the difference between our setpoint and our sensor, simplifying the code and procedure. "Error" helpfully is a useful term, which we'll use a lot.<br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	error = setpoint-sensor 
	if     (error &gt; 5){ output = -1 }
	else if(error &gt; 0){ output = -0.2 }
	else if(error &lt; 0){ output = 0.2 }
	else if(error &lt; -5){ output = 1 }
	motor.set(output)
})
<br>We've now slightly improved things; Now, we can expect more reasonable responses as we're close, and fast responses far away. But we still have the same problem; Those harsh transitions across each else if. Splitting up into more and more branches doesn't seem like it'll help. To resolve the problem, we'd need an infinite number of tiers, dependent on how far we are from our targets. <br>With a bit of math, we can do that! Our error term tells us how far we are, and the sign tells us what direction we need to go... so let's just scale that by some value. Since this is a constant value, and the resulting output is proportional to this term, let's call it kp: Our proportional constant. <br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	kp = 0.1
	error = setpoint-sensor 
	output = error*kp
	motor.set(output)
)}
<br>Now we have a better behaved algorithm! At a distance of 10, our output is 1. At 5, it's half. When on target, it's zero! It scales just how we want. <br>Try this on a real system, and adjust the kP until your motor reliably gets to your setpoint, where error is approximately zero. <br>In doing so, you might notice that you can still oscillate around your setpoint if your gains are too high. You'll also notice that as you get closer, your output drops to zero. This means, at some point you stop being able to get closer to your target. <br>This is easily seen on an elevator system. You know that gravity pulls the elevator down, requiring the motor to push it back up. For the sake of example, let's say an output of 0.2 holds it up. Using our previous kP of 0.1, a distance of 2 generates that output of 0.2. If the distance is 1, we only generate 0.1... which is not enough to hold it! Our system actually is only stable below where we want. What gives! <br> This general case is referred to as "standing error" ; Every loop through our PID fails to reduce the error to zero, which eventually settles on a constant value. So.... what if.... we just add that error up over time? We can then incorporate that error into our outputs. Let's do it.<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
kp = 0.1
ki = 0.001
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	output = error*kp + errorsum*ki
	motor.set(output)
}
<br>The mathematical operation involved here is called integration, which is what this term is called. That's the "I" in PID.<br>
In many practical FRC applications, this is probably as far as you need to go! P and PI controllers can do a lot of work, to suitable precision. This a a very flexible, powerful controller, and can get "pretty good" control over a lot of mechanisms. <br>This is probably a good time to read across the  <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" target="_blank">WPILib PID Controller</a>  page; This covers several useful features. Using this built-in PID, we can reduce our previous code to a nice formalized version that looks something like this.<br>PIDController pid = new PIDController(kP, kI, kD);
run(()-&gt;{
	sensor = motor.getEncoder.getPosition();
	motor.set(pid.calculate(sensor, setpoint))
})
<br>A critical detail in good PID controllers is the iZone. We can easily visualize what problem this is solving by just asking "What happens if we get a game piece stuck in our system"?<br>
Well, we cannot get to our setpoint. So, our errorSum gets larger, and larger.... until our system is running full power into this obstacle. That's not great. Most of the time, something will break in this scenario. <br>So, the iZone allows you to constrain the amount of error the controller actually stores. It might be hard to visualize the specific numbers, but you can just work backward from the math. If output = errorsum*kI, then maxIDesiredTermOutput=iZone*kI. So iZone=maxIDesiredTermOutput/kI.<br>Lastly, what's the D in PID?<br>Well, it's less intuitive, but let's try. Have you seen the large spike in output when you change a setpoint? Give the output a plot, if you so desire. For now, let's just reason through a system using the previous example PI values, and a large setpoint change resulting in an error of 20. <br>Your PI controller is now outputting a value of 2.0 ; That's double full power! Your system will go full speed immediately with a sharp jolt, have a ton of momentum at the halfway point, and probably overshoot the final target. So, what we want to do is constrain the speed; We want it fast but not too fast. So, we want to reduce it according to how fast we're going.<br>
Since we're focusing on error as our main term, let's look at the rate the error changes. When the error is changing fast we want to reduce the output. The difference is simply defined as error-previousError, so a similar strategy with gains gives us output+=kP*(error-previousError) .<br>
This indeed gives us what we want: When the rate of change is high, the contribution is negative and large; Acting to reduce the total output, slowing the corrective action.<br>However, this term has another secret power, which disturbance rejection. Let's assume we're at a steady position, and the system is settled, and error=0. Now, let's bonk the system downward, giving us a positive error. Suddenly nonzero-0 is positive, and the system generates a upward force. For this interaction, all components of the PID are working in tandem to get things back in place.<br><br>OK, that's enough nice things. Understanding PIDs requires knowing when they work well, and when they don't, and when they actually cause problems. <br>
<br>PIDs are reactive, not predictive. Note our key term is "error" ; PIDs only act when the system is already not where you want it, and must be far enough away that the generated math can create corrective action.
<br>Large setpoint changes break the math. When you change a setpoint, the P output gets really big, really fast, resulting in an output spike. When the PID is acting to correct it, the errorSum for the I term is building up, and cannot decrease until it's on the other side of the setpoint. This almost always results in overshoot, and is a pain to resolve.  
<br>Oscillation: PIDs inherently generate oscillations unless tuned perfectly. Sometimes big, sometimes small.
<br>D term instability: D terms are notoriously quirky. Large D terms and velocity spikes can result in bouncy, jostly motion towards setpoints, and can result in harsh, very rapid oscillations around the zero, particularly when systems have significant <a data-href="mechanical backlash" href="mechanical backlash" class="internal-link" target="_self" rel="noopener nofollow">mechanical backlash</a>.
<br>PIDS vs Hard stops: Most systems have one or more <a data-href="Hard Stops" href="Hard Stops" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a>, which present a problem to the I term output. This requires some consideration on how your encoders are initialized, as well as your setpoints.
<br>Tuning is either simple....or very time consuming.
<br>So, how do you make the best use of PIDs?<br>
<br>Reduce the range of your setpoint changes. There's a few ways to go about it, but the easiest are <a data-href="clamping" href="clamping" class="internal-link" target="_self" rel="noopener nofollow">clamping</a> changes, <a data-href="Slew Rate Limiting" href="misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a> and <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> . With such constraints, your error is always small, so you can tune more aggressively for that range. 
<br>Utilize <a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> to create the basic action; Feed-forwards create the "expected output" to your motions, reducing the resulting error significantly. This means your PID can be tuned to act sharply on disturbances and unplanned events, which is what they're designed for.
<br>In other words, this is an error correction mechanism, and if you avoid adding error to begin with, you more effectively accomplish the motions you want. Throwing a PID at a system can get things moving in a controlled fashion, but care should be taken to recognize that it's not intended as the primary control handler for systems. <br><br>]]></description><link>level-1/pid.html</link><guid isPermaLink="false">Level 1/PID.md</guid><pubDate>Thu, 12 Jun 2025 21:16:24 GMT</pubDate></item><item><title><![CDATA[Robot Code Basics]]></title><description><![CDATA[ 
 <br><a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>
<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Install the WPILib VS Code IDE
<br>Make a new robot project
<br>Create a new subsystem
<br>Install the Rev third Library
<br>Basic requirements to start working  on robot projects
<br>Create a new empty subsystem 
<br>Create a new empty command
<br>Add your new command and subsystem to RobotContainer.
<br><br>Programming prerequisites, listed in <a data-href="Coding Basics" href="level-0/coding-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Basics</a> for now<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html</a><br><br>When you open a new robot project you'll see a lot of files we'll interact with.<br>
<br>src/main

<br>deploy
<br>java
<br>frc/frc/robot

<br>commands

<br>ExampleCommand.java


<br>subsystems

<br>ExampleSubsystem.java


<br>Constants.java
<br>Main.java
<br>Robot.java
<br>RobotContainer.java




<br>vendordeps
<br>For typical projects, you'll be spending the most time in RobotContainer, subsystems, and occasionally commands. <br>For some early practice projects, or special use cases you might also interact with Robot.java a bit.<br><br>Many helpful utilities we'll use for robot projects are represented using code that's not available by default. WPILib has a small manager to assist with installing these, detailed here: <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries</a><br><br>We'll also utilize a number of software tools for special interactions with hardware or software components. Some of these include <br>
<br><a data-href="Rev Hardware Client" href="hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a> , a motor controller management tool
<br><a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">GrappleHook</a> , which manages the LaserCan configuration
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" target="_blank">NI Driver Station</a> is needed for systems that will want to enable and drive a robot. 
<br><br>The hardest part of getting started with robots is figuring out where your robot code goes. <br><br>Robot.java is a very powerful file, and it's possible to write your entire robot in just this one file! For reasons we'll get into, we do not want to do this. However, the setup of it does a good job explaining how a robot works. Let's look at the structure of this file for now<br>public class Robot extends TimedRobot {
	private Command m_autonomousCommand;
	private final RobotContainer m_robotContainer;
	public Robot() {
		m_robotContainer = new RobotContainer();
	}
	
	public void robotPeriodic() {}
	
	public void disabledInit() {}
	public void disabledPeriodic() {}
		
	public void autonomousInit() {}
	public void autonomousPeriodic() {}
	
	public void teleopInit() {}
	public void teleopPeriodic() {}
	
	public void testInit() {}
	public void testPeriodic() {}
	
	//a few more ignored bits for now
}
<br>From the pairing, we can group these into several different modes<br>
<br>"Robot"
<br>Autonomous
<br>Teleop
<br>Test
<br>Indeed, if we look at our <a data-href="Driver Station" href="misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a>, we see several modes mentioned.<br>
<img alt="driverstation.jpg" src="lib/media/driverstation.jpg"><br>
Teleop, Auto, and Test are simply selectable operational modes. However, you might want to utilize each one slightly differently.<br>"Practice mode" is intended to simulate real matches: This DriverStation mode runs Autonomous mode for 15 seconds, and then Teleop Mode for the remainder of a match time. <br>"Disabled" mode is automatically selected whenever the robot is not enabled. This includes when the robot boots up, as well as as whenever you hit "disabled" on the driver station.<br>
Disabled mode will also cancel any running <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> . <br>"Robot mode" isn't an explicit mode: Instead, of "Robot Init", we just use the constructor: It runs when the robot boots up. In most cases, the primary task of this is to set up Robot Container.<br>
robotPeriodic just runs every loop, regardless of what other loop is also running.<br>We can also see a grouping of <br>
<br>Init
<br>Periodic<br>
Whenever any new "mode" starts, we first run the Init function once, and then we run the periodic. The robot will continue run associated Periodic functions every loop, 50 times per second. 
<br>We generally won't add much code in Robot.java, but understanding how it works is a helpful starting point to understanding the robot itself. <br><br>As mentioned above, the "Robot Container" is created as the robot boots up. When you create a new project,<br>
This file contains a small number of functions and examples to help you organized. <br>public class RobotContainer(){
	ExampleSubsystem subsystem = new ExampleSubsystem();
	ExampleCommand command = new ExampleCommand();
	CommandXboxJoystick joystick = new CommandXboxJoystick(0);
	RobotContainer(){
		configureBindings();
	}
	public void configureBindings(){
		//Not a special function; Just intended to help organize 
	}
	public Command getAutonomousCommand(){/*stuff*/}
}
<br>This file introduces a couple new concepts  <br>
<br><a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, which form the  "actions" you want the robot to perform
<br><a data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>, or the different parts of the robot that could perform actions
<br><a data-href="Joysticks" href="misc/joysticks.html" class="internal-link" target="_self" rel="noopener nofollow">Joysticks</a> , which serve as the standard input method.
<br>The use of Commands and Subsystems goes a long way to managing complex robot interactions across many subsystems. However, they're certainly tricky concepts to get right off the bat. <br><br>Sometimes, you'll have oddball constants that you need to access in multiple places in your code. Constants.java advertises itself as a place to sort and organize files. <br>Without getting too into the "why", in general you should minimize use of Constants.java; It leads to several problems as your robot complexity increases. <br>Instead, simply follow good practices for scope encapsulation, and keep the constants at the lowest necessary scope. <br>
<br>If a value is used once, just use a value. This includes a lot of setup values like PID tuning values.
<br>If your value is used repeatedly inside a subsystem, make it a private constant in that subsystem. This is common for conversion factors, min/max values, or paired output values
<br>If a constant is strongly associated with a subsystem, but needs to be referenced elsewhere, make it a public constant in that subsystem.
<br>Lastly, if something is not associated with a subsystem, and used repeatedly across multiple subsystems, constants.java is the place. 
<br>If you find yourself depending on a lot of constants, you might need to consider <a data-href="Refactoring" href="misc/refactoring.html" class="internal-link" target="_self" rel="noopener nofollow">Refactoring</a> your code a bit to streamline things.  Note that Stormbots code has almost nothing in here! ]]></description><link>level-1/robot-code-basics.html</link><guid isPermaLink="false">Level 1/Robot Code Basics.md</guid><pubDate>Tue, 10 Jun 2025 08:19:02 GMT</pubDate><enclosure url="lib/media/driverstation.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/driverstation.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Sensing Basics]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>Hardware: <br>
<br>Switches
<br>Encoder
<br>LaserCan
<br><br>
<br>Create a Trigger that represents a sensor condition
<br>Create a Joystick command that runs indefinitely, but stops when the Trigger is in a true condition. 
<br>Repeat with a different sensor type
<br>Create a Trigger that performs a Command automatically when triggered
<br><br>Sensing is interacting with physical objects, and changing robot behaviour based on it.<br>
This can use a variety of sensors and methods, and will change from system to system]]></description><link>level-1/sensing-basics.html</link><guid isPermaLink="false">Level 1/Sensing Basics.md</guid><pubDate>Mon, 02 Jun 2025 05:02:41 GMT</pubDate></item><item><title><![CDATA[State Machines]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Sensing Basics" href="level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br><br>
<br>
???

<br>
Covering system "state" is very useful, especially in subsystems

<br>
ConditionalCommand + SelectCommand can be useful for attributing actions and states on simple systems

<br>
Need to find a sensible formal way to cover it; It's easy to make "custom" state machines for simple systems, but hard to scale up in complexity with consistent patterns.

<br><br>
<br>States of Unloaded, unaligned, loaded, scoring
<br>Consideration: Explain state machines here, as an explanation of how they're used and what they represent<br>Actually make it a workshop later.]]></description><link>level-1/state-machines.html</link><guid isPermaLink="false">Level 1/State Machines.md</guid><pubDate>Sun, 08 Jun 2025 17:26:33 GMT</pubDate></item><item><title><![CDATA[SuperStructure Arm]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create an Arm subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world angle values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current angle
<br>Create a setAngle function that takes a angle, and returns a command that runs indefinitely to the target angle
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
]]></description><link>level-1/superstructure-arm.html</link><guid isPermaLink="false">Level 1/SuperStructure Arm.md</guid><pubDate>Mon, 02 Jun 2025 05:02:51 GMT</pubDate></item><item><title><![CDATA[SuperStructure Elevator]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br>
Reading Resources:<br>
<a data-href="Homing" href="Homing" class="internal-link" target="_self" rel="noopener nofollow">Homing</a><br><br>
<br>Create an Elevator subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current height
<br>Create a setHeight function that takes a height, and returns a command that runs indefinitely to the target height
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
]]></description><link>level-1/superstructure-elevator.html</link><guid isPermaLink="false">Level 1/SuperStructure Elevator.md</guid><pubDate>Mon, 02 Jun 2025 05:02:57 GMT</pubDate></item><item><title><![CDATA[SuperStructure Intake]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="SuperStructure Rollers" href="level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="Sensing Basics" href="level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br>Recommends:<br>
<a data-href="State Machines" href="level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a><br>Requires as needed:<br>
<a data-href="SuperStructure Rollers" href="level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="SuperStructure Elevator" href="level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
<a data-href="SuperStructure Arm" href="level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br><br>
<br>Create an "over the bumper" intake system
<br>Add a controller button to engage the intake process. It must retract when released
<br>The button must automatically stop and retract the intake when a game piece is retracted
<br><br>Intake complexity can range from very simple rollers that capture a game piece, to complex actuated systems intertwined with other scoring mechanisms. <br>A common "over the bumper" intake archetype is a deployed system that<br>
<br>Actuates outward past the frame perimeter
<br>Engages rollers to intake game piece
<br>Retracts with the game piece upon completion of a game piece
<br>The speed of deployment and retraction both impact cycle times, forming a critical competitive aspect of the bot. <br>The automatic detection and retraction provide cycle advantages (streamlining the driver experience), but also prevent fouls and damage due to the collisions on the deployed mechanism.]]></description><link>level-1/superstructure-intake.html</link><guid isPermaLink="false">Level 1/SuperStructure Intake.md</guid><pubDate>Mon, 02 Jun 2025 05:03:02 GMT</pubDate></item><item><title><![CDATA[SuperStructure Rollers]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>Recommends:<br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create a Roller subsystem
<br>Calibrate the system to use RPM
<br>Create Commands for running forward and backwards using the target RPM
<br>Bind them to commands to move the game piece forward or backward
<br>Create a default command that stops the subsystem
]]></description><link>level-1/superstructure-rollers.html</link><guid isPermaLink="false">Level 1/SuperStructure Rollers.md</guid><pubDate>Mon, 02 Jun 2025 05:03:08 GMT</pubDate></item><item><title><![CDATA[Triggers]]></title><description><![CDATA[ 
 <br><br>
<br>Start a command when the robot is enabled, and ends automatically
<br>


<br><br>
<br>Support command+trigger subsystem interfaces
<br>Model system state into binary regions
<br>loose coupling of subsystems
<br>Tolerances on sensors
<br>Joystick buttons = trigger ; Hidden common use case
<br>Starting commands with triggers
<br>ending commands with triggers
<br>sequencing component
]]></description><link>level-1/triggers.html</link><guid isPermaLink="false">Level 1/Triggers.md</guid><pubDate>Sun, 08 Jun 2025 22:42:01 GMT</pubDate></item><item><title><![CDATA[AdvantageKit]]></title><description><![CDATA[ 
 <br><br>
<br>??? Do we need or want this here? 
<br>Need to find a way to actually use it efficiently in beneficial way
<br><br>
<br>Understand how to set up Advantagekit
<br><a rel="noopener nofollow" class="external-link" href="https://docs.advantagekit.org/getting-started/what-is-advantagekit/" target="_blank">https://docs.advantagekit.org/getting-started/what-is-advantagekit/</a>]]></description><link>level-2/advantagekit.html</link><guid isPermaLink="false">Level 2/AdvantageKit.md</guid><pubDate>Mon, 02 Jun 2025 05:03:21 GMT</pubDate></item><item><title><![CDATA[Code Structuring]]></title><description><![CDATA[ 
 <br><br>
<br>Set up a mock project  with a nominal, standard code structure
<br>Project should have a subsystem that<br>
<br>Is in a subsystem folder
<br>Has 3 components in a (logic, <a data-href="Physics Simulation" href="level-2/physics-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">Physics Simulation</a>, <a data-href="Mechanism2d" href="level-2/mechanism2d.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanism2d</a>)
<br>Has a factory method to get a control command (can be mocked up)
<br>Has a trigger that indicates a mechanism state (can be mocked up based on timers)<br>
Has an additional sensor subsystem system that
<br>Provides a trigger for a condition (can be mocked up)<br>
Has a controller and<br>
Has an Autos class to hold autos
<br>With an auto chooser initialization 
<br>A single basic auto using subsystem and sensor
]]></description><link>level-2/code-structuring.html</link><guid isPermaLink="false">Level 2/Code Structuring.md</guid><pubDate>Mon, 02 Jun 2025 04:51:22 GMT</pubDate></item><item><title><![CDATA[Flight Trajectory Calculations]]></title><description><![CDATA[ 
 <br><br>
<br>


<br>Advanced computation for calculating optimal shot angles and rpms]]></description><link>level-2/flight-trajectory-calculations.html</link><guid isPermaLink="false">Level 2/Flight Trajectory Calculations.md</guid><pubDate>Mon, 02 Jun 2025 05:03:32 GMT</pubDate></item><item><title><![CDATA[Forward Kinematics]]></title><description><![CDATA[ 
 <br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/forwardkinematics" target="_blank">https://robotics-explained.com/forwardkinematics</a>]]></description><link>level-2/forward-kinematics.html</link><guid isPermaLink="false">Level 2/Forward Kinematics.md</guid><pubDate>Wed, 04 Jun 2025 23:23:21 GMT</pubDate></item><item><title><![CDATA[Inverse Kinematics]]></title><description><![CDATA[ 
 <br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/inversekinematics" target="_blank">https://robotics-explained.com/inversekinematics</a>]]></description><link>level-2/inverse-kinematics.html</link><guid isPermaLink="false">Level 2/Inverse Kinematics.md</guid><pubDate>Wed, 04 Jun 2025 23:22:09 GMT</pubDate></item><item><title><![CDATA[Lookup Tables]]></title><description><![CDATA[ 
 <br><br>
<br>


<br><br>A pre-computed list of input and output values.<br>Can be used to help model non-trivial conditions where mathematical models are complicated, or don't apply effectively to the problem at hand. <br>Commonly used for modelling <a data-href="Superstructure Shooter" href="level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Shooter</a> ]]></description><link>level-2/lookup-tables.html</link><guid isPermaLink="false">Level 2/Lookup Tables.md</guid><pubDate>Mon, 02 Jun 2025 05:04:06 GMT</pubDate></item><item><title><![CDATA[Mechanism2d]]></title><description><![CDATA[ 
 <br><br>
<br>Create a basic Arm or Elevator motion system
<br>Create a Mechanism 2D representation of the control angle
<br>Create additional visual flair on mechanism to help indicate mechanism context
]]></description><link>level-2/mechanism2d.html</link><guid isPermaLink="false">Level 2/Mechanism2d.md</guid><pubDate>Mon, 02 Jun 2025 05:04:22 GMT</pubDate></item><item><title><![CDATA[Motion Profiles]]></title><description><![CDATA[ 
 <br><br>
<br>Configure a motion system with PID and FeedForward
<br>Add a trapezoidal motion profile command (runs indefinitely)
<br>Create a decorated version with exit conditions
<br>Create a small auto sequence to cycle multiple points
<br>Create a set of buttons for different setpoints
]]></description><link>level-2/motion-profiles.html</link><guid isPermaLink="false">Level 2/Motion Profiles.md</guid><pubDate>Sat, 07 Jun 2025 18:57:58 GMT</pubDate></item><item><title><![CDATA[NetworkTables]]></title><description><![CDATA[ 
 <br><br>
<br>???
<br>


<br><br>
<br>General Debugging
<br><a data-href="Limelight Basics" href="level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight Basics</a>
<br><a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>
<br><a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a>
<br>Odometry Tasks
]]></description><link>level-2/networktables.html</link><guid isPermaLink="false">Level 2/NetworkTables.md</guid><pubDate>Mon, 02 Jun 2025 05:04:36 GMT</pubDate></item><item><title><![CDATA[PhotonVision Basics]]></title><description><![CDATA[ 
 <br><br>Interact with the PhotoVision UI and basic code structures<br><br>
<br>Connect to the WebUI
<br>Set up a camera
<br>Set up AprilTag Target
<br>Read target position via NT
<br><br>This allows you to access PhotonVision via the roborio USB port.<br>
This can be useful when debugging at competitions<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.photonvision.org/en/latest/docs/quick-start/networking.html" target="_blank">https://docs.photonvision.org/en/latest/docs/quick-start/networking.html</a>]]></description><link>level-2/photonvision-basics.html</link><guid isPermaLink="false">Level 2/PhotonVision Basics.md</guid><pubDate>Thu, 19 Jun 2025 01:02:36 GMT</pubDate></item><item><title><![CDATA[PhotonVision Bringup]]></title><description><![CDATA[ 
 <br><br>
<br>Configure the PV networking
<br>Configure the PV hardware
<br>Set up a camera
<br>Create a Vision code class
<br>Configure PV class to communicate with the hardware
]]></description><link>level-2/photonvision-bringup.html</link><guid isPermaLink="false">Level 2/PhotonVision Bringup.md</guid><pubDate>Mon, 02 Jun 2025 04:54:01 GMT</pubDate></item><item><title><![CDATA[PhotonVision Model Training]]></title><description><![CDATA[ 
 <br><br>
<br>Oh no
]]></description><link>level-2/photonvision-model-training.html</link><guid isPermaLink="false">Level 2/PhotonVision Model Training.md</guid><pubDate>Mon, 02 Jun 2025 04:54:09 GMT</pubDate></item><item><title><![CDATA[PhotonVision Object Detection]]></title><description><![CDATA[ 
 <br><br>
<br>Add a Object detection pipeline
<br>Detect a game piece using color detection
<br>if available, detect it using a ML object model 
]]></description><link>level-2/photonvision-object-detection.html</link><guid isPermaLink="false">Level 2/PhotonVision Object Detection.md</guid><pubDate>Mon, 02 Jun 2025 04:54:18 GMT</pubDate></item><item><title><![CDATA[PhotonVision Odometry]]></title><description><![CDATA[ 
 <br><br>
<br>Set up a pipeline to identify april tags
<br>Configure camera position relative to robot center
<br>Set up a
]]></description><link>level-2/photonvision-odometry.html</link><guid isPermaLink="false">Level 2/PhotonVision Odometry.md</guid><pubDate>Mon, 02 Jun 2025 04:54:33 GMT</pubDate></item><item><title><![CDATA[Physics Simulation]]></title><description><![CDATA[ 
 <br><br>
<br>Create a standard Arm or Elevator
<br>Model the system as a Mechanism2D
<br>Create a Physics model class
<br>Configure the physics model
<br>Tune the model to react in a sensible way. It does not need to match a real world model
]]></description><link>level-2/physics-simulation.html</link><guid isPermaLink="false">Level 2/Physics Simulation.md</guid><pubDate>Mon, 02 Jun 2025 04:54:36 GMT</pubDate></item><item><title><![CDATA[Singletons]]></title><description><![CDATA[ 
 <br><br>
<br>Create a Singleton class
<br>Use it in multiple places in your code
<br><br>Coding structure that represents a unique entity, of which only one can assist. <br>Commonly used in WPILib to model physical harware ]]></description><link>level-2/singletons.html</link><guid isPermaLink="false">Level 2/Singletons.md</guid><pubDate>Mon, 02 Jun 2025 04:54:51 GMT</pubDate></item><item><title><![CDATA[SuperStructure Flywheel]]></title><description><![CDATA[ 
 <br>Superstructure component that holds a large amount of kinetic energy at a high velocity. Typically paired with shooters.<br><br>
<br>Create a Flywheel system
<br>Tune with appropriate FeedForwards + PID to hit and maintain target RPMs 
<br>


<br><br><a data-href="System Identification" href="level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a><br>
<a data-href="Lookup Tables" href="level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>]]></description><link>level-2/superstructure-flywheel.html</link><guid isPermaLink="false">Level 2/SuperStructure Flywheel.md</guid><pubDate>Mon, 02 Jun 2025 04:55:06 GMT</pubDate></item><item><title><![CDATA[Superstructure Indexer]]></title><description><![CDATA[ 
 <br>Superstructure component that adds additional control axes between intakes and scoring mechanisms.<br> Common when handling multiple game pieces for storage and alignment, or when handling flywheel systems that must isolate game piece motion from superstructure motion<br> Often referred to as a "feeder" depending on the usage intent<br>]]></description><link>level-2/superstructure-indexer.html</link><guid isPermaLink="false">Level 2/Superstructure Indexer.md</guid><pubDate>Mon, 02 Jun 2025 04:55:22 GMT</pubDate></item><item><title><![CDATA[Superstructure Shooter]]></title><description><![CDATA[ 
 <br>A shooter is simply a flywheel and supporting infrastructure for making game pieces fly from a robot<br><br>
<br>


<br>Typically a "shooter" consists of <br>
<br>a <a data-href="SuperStructure Flywheel" href="level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a> to serve as a mechanical means to maintain momentum
<br>A <a data-href="Superstructure Indexer" href="level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Indexer</a> to time shots and ensure the shooter is at the indended speed
<br>A targeting system, often using Odometry or Vision
<br>A trajectory evaluation to control target RPM. This can be fixed targets, <a data-href="Lookup Tables" href="level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>, or more complex trajectory calculations
]]></description><link>level-2/superstructure-shooter.html</link><guid isPermaLink="false">Level 2/Superstructure Shooter.md</guid><pubDate>Mon, 02 Jun 2025 04:56:29 GMT</pubDate></item><item><title><![CDATA[Swerve Basics]]></title><description><![CDATA[ 
 <br><br>
<br>Understand how swerve works
<br>Teleop Interactions for existing swerve
<br>Reading odometry
<br>Reset/Initialize odometry 
<br><br>
<br>Use an existing Swerve configuration
<br>
]]></description><link>level-2/swerve-basics.html</link><guid isPermaLink="false">Level 2/Swerve Basics.md</guid><pubDate>Mon, 02 Jun 2025 04:56:56 GMT</pubDate></item><item><title><![CDATA[Swerve Bringup]]></title><description><![CDATA[ 
 <br><br>
<br>Create new drive subsystem 
<br>Create and configure a YAGSL drivetain
<br>Tune Yagsl drivetrain and controls for manual driving
<br>Adjust parameters to ensure accurate auto driving and odometry tracking
<br>
]]></description><link>level-2/swerve-bringup.html</link><guid isPermaLink="false">Level 2/Swerve Bringup.md</guid><pubDate>Mon, 02 Jun 2025 04:57:01 GMT</pubDate></item><item><title><![CDATA[Swerve Motion]]></title><description><![CDATA[ 
 <br><br>Interface with swerve for autos and non-trivial teleop interactions<br><br>
<br>Changing point of rotation in real time
<br>Move from Point to Point using a PID
<br>Move from point to point using a motion profile
<br>Create a command that allows translation while aimed at a bearing
<br>Create a command that allows translation while aimed at a Pose2d
]]></description><link>level-2/swerve-motion.html</link><guid isPermaLink="false">Level 2/Swerve Motion.md</guid><pubDate>Mon, 02 Jun 2025 04:57:24 GMT</pubDate></item><item><title><![CDATA[Swerve Odometry]]></title><description><![CDATA[ 
 ]]></description><link>level-2/swerve-odometry.html</link><guid isPermaLink="false">Level 2/Swerve Odometry.md</guid><pubDate>Sat, 31 May 2025 09:11:52 GMT</pubDate></item><item><title><![CDATA[System Identification]]></title><description><![CDATA[ 
 <br>Part of:<br>
<a data-href="SuperStructure Flywheel" href="level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a><br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br><br>
<br>
]]></description><link>level-2/system-identification.html</link><guid isPermaLink="false">Level 2/System Identification.md</guid><pubDate>Mon, 02 Jun 2025 04:57:42 GMT</pubDate></item><item><title><![CDATA[Threading]]></title><description><![CDATA[ 
 <br>Ways to manage multiple, simultaneous operations happening on the robot<br><br>
<br>


<br><br>]]></description><link>level-2/threading.html</link><guid isPermaLink="false">Level 2/Threading.md</guid><pubDate>Mon, 02 Jun 2025 04:59:00 GMT</pubDate></item><item><title><![CDATA[Closed Loop Controller]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/revlib/spark/closed-loop" target="_blank">https://docs.revrobotics.com/revlib/spark/closed-loop</a><br>Additional reading from <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> <br><br>as derived on the <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> lecture, a Bang Bang controller looks at the error, and emits full output power depending on whether it's above or below. <br>class BangBang(){
	double max=1;
	double min=0;

	double calculate(double sensor, double setpoint){
		if(sensor &lt; setpoint){ return max ; }
		else if(sensor &gt;= setpoint){ return min; }
	}
}
<br>This kind of controller tends to be sub-optimal on most systems, but is useful in situations where you have <br>
<br>Analog inputs
<br>Binary outputs
<br>Comparatively large inertia relative to system power. 
<br><br>Hysteresis is a resistance to state changes, with numerous applications in physics and control theory, both advantageous and otherwise.<br>In control theory, hysteresis is often utilized intentionally to prevent rapid switching when a system is at setpoint, as shown in this modified bang-bang controller.<br>class BangBangWithHysterisis(){
	double threshhold=1;
	double max=1;
	double min=0;
	double currentValue=0
	
	double calculate sensor, double setpoint){
		if(sensor &lt; setpoint-threshhold){ currentValue=max}
		else if(sensor &gt;= setpoint+threshhold){ currentvalue=min}
		return currentValue;
	}
}
<br>In this code, you can see that if a setpoint is within 1 of the setpoint, it doesn't turn off or turn on; It simply does what it was already doing.<br>This creates both slight overshoot and slight undershoot, but creates a range of acceptable values, which is often suitable for applications where a standard BangBang controller would be used.<br>This is something you'll commonly see on automatic heaters: As the room cools, they turn on when you're too cold, and only turn off once you're a bit too warm, and the cycle repeats. You're never quite at the temperature you want, but generally pretty close to it. The hysteresis ensures that the heater always changes the temp by several degrees at once.<br>Hysteresis is also seen in automatic shifting algorithms in both cars and robots; This avoids unnecessary gear changes within ranges where either gearing is equally effective.<br><br>Similar to a Bang Bang (formally known as a two-point controller), a three-point controller has on/off/reverse.<br>class BangBangWithHysterisis(){
	double threshhold=1;
	double max=1;
	double min=-1;
	double off=0
	double currentValue=0
	
	double calculate sensor, double setpoint){
		if(sensor &lt; setpoint-threshhold){ currentValue=max}
		else if(sensor &gt;= setpoint+threshhold){ currentvalue=min}
		return off;
	}
}
<br>This looks a lot like the hysterisis control, but instead of overshooting through the middle zone, it simply turns off.<br>While not common in modern FRC, this control mode is very common in many real world applications due to the simple, cheap electronics needed to operate it. <br>In past FRC seasons, this type of control was used for relay controlled motors. It can also be used alongside two-pole pnuematic systems for somewhat analog control in air positioned systems. <br><br>This is an odd, but useful technique, as much as a specific algorithm. By taking the square root of the error, then applying a gain, you get a sharp, aggressive response for small errors, but decreasingly aggressive as the error increases further.<br>class SquareRootError(){
	gain = 0.1
	
	double calculate(double sensor, double setpoint,){
		error = setpoint-sensor 
		output = gain * Math.signOf(error) * Math.sqrt(Math.abs(Error))
		return output;
	}
}
<br>This simple algorithm tends to generate a "springy" response to disturbances, is simple to tune, and typically can hit the setpoint reliably under a wider variety of disturbance conditions.<br>This algorithm tends to work well for velocity systems like <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a>, <a data-tooltip-position="top" aria-label="Superstructure Shooter" data-href="Superstructure Shooter" href="level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Shooters</a>, or Drivetrains. When tuned effectively, disturbances will tend to generate the right amount of output to add momentum to the system, quickly getting things back to the velocity target.<br>The major flaw of this algorithm stems from the tendency to result in high frequency oscillation at the setpoint, especially for systems with notable backlash. Using a <a data-tooltip-position="top" aria-label="Slew Rate Limiting" data-href="Slew Rate Limiting" href="misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiter</a> on the output can improve response in these cases. <br>It can also be useful for following position or velocity targets generated by <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>, but the sharp oscillations make it sub-optimal for holding position in steady state scenarios.]]></description><link>misc/closed-loop-controller.html</link><guid isPermaLink="false">Misc/Closed Loop Controller.md</guid><pubDate>Tue, 10 Jun 2025 08:11:22 GMT</pubDate></item><item><title><![CDATA[Driver Station]]></title><description><![CDATA[ 
 <br><img alt="driverstation.jpg" src="lib/media/driverstation.jpg">]]></description><link>misc/driver-station.html</link><guid isPermaLink="false">Misc/Driver Station.md</guid><pubDate>Sun, 08 Jun 2025 17:44:12 GMT</pubDate><enclosure url="lib/media/driverstation.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/driverstation.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Git Basics]]></title><description><![CDATA[ 
 <br><br>Understand the typical Git operations most helpful for day-to-day programming<br><br>This module is intended to be completed alongside other tasks.<br>
<br>Initialize a git repository in your project
<br>Create an initial commit
<br>Create several commits representing simple milestones in your project
<br>When moving to a new skill card, create a new branch to represent it. Create as many commits on the new branch as necessary to track your work for this card. 
<br>When working on a skill card that does not rely on the previous branch, switch to your main branch, and create a new branch to  represent that card.
<br>On completion of that card (or card sequence), merge the results of both branches back into Main.
<br>Upon resolving the merge, ensure both features work as intended.
<br><br>
<br>Understanding git
<br>workspace, staging, remotes
<br>fetching
<br>Branches + commits
<br>Pushing and pulling
<br>Switching branches
<br>Merging
<br>Merge conflicts and resolution
<br>Terminals vs integrated UI tools
<br>In general<br><br><br><a rel="noopener nofollow" class="external-link" href="https://mermaid.live/edit#pako:eNqFUM1OxiAQfJUve24aaAulXDXx5AuYXrDsR4kFGgSjNn13sZ8_ica4p9nZmdlkNpiCRpBgbLqJap1HfyozBeds-o3vo_LTfNL4hEtYP-4zTg8hpx_sHwlfaqesv1AOo8H_3FCBiVaDTDFjBcVTAsoK27tqhDSjwxFkgRrPKi9phNHvxbYqfxeC-3TGkM0M8qyWx7LlVauE11aZqL4l6DXGq5B9AkmHIwLkBs8gG8Fq3lLBeccY6QWt4KWwhNU960jXsn6ghDK-V_B6PCW1oJQ2HWt4OwhOBasAtU0h3l6KP_rf3wA0I3rV" target="_blank">https://mermaid.live/edit#pako:eNqFUM1OxiAQfJUve24aaAulXDXx5AuYXrDsR4kFGgSjNn13sZ8_ica4p9nZmdlkNpiCRpBgbLqJap1HfyozBeds-o3vo_LTfNL4hEtYP-4zTg8hpx_sHwlfaqesv1AOo8H_3FCBiVaDTDFjBcVTAsoK27tqhDSjwxFkgRrPKi9phNHvxbYqfxeC-3TGkM0M8qyWx7LlVauE11aZqL4l6DXGq5B9AkmHIwLkBs8gG8Fq3lLBeccY6QWt4KWwhNU960jXsn6ghDK-V_B6PCW1oJQ2HWt4OwhOBasAtU0h3l6KP_rf3wA0I3rV</a>]]></description><link>misc/git-basics.html</link><guid isPermaLink="false">Misc/Git Basics.md</guid><pubDate>Sat, 07 Jun 2025 20:05:45 GMT</pubDate></item><item><title><![CDATA[Joysticks]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/basic-programming/joystick.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/basic-programming/joystick.html</a> <br><br>Through experience, we've found that we often have multiple joysticks, a lot of different projects, and a lot of computers. <br>Not surprisingly, if you wind up trying to read the wrong inputs from the wrong joysticks, you can end up with a lot of surprises, sometimes dangerously so. <br>As a result, we found the best resolution is to simply define <br>
<br>Joystick 0 is always the "main" joystick, typically for the driver. 
<br>Joystick 1 is always the "operator" joystick for auxiliary controls. 
<br>In code, we'd represent this as <br>Joystick driverInput = new Joystick(0);
Joystick operatorInput = new Joystick(1);
<br>Then, in the <a data-href="Driver Station" href="misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a> , make sure that it picks up the corresponding controllers in the same order: 0 for main/driver, and 1 for operator. <br>]]></description><link>misc/joysticks.html</link><guid isPermaLink="false">Misc/Joysticks.md</guid><pubDate>Sun, 08 Jun 2025 18:54:51 GMT</pubDate></item><item><title><![CDATA[Lambdas]]></title><description><![CDATA[ 
 <br><br>A "Lambda" is also known as an "anonymous function" . In a general sense, lambda's are just a quirky syntax to create "on the fly" functions, and otherwise work basically like any other function. <br>In WPILib code, it's common to want to pass procedures and code blocks to  <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> and <a data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a>, allowing those functions to know "how to get new values", rather than just what the values are when you first try to set them up. This is critical for real-time decisions, like "is a game piece loaded?" which you won't know when creating the command. <br>WPILib has good further reading that might assist with understanding.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/basic-programming/functions-as-data.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/basic-programming/functions-as-data.html</a><br><br>Functions should be common to most programmers. Let's take a look at the obvious properties of a function to make sure we're well set. <br>
<br>A name of the function
<br>A list of parameters
<br>And a returned value
<br>associated code to run
<br>For something like <br>public void sayHello(String name){print("hello "+name);}; 
<br>we can see that <br>
<br>the name is sayHello
<br>There is one parameter, named name
<br>There is code that prints a greeting and the name
<br>The return type is void, or has no return value. 
<br>However, another sneaky property is the function's scope. Scope represents variables and functions that the function has access to that are not strictly part of the function itself.  For Java, this often indicates files in the same class. This too should look familiar:<br>public class ExampleClass{
	String greeting="sup ";
	public void sayHello(String name){print(greeting+name);}; 
}
<br>Here, greeting is part of sayHello's scope, but not part of the function itself. This is a property of the function, even if it's not an apparent one. <br><br>This example takes uses Commands.run(), which takes a Runnable object, and executes once per robot loop. A Runnable simply describes "a function that takes no argument, and returns no values". We'll come back to this. <br>We can pass this to a command in two different ways<br>//Create a named function like we're used to
// and then pass a reference to it
void printSomething(){System.out.println("something");}	
Commands.run(this::printSomething);

//Or, just create it directly.
Commands.run(()-&gt;{System.out.println("something");});
}
<br>We can see that a lambda looks very similar to a function, with effectively the same structure. <br>// return type | function name | parameter list | the code block
void             printSomething   ()           {System.out.println("something");}
                                  ()       -&gt;  {System.out.println("something");}
<br>The primary difference is the missing function name, and lack of explicit return type. We don't need a name because it's anonymous. We don't need a return type, because it's declared by the Command's argument type: Runnable.<br>
The main difference is the -&gt; ; This is just the special lambda syntax. It might help to consider it as "goes to" or "yields" ; as in the parameter list (...) yields a value {block of code}.<br><br>Just as "Runnable" defines "A function that accepts no arguments and returns nothing", there's a whole bunch of standard references for functions that "Take X" and "Return X". <br>These are generally broken down into Suppliers (returns a value) and Consumers (accepts a value). Here's a few.<br>Runnable // takes nothing, and returns nothing. Just a pure code block.
BooleanSupplier // A function that takes nothing, and returns a boolean
DoubleSupplier // A function that accepts nothing, and returns a double

BooleanConsumer // Function that takes a boolean and returns nothing.
<br>That's about it! These helper classes <br><br>A great reference is the FunctionalCommand class. This class takes 4 lambdas, replacing each of the core parts of a <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> with a simple code. It looks like this. <br>FunctionalCommand(
	Runnable, //initialize
	Runnable, //execute
	BooleanSupplier, //isFinished ; returns a boolean
	BooleanConsumer // end; takes a boolean that indicates if it was cancelled.
);
<br>Let's say we want to create a command that <br>
<br>Print the time it starts
<br>how long it ran, and if it was successful
<br>End 5 seconds after it starts
<br>double startTime=0;
new FunctionalCommand(
	()-&gt;{//initialize by recording the time
		startTime=Timer.getFPGATimestamp();
		System.out.println(startTime);
	},
	()-&gt;{}, //execute: do nothing
	()-&gt;{return Timer.getFPGATimestamp()-startTime&gt;=5}, //isFinished
	(cancelled)-&gt;{ //our end block
		System.out.println(Timer.getFPGATimestamp()-startTime);
		System.out.println(cancelled);
	}
<br>Hooray! This works, and leads us to a useful confirmation: Like any other function, you can access any variable in the current scope in which it was created.<br>When we combine this feature with <a data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> and the Factory pattern for commands, we can have "function scope" variables to serve as data between the components of the command. <br>This scope access also is a large value add when creating <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> inside of <a data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>. We can just access useful constants, motors, encoders, and helper functions without any extra setup.<br><br>It's often helpful to take functions as arguments. This allows you to isolate the code you're writing from objects that create that data. <br>Let's create a function that takes two lambdas, and returns the value of the larger one. You <br>Double myFunction(DoubleSupplier left, DoubleSupplier right){
	var letfvalue = left.getAsDouble();
	var rightvalue = right.getAsDouble();
	if(letfvalue &gt; rightvalue) return left;
	return right;
}
<br>This command doesn't do much in practice, but demonstrates the process. A more utilitarian practice is something like a "Drive" command on the robot; Sure, you could take a Joystick object, and then read from that. But, what if you want to feed it values from a Vision process? Vision doesn't have a joystick, so, you need a new entire Drive command for it. If you want to use a rangefinder? Another whole  drive command.<br>Instead, creating a DoubleSupplier interface means your drive command can get values from arbitrary functions, making them much more generic and helpful.]]></description><link>misc/lambdas.html</link><guid isPermaLink="false">Misc/Lambdas.md</guid><pubDate>Sat, 14 Jun 2025 04:25:14 GMT</pubDate></item><item><title><![CDATA[PathPlanning Tools]]></title><description><![CDATA[ 
 <br><br>
<br>Choose a PathPlanning tool
<br>Implement the Java framework for the selected tool
<br>Model the robot's physical parameters for your tool
<br>Drive a robot along a target trajectory using one of these tools
<br>Followup to:<br>
<a data-href="Auto Differential" href="level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Swerve Motion" href="level-2/swerve-motion.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Motion</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html</a><br>
<a rel="noopener nofollow" class="external-link" href="https://choreo.autos/" target="_blank">https://choreo.autos/</a><br>
<a rel="noopener nofollow" class="external-link" href="https://pathplanner.dev/home.html" target="_blank">https://pathplanner.dev/home.html</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html</a><br><br>Do you need path planning to make great autos? Maybe! But not always.<br>PathPlanning can give you extremely fast, optimized autos, allowing you to squeeze every fraction of a second from your auto. However, it can be challenging to set up, and has a long list of requirements to get even moderate performance.<br><br><br>Unlike "path planning" algorithms that attempt to define and predict robot motion, Pure Pursuit simply acts as a reactive path follower, as the name somewhat implies.<br><a rel="noopener nofollow" class="external-link" href="https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html" target="_blank">https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html</a><br>
<img alt="pathfinding-pure-pursuit.png" src="lib/media/pathfinding-pure-pursuit.png"><br>This algorithm is fairly simple and conceptually straightforward, but with some notable limitations. However, the concept is very useful for advancing simpler autos]]></description><link>misc/pathplanning-tools.html</link><guid isPermaLink="false">Misc/PathPlanning Tools.md</guid><pubDate>Thu, 19 Jun 2025 01:44:30 GMT</pubDate><enclosure url="lib/media/pathfinding-pure-pursuit.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/pathfinding-pure-pursuit.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Refactoring]]></title><description><![CDATA[ 
 <br>Refactoring is the process of re-structuring your code without notably altering the actual behavior of your code. <br>Refactoring is a very common programming practice, serving purposes from performance, readability, maintainability, de-duplication, and as preparation for further work. <br><br>Refactoring tends to focus on how you manage complexity across your program. The way you represent your problem space in code is commonly called an "Abstraction". <br>A good abstraction enables you to do complicated things easily and focus on solving problems, without having to think too hard on how they're being solved.<br>Without a good abstraction, the programmer will often trip over this complexity time and time again, distracting from the bigger picture problems.<br>A bad abstraction does more harm than good. This can range from being misleading, adding more complexity than it reduces, or just restricting you without good cause.   <br>Refactoring is, in a nutshell, finding a better abstraction. <br><br>You'll often times hear the term "code smell" when it comes to identifying this type of issue. Just like a weird smell in your house, you can probably ignore it for a bit, but the longer you do, the harder it is to avoid. And, like a smell, the first sign is usually not the actual problem, but a symptom. You have to track it to the source, and once dealt with, the impact is bigger than it might first seem.<br>Creating this type of problem isn't a programmer failing though. Whenever a codebase grows in complexity, there's going to be little rough edges, quirks, and special cases left over. Left unchecked, you can easily build on these until they grow into major pitfalls that can completely stop progress.<br>Part of being a good programmer is learning how to identify such issues, form a corrective plan, and tidy up while it's still manageable. <br><br>Duplication tends to be the re-use of small bits of code just here and there. Eventually you might notice that this same bit of code is all over the place, sometimes slightly adjusted or modified. Importantly, you're probably suddenly seeing it because there's a bug in one copy.... that's probably in many of them. <br><br>Readability tends to refer to the simple things in your code: Having good, clear naming conventions, having good indentation, and consistent bracket use.<br>It can also dip a bit into consistent writing patterns. Do your boolean functions swap between isSystemLoaded and isSystemClear ? Do different subsystems have different units?<br>These things don't strictly impact the way the code actually works, but can significantly impact the productivity of programmers working on it! In a multi-user setting, it's easy to tell if readability is off, because you'll probably have just as hard of a time reading their code as they do yours. <br><br>Somewhat tied to the above, maintainability issues dip into the underlying structure a bit more. This normally shows up that the code just breaks more often than you think it should. Little changes cause random other problems, especially on parts of the code unrelated to what you're working on. <br>This can also show up in noticing that the way your code is structured requires a lot of repetitive syntax to deal with, or functions that are not particularly useful in the current state.<br><br>Very much a vibe check; Is your code just feeling difficult to add new code into? Is getting it to do what you want requiring a lot of mental overhead that's not related to solving bigger problems? <br><br>With a need for a refactor identified, it's time to actually do it. There's no hard-and-fast routine, but here's a good starting point <br><br><br><a data-tooltip-position="top" aria-label="Git Basics" data-href="Git Basics" href="misc/git-basics.html" class="internal-link" target="_self" rel="noopener nofollow">git</a> is your friend! Git makes it easier to see big, sweeping changes, and see what bits you changed. It also, critically, ensures that if you get it wrong, you can easily start over and try again. Once you have a known good restore point, be fearless! Rip it apart!<br><br>Get your code to a working state. Sometimes it means powering through what whatever code you were trying to add. Sometimes it's pulling your code out and putting it off for a bit.<br>
Basically, If your code doesn't work when you start the refactor, it's harder to judge if the refactor did what it was supposed to: Be cleaner, nicer, and work as it did before. <br><br>This is the hard part. You've gotten a whiff of the problem, but probably don't yet know how deep it goes, and you might not have a full picture of the solution solution quite yet. That's OK. <br>One way to do it is find one of the spots that seem off, and just fix it. This will probably break something else, but that's alright. Fix that up too. Tidy it up. Sometimes doing this simple process leads you a good solution.<br>In the case that some simple poking didn't fix things, you may need to zoom out, and look at the big picture a bit more. Not just lines of code, but where whole functions and processes are kept. Sometimes you back yourself into a corner. Find the biggest problem you're dealing with, and just fix it in the quickest way possible, move things around, and see if that sparks any ideas for how to organize it. Be fearless! you always have <a data-tooltip-position="top" aria-label="Git Basics" data-href="Git Basics" href="misc/git-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Git</a> at your disposal to get back to your starting point. <br><br>With luck, poking around at the problems has led you to a better way to model your problems in code, and gotten you a few game plans. <br>Now, you just have to do the legwork of tidying it up, making your cleanup routine the "new standard" for the project, and seeing if it brings up any new problems. <br>If you see any new problems, consider trying to plan ahead. Often, just a few minutes of planning can help avoid a refactor down the line, or at least make it easier. <br><br>A common error we've run into before is setting up <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> -&gt; Robotcontainer interfaces in the wrong convention. These looked like so.<br>//A custom subsystem class
ExampleRollers extends subsystem base

	public void runMotor(double power){/*code to run motor*/}
	public boolean thingLoaded(){/*checks a sensor*/}
}
<br>//in robot container
joystick.a().whileTrue(Commands.run(exampleRollers.runMotor(1),exampleRollers));
joystick.b().whileTrue(Commands.run(exampleRollers.runMotor(-1),exampleRollers));
<br>With just a few lines, we're able to start seeing some weird structural problems. <br>
<br>Duplication: We're typing out that Commands.run(...,...) bit a whole lot. We also don't seem to be using runMotor in any other way either.
<br>Maintainability: You have to remember the requires every time you run one of these commands! That's a booby trap waiting to happen. 
<br>Readability: It's unclear what directions 1 and -1 mean. It's probably guessable, but no the code doesn't make it clear, or provide guidelines.  
<br>Code Pushback: Let's say you want to have runMotor stop automatically when running forward, and do a quick jolt when running backwards to fix a jamming issue. You might rightly assume this should be in the subsystem.... but the structure doesn't support it. You have to put it in RobotContainer, creating a bunch of new commands. And if there's another use of the eject or intake added later, you're duplicating all this!
<br>Let's walk through and check some specific problems and potential solutions:<br>
<br>We want to remove the unnecessary syntax headaches when trying to run the subsystem
<br>We want to clear up the Requires mess, and make that automatic as part of our function call
<br>We want to make the actual actions read clearer, and avoid arbitrary values
<br>We want to be set up to to build more complex sequences easily.
<br>Let's start with the first one. We can do this by just shoving those inside the subsystem.<br>//A custom subsystem class
ExampleRollers extends subsystem base
	public void runMotor(double power){/*code to run motor*/}
	public boolean thingLoaded(){/*checks a sensor*/}

	public Command runMotorCommand(double power){
		return Commands.run(this.runMotor(1),this);
	}
}
<br>//in robot container
joystick.a().whileTrue(exampleRollers.runMotorCommand(1));
joystick.b().whileTrue(exampleRollers.runMotorCommand(-1));
<br>So far so good! This shortens the robotContainer up quite a bit. We also notice that this handily cleans up the risk of a forgotten Requires.<br>Next, we want to clarify the actions. Unfortunately, the action is tied to the value we provide. So we need to avoid passing in a value. This means we can't use the same function in both places, but that's OK. Let's just assign names and shortcuts and keep going. <br>//A custom subsystem class
ExampleRollers extends subsystem base
	public void runMotor(double power){/*code to run motor*/}
	public boolean thingLoaded(){/*checks a sensor*/}

	public Command runMotorCommand(double power){
		return Commands.run(this.runMotor(1),this);
	}
	public Command intake(){return runMotorCommand(1);}
	public Command eject(){return runMotorCommand(-1);}
}
<br>//in robot container
joystick.a().whileTrue(exampleRollers.intake());
joystick.b().whileTrue(exampleRollers.eject());
<br>This is looking good! Our RobotContainer now looks super clean! The subsystem is also pretty good. We're slowly building more complicated bits on top of each other, and we're not duplicating code in the process.<br>At this point, nothing we've done changes how the code works. We've just shuffled things around, and changed where we manage various details. A good refactor! <br>Now, we're ready to tackle what we wanted to do: Add some features to stop the intake once it's loaded, and jostle things a bit before ejecting them. Fortunately, this is now really easy; We're well set up for it. <br>//A custom subsystem class
ExampleRollers extends subsystem base
	public void runMotor(double power){/*code to run motor*/}
	public boolean isThingLoaded(){/*checks a sensor*/}

	public Command runMotorCommand(double power){
		return Commands.run(this.runMotor(1),this);
	}
	public Command intake(){return runMotorCommand(1);}
	public Command eject(){
		//Jolt the system because it jams or something!
		return Commands.sequence(
			runMotorCommand(1).withTimeout(0.1), 
			runMotorCommand(-1),
		);
	}
}
<br>//in robot container
joystick.a().whileTrue(exampleRollers.intake().until(example::isThingLoaded));
joystick.b().whileTrue(exampleRollers.eject());
<br>Without getting to the weeds of  <a data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> and <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> best practices, part of the problem was solved by modifying a created command in RobotContainer, and part of it the base command created in the subsystem. The important detail is that we can fix things easily and properly. ]]></description><link>misc/refactoring.html</link><guid isPermaLink="false">Misc/Refactoring.md</guid><pubDate>Thu, 12 Jun 2025 20:14:06 GMT</pubDate></item><item><title><![CDATA[Robot Radio]]></title><description><![CDATA[ 
 <br>See Official Documentation
The official radio documentation is complete and detailed, and should serve as your primary resource.<br>
<a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/" target="_blank">https://frc-radio.vivid-hosting.net/</a>
However, It's not always obvious what you need to look up to get moving. Consider this document just a simple guide and jumping-off point to find the right documentation elsewhere
<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/quick-start-guide" target="_blank">https://frc-radio.vivid-hosting.net/overview/quick-start-guide</a><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html" target="_blank">https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html</a><br><br>You don't! The Field Technicians at competitions will program the radio  for competitions. <br>When configured for competition play, you cannot connect to the radio via wifi. Instead, use an ethernet cable, or <br><br>The home radio configuration is a common pain point<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview" target="_blank">https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview</a><br><br>This option is the simplest: Just connect the robot via an ethernet or USB, and do whatever you need to do. For quick checks, this makes sense, but obviously is suboptimal for things like driving around. <br><br>The radio does have a 2.4ghz wifi hotspot, albeit with some limitations. This mode is suitable for many practices, and is generally the recommended approach for most every-day practices due to ease of use.<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions" target="_blank">https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions</a><br>Note, this option requires access to the tiny DIP switches on the back of the radio! You'll want to make sure that your hardware teams don't mount the radio in a way that makes this impossible to access. <br><br>This option uses a second radio to connect your laptop to the robot. This is the most cumbersome and limited way to connect to a robot, and makes swapping who's using the bot a bit more tricky. <br>However, this is also the most performant and reliable connection method. This is recommended when doing extended driving sessions, final performance tuning, and  other scenarios where you're trying to simulate competition-ready environments. <br>This option has a normal robot on one end, and your driver-station setup will look the following image.  See <a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/practicing-at-home" target="_blank">https://frc-radio.vivid-hosting.net/overview/practicing-at-home</a> for full setup directions<br>
<img alt="vidid-radio-wifi-bridge.png.png" src="lib/media/vidid-radio-wifi-bridge.png.png"><br><br><br>Port forwarding allows you to bridge networks across different interfaces. <br>The practical application in FRC is being able to access network devices via the USB interface! This is mostly useful for quickly interfacing with Vision hardware like the <a data-tooltip-position="top" aria-label="Limelight Basics" data-href="Limelight Basics" href="level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight</a> or <a data-tooltip-position="top" aria-label="PhotonVision Basics" data-href="PhotonVision Basics" href="level-2/photonvision-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Photonvision</a> at competitions.<br>//Add in the constructor in Robot.java or RobotContainer.java

// If you're using a Limelight
PortForwarder.add(5800, "limelight.local", 5800);
// If you're using PhotonVision
PortForwarder.add(5800, "photonvision.local", 5800);
<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html" target="_blank">https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html</a><br><br>The radio has some scriptable interfaces, allowing programmatic access to quickly change or read settings. <br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced" target="_blank">https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced</a>]]></description><link>misc/robot-radio.html</link><guid isPermaLink="false">Misc/Robot Radio.md</guid><pubDate>Thu, 19 Jun 2025 01:55:19 GMT</pubDate><enclosure url="lib/media/vidid-radio-wifi-bridge.png.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/vidid-radio-wifi-bridge.png.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slew Rate Limiting]]></title><description><![CDATA[ 
 <br><br>Slew Rate Limiting is a simple numerical filter that constrains the rate of change of some value. This can be very useful in multiple situations to prevent unexpected sharp motions<br>SlewRateLimiter limit = new SlewRate(maxRatePerSecond)
// ...
var constrainedOutput = limit.calculate(unconstrainedInput)
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/slew-rate-limiter.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/slew-rate-limiter.html" target="_blank">WPILIb Slew Rate Limiter</a><br><br><br>By far the most helpful use case on everyday robots. This helps drivers get reliable, steady control of the robot, preventing sharp jerky motions. It also has the lowest risk of quirky side effects.<br>// Ordinary call with no ramping applied
drivetrain.arcadeDrive(forward, turn);
// Slew-rate limits the forward/backward input, limiting forward/backward acceleration
drivetrain.arcadeDrive(limit.calculate(forward), turn);
<br><br>In some cases it can be helpful to contain motor outputs directly. <br>In fact, this use case is so common that Rev controllers have two variants of this built in<br>// Applies the slew rate on outputs generated by
// motor.set(...) 
motorconfig.openLoopRampRate(rate);
// Applies the slew rate on outputs generated by
// motor.setReference(...) 
motorconfig.closedLoopRampRate(rate);
<br>The closedLoopRampRate can help mitigate sharp oscillations around setpoints caused by imperfect <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> tunings, and harsh transitions on setpoint changes. This can a lot of stability to simple systems, as well as make tuning easier. <br>The openLoopRampRate is valuable for preventing harsh transitions between power levels, commonly encountered for simple button-actuated motions on rollers.<br>This application of slew rate limiting is most common earlier in your robotics career. Eventually, this simple method will be replaced with more advanced <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>.<br><br>Applying slew rate limits to <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> setpoints can significantly improve ease of tuning and reduce many issues with setpoint jumps creating large error terms. <br>This application of slew-rates effectively creates a limited version of a <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Trapezoidal Motion Profile</a> , but with some extra constraints and caveats.<br><br>A common surprise you might encounter with slew rate limiters is that they constrain limits in both up and down. This makes perfect mathematical sense, but the effect is that heavily rate-limited things may not stop when you expect them to. This can cause them to feel "unresponsive" or "floating". This is most common with things like buttons or joysticks; Stuff won't stop moving when you release, because it'll slowly coast down.<br>The internal implementation accounts for "change per time interval", with "time interval" being defined as the current and previous runs of the calculate() method. If your system stops calculating for a time, the time interval is very large, which means the allowed change in the current iteration is also very large! This can permit the very problems you wanted to solve. If you're restarting a slew rate process, you'll need to reset it by creating a new instance of the SlewRate limiter and over-riding the old one. ]]></description><link>misc/slew-rate-limiting.html</link><guid isPermaLink="false">Misc/Slew Rate Limiting.md</guid><pubDate>Tue, 10 Jun 2025 22:08:48 GMT</pubDate></item><item><title><![CDATA[Subsystems]]></title><description><![CDATA[ 
 <br><br>
<br>None? Part of <a data-href="Robot Code Basics" href="level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a> and reference
<br><br>A "Subsystem" class generally accomplishes 4 distinct things in a robot project<br>
<br>Serve as a "resource" to constrain hardware for <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> requirement
<br>Hold tuning, configuration and code 
<br>House useful <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>
<br>House useful <a data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a>
<br>Any time you're performing multiple tasks in a single code class, careful consideration of your structure is important. <br><br>The first consideration of your robot should always be "What qualifies as a 'subsystem'" . Through experience or wisdom, you'll generally land on "A subsystem is a single actuator".<br>For more complex bots, you may be forced to consider a single subsystem as one or more <a data-tooltip-position="top" aria-label="Forward Kinematics" data-href="Forward Kinematics" href="level-2/forward-kinematics.html" class="internal-link" target="_self" rel="noopener nofollow">|kinematically linked</a> sets of mechanisms.<br>Chassis are something of an exception: Despite having multiple actuators/motors, they act as a single cohesive system, and have helper classes to manage some complexity.<br>This decision will create more subsystems than you think are necessary. However, it has a few advantages<br>
<br>The subsystems are smaller, and more manageable
<br>More subsystems --&gt; easier splitting of tasks and workloads 
<br>A couple simple <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> can easily link two subsystems that might seem useless when operated independently
<br>As a season progresses, unexpected developments might bring to light reasons to split a "double actuator subsystem". Having this already be done saves a lot of time and effort.
<br><br>Pseudocode warning
This code will not compile or work out of the box, and just serves as a reference. 
<br><br>This is a functional, but barebones system. This is <br>SimpleRollerSystem extends SubsystemBase(){
	SparkMax motor = new SparkMax(42,kBrushless);

	ExampleSubsystem(){
		//Normal constructor tasks
		//Configure motor
		//Set the default command; In this case, just power down the roller
		setDefaultCommand(setPower(0))
	}	

	public Command setPower(double power){
		return run(()-&gt;motor.set(power)); 
	}
}
<br><br>This is representative of a much more feature complete subsystem, including positional control. This is in line with the expectation of a Stormbot's production subsystem.<br>This integrates <a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a>, <a data-tooltip-position="top" aria-label="PID" data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PIDs</a>, and a <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profile</a>. <br>ExampleElevatorSubsystem extends SubsystemBase(){
	SparkMax motor = new SparkMax(42,kBrushless);

	//See [[FeedForwards]] for additional information
	ElevatorFeedForward ff = new ElevatorFeedForward(...);

	//This is a relatively stramlined way to combine [[PID]] 
	// and [[Motion Profiles]]
	TrapezoidProfile.Constraints constraints = 
		new TrapezoidProfile.Constraints(maxv,maxa);
	ProfiledPIDController pid = 
		new ProfiledPIDController(kp,ki,kd,constraints);
	
	ExampleElevatorSubsystem(){
		//Normal constructor tasks, setup, and configuration
		//Configure motor
		
		//DefaultCommands help avoid leaving a system in an uncontrolled
		//state. Often, this simply means intentionally applying no motion.
		setDefaultCommand(setPower(kg));
	}	

	//Triggers form the optimal way to transfer subsystem states/conditions
	//to external subsystems.
	public Trigger isAtPosition = new Trigger(pid::atGoal);
	
	//A manual command option is essential for tuning and calibration
	//Including the feed-forward here  
	public Command setPower(double power){
		return run(()-&gt;motor.set(power)); 
	}
	
	//Once tuned, a profiled PID is the gold standard for most control actions
	//The primary version _should not_ exit, as it complicates composition.
	public Command setPosition(double position){
		return startRun(()-&gt;{
			//Do initial reset for PID/profile
			//Run the profiledPID
		});
	}
	
	//This version simply adds the exit condition to the setPosition
	//This helps clean up autos and sequences.
	public Command setPositionExit(double position){
		return setPosition(position).until(isAtPosition);
	}
}
<br><br>Sensor subsystems can help manage access of a single sensor across multiple other subsystems. <br>ExampleSensorSubsystem extends SubsystemBase(){
	//Create a sensor object, whatever that looks like
	Sensor sensor = new Sensor(....);
	
	ExampleSensorSubsystem(){
		//Normal constructor tasks
		//Configure motor
		//There's likely no need for a defaultCommand
	}

	//Set Triggers 
	public Trigger isThingInRange = new Trigger(()-&gt;
		if(sensor.read &lt; 10) return true;
		return false;
	}
	
	// Repeat triggers as needed to have all useful states

	// Sometimes you just need analog data.
	public double getDistanceToThing(){
		return 0;//read sensor and return a sane value
	}
}
<br>Generally, sensor subsystems should be designed to avoid needing to require the subsystem, facilitating shared access. However, sometimes special cases are needed for very modal systems. The most notable and common example is Vision systems where pipeline changes are necessary for different game pieces, zoom, or detection methods.]]></description><link>misc/subsystems.html</link><guid isPermaLink="false">Misc/Subsystems.md</guid><pubDate>Sun, 08 Jun 2025 06:32:52 GMT</pubDate></item><item><title><![CDATA[Contributing]]></title><description><![CDATA[ 
 <br><br><br>Documents should generally be structured with the consideration that they're a small part of a whole; Each document is a little workshop, and intended to both provide some education, and provide a small task for the reader. <br>Every document will likely be first encountered through the skill trees, so making sure that the first few lines are useful in the progression context will help those skill trees read better. <br>Document Title - 
A short synopsis or summary helping clarify the topic for at-a-glance reminders on the skill tree.


<br>Checkbox list of items that individually demonstrate a partial understanding of the document's goals
<br>Items can be breadcrumbs of smaller steps toward the larger goal, in cases where reader background might not make it obvious otherwise
<br>Items can also be generic requests to handle something a particular way, if the way to do so should be well understood
<br>Items can also simply request variations


A summary of what this the reader should understand after understanding the article's success criteria. This is not always required, but can be useful for more abstract or difficult topics.

Currently, no additional guidelines exist. Just add things
<br><br>The core details we want to document:<br>
<br>What something is
<br>How it works
<br>Why we want to use it
<br>When to use it
<br>Where it goes in your code
<br>When writing documentation, follow the graphs! You can expect that your reader has <br>
<br>Understood all documents leading up to this one
<br>Not read documents after this one.<br>
If you're trying to write documentation and find that you cannot follow the graph, start a discussion about it. It may help to break up the topic at hand, or adjust the graph to better suit it. 
<br>Good things to document<br>
<br>Hard earned lessons, especially if they're non-obvious when understanding a topic. A good example is that feed-forwards make PIDs much easier to work with, even if they're not required for systems to work.   
<br>Custom idioms that we as a team like to use, or alterations to the existing documentation. 
<br>Documenting the "why" is often forgotten, but very valuable. 
<br>Documentation considerations: <br>
<br>If there's good existing documentation, consider just linking it and building on top of it! This is especially true of concepts at [docs.wpilib.org]. This means we can provide guidance and workflow, without having additional upkeep on our own documentation. 
<br>However, consider offline use and reader flow. If something is quick and easy to explain, and unlikely to change season to season, it's may be worth adding just to make things easy. 
<br>Avoid duplicating information in multiple documents here. If we explain it elsewhere, just link to it. This prevents conflicting information and excessive work maintaining the notebook. 
<br>
<br><br><br>Some of the basic markdown features are critical to being effective in adding and extending the notebook:<br>
<a rel="noopener nofollow" class="external-link" href="https://help.obsidian.md/syntax" target="_blank">https://help.obsidian.md/syntax</a><br>On occasion, we'll need other stuff from here:  <a rel="noopener nofollow" class="external-link" href="https://help.obsidian.md/advanced-syntax" target="_blank">https://help.obsidian.md/advanced-syntax</a><br><br>We can embed pictures! Drag and drop or copy and paste is probably the easiest way.<br>
When doing so, it'll default to storing the file in the project root directly. In general, just shove pictures in the assets/ folder so they're out of the way. Renaming them to be vaguely descriptive is recommended though. <br><br>A callout is a useful structure for little inline sidebars with various appearances<br>
<a rel="noopener nofollow" class="external-link" href="https://help.obsidian.md/callouts" target="_blank">https://help.obsidian.md/callouts</a><br>Info
This is what a callout looks like
<br>Caution
Use caution and warn callouts when something is easy to get wrong and result in surprises.<br>
If something going wrong provides a safety risk, consider the danger tag.
<br>Bug
Bug-type callout. Useful for indicating when something is actively broken, or works unexpectedly
<br><br>Basic table format is <br>|col name 1| colname 2| etc |
|----------|----------|-----|
| row one  | stuff    |     |
<br>But you'll probably just want to use CTRL+P and select Insert Table<br>This use a plugin to enable excel-like math operations should it prove useful for helping in explaining concepts.<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/klaudyu/CalcCraft" target="_blank">https://github.com/klaudyu/CalcCraft</a><br><br>note: these are only evaluated in "reader" mode (click the book icon on the top right of this page window)<br><br>Beyond the Canvas utilities, you can embed a variety of diagrams generated by Mermaid. This utility can assist in learning and configuring diagrams efficiently.<br>
<a rel="noopener nofollow" class="external-link" href="https://mermaid.live/edit" target="_blank">https://mermaid.live/edit</a><br><br>If you forget how to set up some syntax detail, just select some text, and hit CTRL+P to open the command bar. Enter whatever it is you're after, and obsidian will help you out. <br>When all else fails, just write it! We can always tidy up later. ]]></description><link>contributing.html</link><guid isPermaLink="false">CONTRIBUTING.md</guid><pubDate>Sat, 07 Jun 2025 20:00:38 GMT</pubDate></item><item><title><![CDATA[Dropped+Moved Requirements]]></title><description><![CDATA[ 
 <br><br>
<br>
Lambdas/methods

<br>
Printing To Terminal

<br><br>
<br>Elastic
<br>Rev Hardware Client
<br>PathPlanner
<br><br>should "encoder basics" come after motor control? Or just give more modularity for introductory stuff?]]></description><link>dropped+moved-requirements.html</link><guid isPermaLink="false">Dropped+Moved Requirements.md</guid><pubDate>Mon, 02 Jun 2025 05:05:41 GMT</pubDate></item><item><title><![CDATA[Skyview Robotics Knowledgebase]]></title><description><![CDATA[ 
 <br><br>This is the Skyview Robotics training wiki and educational resources<br><br>Robotics does not have a linear path to success; There's a lot of variety in what you'll need to do, and a bigger variety in what you want to do. So, instead of a standard curriculum, our resources are broken down as skill trees that build up and out from smaller, foundational sections.<br>Brand new programmers will likely need to start with the very fundamentals of coding:<br>
<a data-tooltip-position="top" aria-label="Coding Basics.canvas" data-href="Coding Basics.canvas" href="level-0/coding-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Basics</a><br>Once you're ready to move some hardware, the <a data-tooltip-position="top" aria-label="StormBreakers Tree.canvas" data-href="StormBreakers Tree.canvas" href="stormbreakers-tree.html" class="internal-link" target="_self" rel="noopener nofollow">StormBreakers Tree</a> is intended to guide new students to meet the challenges of a fully working, competitive Kitbot.<br>Lastly, our <a data-tooltip-position="top" aria-label="Stormbots Tree.canvas" data-href="Stormbots Tree.canvas" href="stormbots-tree.html" class="internal-link" target="_self" rel="noopener nofollow">Stormbots Tree</a>  builds on experience, and emphasizes deeper dives into advancing specific skills, and blending varied skill sets together. This tree is intended to guide students through more complex designs and higher performance targets. It also builds and relies upon the <a data-tooltip-position="top" aria-label="StormBreakers Tree.canvas" data-href="StormBreakers Tree.canvas" href="stormbreakers-tree.html" class="internal-link" target="_self" rel="noopener nofollow">StormBreakers Tree</a>, which will remain a valuable resource.<br>While any particular page will likely prove somewhat useful on it's own, everything will be written with the assumption you're caught up according to these trees. <br><br>This notebook is an <a data-tooltip-position="top" aria-label="https://obsidian.md" rel="noopener nofollow" class="external-link" href="https://obsidian.md" target="_blank">Obsidian.md</a> notebook, and some features of it may not fully work outside of Obsidian.<br><br><img alt="StormBreakers Tree" src="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1" referrerpolicy="no-referrer"><br><br><img alt="Stormbots Tree" src="https://github.com/user-attachments/assets/0a43acb5-d197-4e00-8eb5-28ca4c408e23" referrerpolicy="no-referrer">]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Thu, 05 Jun 2025 08:11:44 GMT</pubDate><enclosure url="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Stormbots Tree]]></title><description><![CDATA[ 
 SuperStructure FocusSwerve FocusVision FocusSimulation, Logging, VisualizationSpecialized Dependencies<br>Requires:<br>
<a data-href="SuperStructure Rollers" href="level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="Sensing Basics" href="level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br>Recommends:<br>
<a data-href="State Machines" href="level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a><br>Requires as needed:<br>
<a data-href="SuperStructure Rollers" href="level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="SuperStructure Elevator" href="level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
<a data-href="SuperStructure Arm" href="level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br><br>
<br>Create an "over the bumper" intake system
<br>Add a controller button to engage the intake process. It must retract when released
<br>The button must automatically stop and retract the intake when a game piece is retracted
<br><br>Intake complexity can range from very simple rollers that capture a game piece, to complex actuated systems intertwined with other scoring mechanisms. <br>A common "over the bumper" intake archetype is a deployed system that<br>
<br>Actuates outward past the frame perimeter
<br>Engages rollers to intake game piece
<br>Retracts with the game piece upon completion of a game piece
<br>The speed of deployment and retraction both impact cycle times, forming a critical competitive aspect of the bot. <br>The automatic detection and retraction provide cycle advantages (streamlining the driver experience), but also prevent fouls and damage due to the collisions on the deployed mechanism.SuperStructure Intake<br>Requires:<br>
<a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>Recommends:<br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create a Roller subsystem
<br>Calibrate the system to use RPM
<br>Create Commands for running forward and backwards using the target RPM
<br>Bind them to commands to move the game piece forward or backward
<br>Create a default command that stops the subsystem
SuperStructure Rollers<br>Requires<br>
<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Create a PID system on a test bench
<br>Tune necessary PIDs using encoders
<br>Set a velocity using a PID
<br>Set a angular position using a PID
<br>Set a elevator position using a PID
<br>Plot the system's position, target, and error as you command it.
<br><br>TODO:<br>
Add some graphs<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/DylanHojnoski/obsidian-graphs" target="_blank">https://github.com/DylanHojnoski/obsidian-graphs</a><br>
Write synopsis<br><br>A PID system is a <a data-href="Closed Loop Controller" href="misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controller</a> designed to reduce system error through a simple, efficient mathematical approach.<br>You may also appreciate Chapter 1 and 2 from <a data-href="controls-engineering-in-frc.pdf" href="misc/controls-engineering-in-frc.pdf" class="internal-link" target="_self" rel="noopener nofollow">controls-engineering-in-frc.pdf</a> , which covers PIDs very well. <br><br>To get an an intuitive understanding about PIDs and feedback loops, it can help to start from scratch, and kind of recreating it from the basic assumptions and simple code.<br>Let's start from the core concept of "I want this system to go to a position and stay there". <br>Initially, you might simply say "OK, if we're below the target position, go up.  If we're above the target position, go down." This is a great starting point, with the following pseudo-code.<br>setpoint= 15  //your target position, in arbitrary units
sensor= 0 //Initial position
if(sensor &lt; setpoint){ output = 1 }
else if(sensor &gt; setpoint){ output = -1 }
motor.set(output)
<br>However, you might see a problem. What happens when setpoint and sensor are equal? <br>If you responded with "It rapidly switches between full forward and full reverse", you would be correct. If you also thought "This sounds like it might damage things", then you'll understand why this controller is named a "Bang-bang" controller, due to the name of the noises it tends to make.<br>Your instinct for this might be to simply not go full power. Which doesn't solve the problem, but reduces it's negative impacts. But it also creates a new problem. Now it's going to oscillate at the setpoint (but less loudly), and it's also going to take longer to get there.<br>So, let's complicate this a bit. Let's take our previous bang-bang, but split the response into two different regions: Far away, and closer. This is easier if we introduce a new term: Error. Error just represents the difference between our setpoint and our sensor, simplifying the code and procedure. "Error" helpfully is a useful term, which we'll use a lot.<br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	error = setpoint-sensor 
	if     (error &gt; 5){ output = -1 }
	else if(error &gt; 0){ output = -0.2 }
	else if(error &lt; 0){ output = 0.2 }
	else if(error &lt; -5){ output = 1 }
	motor.set(output)
})
<br>We've now slightly improved things; Now, we can expect more reasonable responses as we're close, and fast responses far away. But we still have the same problem; Those harsh transitions across each else if. Splitting up into more and more branches doesn't seem like it'll help. To resolve the problem, we'd need an infinite number of tiers, dependent on how far we are from our targets. <br>With a bit of math, we can do that! Our error term tells us how far we are, and the sign tells us what direction we need to go... so let's just scale that by some value. Since this is a constant value, and the resulting output is proportional to this term, let's call it kp: Our proportional constant. <br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	kp = 0.1
	error = setpoint-sensor 
	output = error*kp
	motor.set(output)
)}
<br>Now we have a better behaved algorithm! At a distance of 10, our output is 1. At 5, it's half. When on target, it's zero! It scales just how we want. <br>Try this on a real system, and adjust the kP until your motor reliably gets to your setpoint, where error is approximately zero. <br>In doing so, you might notice that you can still oscillate around your setpoint if your gains are too high. You'll also notice that as you get closer, your output drops to zero. This means, at some point you stop being able to get closer to your target. <br>This is easily seen on an elevator system. You know that gravity pulls the elevator down, requiring the motor to push it back up. For the sake of example, let's say an output of 0.2 holds it up. Using our previous kP of 0.1, a distance of 2 generates that output of 0.2. If the distance is 1, we only generate 0.1... which is not enough to hold it! Our system actually is only stable below where we want. What gives! <br> This general case is referred to as "standing error" ; Every loop through our PID fails to reduce the error to zero, which eventually settles on a constant value. So.... what if.... we just add that error up over time? We can then incorporate that error into our outputs. Let's do it.<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
kp = 0.1
ki = 0.001
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	output = error*kp + errorsum*ki
	motor.set(output)
}
<br>The mathematical operation involved here is called integration, which is what this term is called. That's the "I" in PID.<br>
In many practical FRC applications, this is probably as far as you need to go! P and PI controllers can do a lot of work, to suitable precision. This a a very flexible, powerful controller, and can get "pretty good" control over a lot of mechanisms. <br>This is probably a good time to read across the  <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" target="_blank">WPILib PID Controller</a>  page; This covers several useful features. Using this built-in PID, we can reduce our previous code to a nice formalized version that looks something like this.<br>PIDController pid = new PIDController(kP, kI, kD);
run(()-&gt;{
	sensor = motor.getEncoder.getPosition();
	motor.set(pid.calculate(sensor, setpoint))
})
<br>A critical detail in good PID controllers is the iZone. We can easily visualize what problem this is solving by just asking "What happens if we get a game piece stuck in our system"?<br>
Well, we cannot get to our setpoint. So, our errorSum gets larger, and larger.... until our system is running full power into this obstacle. That's not great. Most of the time, something will break in this scenario. <br>So, the iZone allows you to constrain the amount of error the controller actually stores. It might be hard to visualize the specific numbers, but you can just work backward from the math. If output = errorsum*kI, then maxIDesiredTermOutput=iZone*kI. So iZone=maxIDesiredTermOutput/kI.<br>Lastly, what's the D in PID?<br>Well, it's less intuitive, but let's try. Have you seen the large spike in output when you change a setpoint? Give the output a plot, if you so desire. For now, let's just reason through a system using the previous example PI values, and a large setpoint change resulting in an error of 20. <br>Your PI controller is now outputting a value of 2.0 ; That's double full power! Your system will go full speed immediately with a sharp jolt, have a ton of momentum at the halfway point, and probably overshoot the final target. So, what we want to do is constrain the speed; We want it fast but not too fast. So, we want to reduce it according to how fast we're going.<br>
Since we're focusing on error as our main term, let's look at the rate the error changes. When the error is changing fast we want to reduce the output. The difference is simply defined as error-previousError, so a similar strategy with gains gives us output+=kP*(error-previousError) .<br>
This indeed gives us what we want: When the rate of change is high, the contribution is negative and large; Acting to reduce the total output, slowing the corrective action.<br>However, this term has another secret power, which disturbance rejection. Let's assume we're at a steady position, and the system is settled, and error=0. Now, let's bonk the system downward, giving us a positive error. Suddenly nonzero-0 is positive, and the system generates a upward force. For this interaction, all components of the PID are working in tandem to get things back in place.<br><br>OK, that's enough nice things. Understanding PIDs requires knowing when they work well, and when they don't, and when they actually cause problems. <br>
<br>PIDs are reactive, not predictive. Note our key term is "error" ; PIDs only act when the system is already not where you want it, and must be far enough away that the generated math can create corrective action.
<br>Large setpoint changes break the math. When you change a setpoint, the P output gets really big, really fast, resulting in an output spike. When the PID is acting to correct it, the errorSum for the I term is building up, and cannot decrease until it's on the other side of the setpoint. This almost always results in overshoot, and is a pain to resolve.  
<br>Oscillation: PIDs inherently generate oscillations unless tuned perfectly. Sometimes big, sometimes small.
<br>D term instability: D terms are notoriously quirky. Large D terms and velocity spikes can result in bouncy, jostly motion towards setpoints, and can result in harsh, very rapid oscillations around the zero, particularly when systems have significant <a data-href="mechanical backlash" href="mechanical backlash" class="internal-link" target="_self" rel="noopener nofollow">mechanical backlash</a>.
<br>PIDS vs Hard stops: Most systems have one or more <a data-href="Hard Stops" href="Hard Stops" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a>, which present a problem to the I term output. This requires some consideration on how your encoders are initialized, as well as your setpoints.
<br>Tuning is either simple....or very time consuming.
<br>So, how do you make the best use of PIDs?<br>
<br>Reduce the range of your setpoint changes. There's a few ways to go about it, but the easiest are <a data-href="clamping" href="clamping" class="internal-link" target="_self" rel="noopener nofollow">clamping</a> changes, <a data-href="Slew Rate Limiting" href="misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a> and <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> . With such constraints, your error is always small, so you can tune more aggressively for that range. 
<br>Utilize <a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> to create the basic action; Feed-forwards create the "expected output" to your motions, reducing the resulting error significantly. This means your PID can be tuned to act sharply on disturbances and unplanned events, which is what they're designed for.
<br>In other words, this is an error correction mechanism, and if you avoid adding error to begin with, you more effectively accomplish the motions you want. Throwing a PID at a system can get things moving in a controlled fashion, but care should be taken to recognize that it's not intended as the primary control handler for systems. <br><br>PID<br><br>
<br>Configure a motion system with PID and FeedForward
<br>Add a trapezoidal motion profile command (runs indefinitely)
<br>Create a decorated version with exit conditions
<br>Create a small auto sequence to cycle multiple points
<br>Create a set of buttons for different setpoints
Motion Profiles<br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/inversekinematics" target="_blank">https://robotics-explained.com/inversekinematics</a>Inverse Kinematics<br><br>One of <br>
<br><a data-href="SuperStructure Arm" href="level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a>
<br><a data-href="SuperStructure Elevator" href="level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a>
<br><br>Understand how to efficiently communicate to and from a robot for diagnostics and control <br><br>
<br>


<br><br><br>
<br>Graphs
<br>Field2D
<br>Poses
<br>Folders
<br>Mechanism2d
<br><br>
<br>Widget options
<br>Driverstation setup
Basic TelemetrySwerve Odometry<br><br>
<br>Choose a PathPlanning tool
<br>Implement the Java framework for the selected tool
<br>Model the robot's physical parameters for your tool
<br>Drive a robot along a target trajectory using one of these tools
<br>Followup to:<br>
<a data-href="Auto Differential" href="level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Swerve Motion" href="level-2/swerve-motion.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Motion</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html</a><br>
<a rel="noopener nofollow" class="external-link" href="https://choreo.autos/" target="_blank">https://choreo.autos/</a><br>
<a rel="noopener nofollow" class="external-link" href="https://pathplanner.dev/home.html" target="_blank">https://pathplanner.dev/home.html</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html</a><br><br>Do you need path planning to make great autos? Maybe! But not always.<br>PathPlanning can give you extremely fast, optimized autos, allowing you to squeeze every fraction of a second from your auto. However, it can be challenging to set up, and has a long list of requirements to get even moderate performance.<br><br><br>Unlike "path planning" algorithms that attempt to define and predict robot motion, Pure Pursuit simply acts as a reactive path follower, as the name somewhat implies.<br><a rel="noopener nofollow" class="external-link" href="https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html" target="_blank">https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html</a><br>
<img alt="pathfinding-pure-pursuit.png" src="assets/pathfinding-pure-pursuit.png"><br>This algorithm is fairly simple and conceptually straightforward, but with some notable limitations. However, the concept is very useful for advancing simpler autosPathPlanning Tools<br>Part of:<br>
<a data-href="SuperStructure Flywheel" href="level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a><br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br><br>
<br>
System Identification<br><br>
<br>Understand how swerve works
<br>Teleop Interactions for existing swerve
<br>Reading odometry
<br>Reset/Initialize odometry 
<br><br>
<br>Use an existing Swerve configuration
<br>
Swerve Basics<br>Superstructure component that adds additional control axes between intakes and scoring mechanisms.<br> Common when handling multiple game pieces for storage and alignment, or when handling flywheel systems that must isolate game piece motion from superstructure motion<br> Often referred to as a "feeder" depending on the usage intent<br>Superstructure Indexer<br>Superstructure component that holds a large amount of kinetic energy at a high velocity. Typically paired with shooters.<br><br>
<br>Create a Flywheel system
<br>Tune with appropriate FeedForwards + PID to hit and maintain target RPMs 
<br>


<br><br><a data-href="System Identification" href="level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a><br>
<a data-href="Lookup Tables" href="level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>SuperStructure Flywheel<br><br>Interface with swerve for autos and non-trivial teleop interactions<br><br>
<br>Changing point of rotation in real time
<br>Move from Point to Point using a PID
<br>Move from point to point using a motion profile
<br>Create a command that allows translation while aimed at a bearing
<br>Create a command that allows translation while aimed at a Pose2d
Swerve Motion<br><br>
<br>Create new drive subsystem 
<br>Create and configure a YAGSL drivetain
<br>Tune Yagsl drivetrain and controls for manual driving
<br>Adjust parameters to ensure accurate auto driving and odometry tracking
<br>
Swerve Bringup<br><br><br>
<br>Oh no
PhotonVision Model Training<br>A shooter is simply a flywheel and supporting infrastructure for making game pieces fly from a robot<br><br>
<br>


<br>Typically a "shooter" consists of <br>
<br>a <a data-href="SuperStructure Flywheel" href="level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a> to serve as a mechanical means to maintain momentum
<br>A <a data-href="Superstructure Indexer" href="level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Indexer</a> to time shots and ensure the shooter is at the indended speed
<br>A targeting system, often using Odometry or Vision
<br>A trajectory evaluation to control target RPM. This can be fixed targets, <a data-href="Lookup Tables" href="level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>, or more complex trajectory calculations
Superstructure Shooter<br><br>
<br>


<br>Advanced computation for calculating optimal shot angles and rpmsFlight Trajectory Calculations<br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/forwardkinematics" target="_blank">https://robotics-explained.com/forwardkinematics</a>Forward Kinematics<br><br>
<br>Set up a mock project  with a nominal, standard code structure
<br>Project should have a subsystem that<br>
<br>Is in a subsystem folder
<br>Has 3 components in a (logic, <a data-href="Physics Simulation" href="level-2/physics-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">Physics Simulation</a>, <a data-href="Mechanism2d" href="level-2/mechanism2d.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanism2d</a>)
<br>Has a factory method to get a control command (can be mocked up)
<br>Has a trigger that indicates a mechanism state (can be mocked up based on timers)<br>
Has an additional sensor subsystem system that
<br>Provides a trigger for a condition (can be mocked up)<br>
Has a controller and<br>
Has an Autos class to hold autos
<br>With an auto chooser initialization 
<br>A single basic auto using subsystem and sensor
Code Structuring<br><br>Interact with the PhotoVision UI and basic code structures<br><br>
<br>Connect to the WebUI
<br>Set up a camera
<br>Set up AprilTag Target
<br>Read target position via NT
<br><br>This allows you to access PhotonVision via the roborio USB port.<br>
This can be useful when debugging at competitions<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.photonvision.org/en/latest/docs/quick-start/networking.html" target="_blank">https://docs.photonvision.org/en/latest/docs/quick-start/networking.html</a>PhotonVision Basics<br><br>
<br>Set up a pipeline to identify april tags
<br>Configure camera position relative to robot center
<br>Set up a
PhotonVision Odometry<br><br>
<br>Configure the PV networking
<br>Configure the PV hardware
<br>Set up a camera
<br>Create a Vision code class
<br>Configure PV class to communicate with the hardware
PhotonVision Bringup<br><br>
<br>Add a Object detection pipeline
<br>Detect a game piece using color detection
<br>if available, detect it using a ML object model 
PhotonVision Object Detection<br><br>Understand the typical Git operations most helpful for day-to-day programming<br><br>This module is intended to be completed alongside other tasks.<br>
<br>Initialize a git repository in your project
<br>Create an initial commit
<br>Create several commits representing simple milestones in your project
<br>When moving to a new skill card, create a new branch to represent it. Create as many commits on the new branch as necessary to track your work for this card. 
<br>When working on a skill card that does not rely on the previous branch, switch to your main branch, and create a new branch to  represent that card.
<br>On completion of that card (or card sequence), merge the results of both branches back into Main.
<br>Upon resolving the merge, ensure both features work as intended.
<br><br>
<br>Understanding git
<br>workspace, staging, remotes
<br>fetching
<br>Branches + commits
<br>Pushing and pulling
<br>Switching branches
<br>Merging
<br>Merge conflicts and resolution
<br>Terminals vs integrated UI tools
<br>In general<br><br><br><a rel="noopener nofollow" class="external-link" href="https://mermaid.live/edit#pako:eNqFUM1OxiAQfJUve24aaAulXDXx5AuYXrDsR4kFGgSjNn13sZ8_ica4p9nZmdlkNpiCRpBgbLqJap1HfyozBeds-o3vo_LTfNL4hEtYP-4zTg8hpx_sHwlfaqesv1AOo8H_3FCBiVaDTDFjBcVTAsoK27tqhDSjwxFkgRrPKi9phNHvxbYqfxeC-3TGkM0M8qyWx7LlVauE11aZqL4l6DXGq5B9AkmHIwLkBs8gG8Fq3lLBeccY6QWt4KWwhNU960jXsn6ghDK-V_B6PCW1oJQ2HWt4OwhOBasAtU0h3l6KP_rf3wA0I3rV" target="_blank">https://mermaid.live/edit#pako:eNqFUM1OxiAQfJUve24aaAulXDXx5AuYXrDsR4kFGgSjNn13sZ8_ica4p9nZmdlkNpiCRpBgbLqJap1HfyozBeds-o3vo_LTfNL4hEtYP-4zTg8hpx_sHwlfaqesv1AOo8H_3FCBiVaDTDFjBcVTAsoK27tqhDSjwxFkgRrPKi9phNHvxbYqfxeC-3TGkM0M8qyWx7LlVauE11aZqL4l6DXGq5B9AkmHIwLkBs8gG8Fq3lLBeccY6QWt4KWwhNU960jXsn6ghDK-V_B6PCW1oJQ2HWt4OwhOBasAtU0h3l6KP_rf3wA0I3rV</a>Git Basics<br><br>
<br>Create a Singleton class
<br>Use it in multiple places in your code
<br><br>Coding structure that represents a unique entity, of which only one can assist. <br>Commonly used in WPILib to model physical harware Singletons<br><br>
<br>


<br><br>A pre-computed list of input and output values.<br>Can be used to help model non-trivial conditions where mathematical models are complicated, or don't apply effectively to the problem at hand. <br>Commonly used for modelling <a data-href="Superstructure Shooter" href="level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Shooter</a> Lookup Tables<br>Ways to manage multiple, simultaneous operations happening on the robot<br><br>
<br>


<br><br>Threading<br><br>
<br>??? Do we need or want this here? 
<br>Need to find a way to actually use it efficiently in beneficial way
<br><br>
<br>Understand how to set up Advantagekit
<br><a rel="noopener nofollow" class="external-link" href="https://docs.advantagekit.org/getting-started/what-is-advantagekit/" target="_blank">https://docs.advantagekit.org/getting-started/what-is-advantagekit/</a>AdvantageKit<br><br><br><br>
<br>Create a standard Arm or Elevator
<br>Model the system as a Mechanism2D
<br>Create a Physics model class
<br>Configure the physics model
<br>Tune the model to react in a sensible way. It does not need to match a real world model
Physics Simulation<br><br>
<br>Create a basic Arm or Elevator motion system
<br>Create a Mechanism 2D representation of the control angle
<br>Create additional visual flair on mechanism to help indicate mechanism context
Mechanism2d]]></description><link>stormbots-tree.html</link><guid isPermaLink="false">Stormbots Tree.canvas</guid><pubDate>Thu, 19 Jun 2025 00:48:57 GMT</pubDate><enclosure url="assets/pathfinding-pure-pursuit.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/pathfinding-pure-pursuit.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[StormBreakers Tree]]></title><description><![CDATA[ 
 Introductory TopicsStandard TopicsSpecial CoursesCapstone Topics<br>Requires:<br>
<a data-href="Robot Code Basics" href="level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Configure a motor encoder
<br>Read an encoder
<br>Configure encoder range/units through gearing
<br>Enable/Disable Soft Limits
<br><br>
<br>Absolute vs Relative encoders
<br>Startup positioning
<br><a data-href="Homing" href="Homing" class="internal-link" target="_self" rel="noopener nofollow">Homing</a>
<br>Slew Rate Limiting
Encoder Basics<br><a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>
<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Install the WPILib VS Code IDE
<br>Make a new robot project
<br>Create a new subsystem
<br>Install the Rev third Library
<br>Basic requirements to start working  on robot projects
<br>Create a new empty subsystem 
<br>Create a new empty command
<br>Add your new command and subsystem to RobotContainer.
<br><br>Programming prerequisites, listed in <a data-href="Coding Basics" href="level-0/coding-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Basics</a> for now<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html</a><br><br>When you open a new robot project you'll see a lot of files we'll interact with.<br>
<br>src/main

<br>deploy
<br>java
<br>frc/frc/robot

<br>commands

<br>ExampleCommand.java


<br>subsystems

<br>ExampleSubsystem.java


<br>Constants.java
<br>Main.java
<br>Robot.java
<br>RobotContainer.java




<br>vendordeps
<br>For typical projects, you'll be spending the most time in RobotContainer, subsystems, and occasionally commands. <br>For some early practice projects, or special use cases you might also interact with Robot.java a bit.<br><br>Many helpful utilities we'll use for robot projects are represented using code that's not available by default. WPILib has a small manager to assist with installing these, detailed here: <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries</a><br><br>We'll also utilize a number of software tools for special interactions with hardware or software components. Some of these include <br>
<br><a data-href="Rev Hardware Client" href="hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a> , a motor controller management tool
<br><a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">GrappleHook</a> , which manages the LaserCan configuration
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" target="_blank">NI Driver Station</a> is needed for systems that will want to enable and drive a robot. 
<br><br>The hardest part of getting started with robots is figuring out where your robot code goes. <br><br>Robot.java is a very powerful file, and it's possible to write your entire robot in just this one file! For reasons we'll get into, we do not want to do this. However, the setup of it does a good job explaining how a robot works. Let's look at the structure of this file for now<br>public class Robot extends TimedRobot {
	private Command m_autonomousCommand;
	private final RobotContainer m_robotContainer;
	public Robot() {
		m_robotContainer = new RobotContainer();
	}
	
	public void robotPeriodic() {}
	
	public void disabledInit() {}
	public void disabledPeriodic() {}
		
	public void autonomousInit() {}
	public void autonomousPeriodic() {}
	
	public void teleopInit() {}
	public void teleopPeriodic() {}
	
	public void testInit() {}
	public void testPeriodic() {}
	
	//a few more ignored bits for now
}
<br>From the pairing, we can group these into several different modes<br>
<br>"Robot"
<br>Autonomous
<br>Teleop
<br>Test
<br>Indeed, if we look at our <a data-href="Driver Station" href="misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a>, we see several modes mentioned.<br>
<img alt="driverstation.jpg" src="assets/driverstation.jpg"><br>
Teleop, Auto, and Test are simply selectable operational modes. However, you might want to utilize each one slightly differently.<br>"Practice mode" is intended to simulate real matches: This DriverStation mode runs Autonomous mode for 15 seconds, and then Teleop Mode for the remainder of a match time. <br>"Disabled" mode is automatically selected whenever the robot is not enabled. This includes when the robot boots up, as well as as whenever you hit "disabled" on the driver station.<br>
Disabled mode will also cancel any running <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> . <br>"Robot mode" isn't an explicit mode: Instead, of "Robot Init", we just use the constructor: It runs when the robot boots up. In most cases, the primary task of this is to set up Robot Container.<br>
robotPeriodic just runs every loop, regardless of what other loop is also running.<br>We can also see a grouping of <br>
<br>Init
<br>Periodic<br>
Whenever any new "mode" starts, we first run the Init function once, and then we run the periodic. The robot will continue run associated Periodic functions every loop, 50 times per second. 
<br>We generally won't add much code in Robot.java, but understanding how it works is a helpful starting point to understanding the robot itself. <br><br>As mentioned above, the "Robot Container" is created as the robot boots up. When you create a new project,<br>
This file contains a small number of functions and examples to help you organized. <br>public class RobotContainer(){
	ExampleSubsystem subsystem = new ExampleSubsystem();
	ExampleCommand command = new ExampleCommand();
	CommandXboxJoystick joystick = new CommandXboxJoystick(0);
	RobotContainer(){
		configureBindings();
	}
	public void configureBindings(){
		//Not a special function; Just intended to help organize 
	}
	public Command getAutonomousCommand(){/*stuff*/}
}
<br>This file introduces a couple new concepts  <br>
<br><a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, which form the  "actions" you want the robot to perform
<br><a data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>, or the different parts of the robot that could perform actions
<br><a data-href="Joysticks" href="misc/joysticks.html" class="internal-link" target="_self" rel="noopener nofollow">Joysticks</a> , which serve as the standard input method.
<br>The use of Commands and Subsystems goes a long way to managing complex robot interactions across many subsystems. However, they're certainly tricky concepts to get right off the bat. <br><br>Sometimes, you'll have oddball constants that you need to access in multiple places in your code. Constants.java advertises itself as a place to sort and organize files. <br>Without getting too into the "why", in general you should minimize use of Constants.java; It leads to several problems as your robot complexity increases. <br>Instead, simply follow good practices for scope encapsulation, and keep the constants at the lowest necessary scope. <br>
<br>If a value is used once, just use a value. This includes a lot of setup values like PID tuning values.
<br>If your value is used repeatedly inside a subsystem, make it a private constant in that subsystem. This is common for conversion factors, min/max values, or paired output values
<br>If a constant is strongly associated with a subsystem, but needs to be referenced elsewhere, make it a public constant in that subsystem.
<br>Lastly, if something is not associated with a subsystem, and used repeatedly across multiple subsystems, constants.java is the place. 
<br>If you find yourself depending on a lot of constants, you might need to consider <a data-href="Refactoring" href="misc/refactoring.html" class="internal-link" target="_self" rel="noopener nofollow">Refactoring</a> your code a bit to streamline things.  Note that Stormbots code has almost nothing in here! Robot Code BasicsCoding Basics.canvas<br>Requires:<a data-href="Robot Code Basics" href="level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br>
Recommends:<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br><br>
<br>Spin a motor
<br>Configure a motor with max current
<br>Control on/off via joystick button
<br>Control speed via joystick
<br><br>Learning order
This curriculum does not require or assume the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> structure; It's just about spinning motors.<br>
However, it's recommended to learn Motor Control alongside or after <a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, as we'll use them for everything afterwards anyway.
<br>Rev Lib
This documentation assumes you have the third party Rev Library installed. You can find instructions here.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html</a>
<br>Wiring and Electrical
This document also assumes correct wiring and powering of a motor controller. This should be the case if you're using a testbench. 
<br><br>// Robot.java
public Robot extends TimedRobot{

	public void teleopPeriodic(){
		
	}
}
Motor Control<br>Requires:<br>
<a data-href="Robot Code Basics" href="level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Create a command that runs indefinitely
<br>Have that command start+end on a joystick button
<br>Create a command that starts on a joystick press, and stop it with a different button
<br>Create a default command that lets you know when it's running through <a data-tooltip-position="top" aria-label="Basic Telemetry" data-href="Basic Telemetry" href="level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Telemetry</a>
<br>Create a runCommand using a function pointer
<br>Create a runCommand using a lambda
<br>Learning order
You can learn this without having done <a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>, but it's often more fun to learn alongside it in order to have more interesting, visual commands while experimenting.<br>
The commands provided as an example just print little messages visible in the RioLog, allowing this to be set up without motors
<br><br>A Command is an event driven code structure that allows you manage when code runs, what resources it uses, and when it ends. <br>In the context of a robot, it allows you to easily manage a lot of the complexity involved with managing multiple <a data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> <br>The code structure itself is fairly straightforward, and defines a few methods; Each method defines what code runs at what time. <br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){}
	public void initialize(){}
	public void execute(){}
	public boolean isFinished(){ return false; }
	public void end(boolean cancelled){}
}
<br>Behind the scenes, the robot runs a command scheduler, which helps manage what runs when. Once started, a command will run according to the following flowchart, more formally known as a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">state machine</a>. <br><br>This is the surface level complexity, which sets you up for how to view, read, and write commands. <br><br>A key aspect of Commands is their ability to claim temporary, exclusive  ownership over a <a data-href="Subsystem" href="Subsystem" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> .  This is done by passing the subsystem into a command, and then adding it as a requirement<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(ExampleSubsystem subsystemName){
		addRequirements(subsystemName);
	}
<br>Now, whenever the command is started, it will forcibly claim that subsystem. It'll release that claim when it runs it's end() block.<br>This ability of subsystems to hold a claim on a resource has a lot of utility. The main value is in preventing you from doing silly things like trying to tell a motor to go forward and backward at once.<br><br>Now that we've established subsystem ownership, what happens when you do try to tell your motor to go forward and then backward?<br>When you start the command, it will forcibly interrupt other commands that share a resource with it, ensuring that the new command has exclusive access. <br>It'll look like this<br><br>When a command is cancelled, the command scheduler runs the commands end(cancelled) block, passing in a value of true. Whole not typical, some commands will need to do different cleanup routines depending on whether they exited on a task completion, or if something else kicks em off a subsystem. <br><br>Commands can be started in one of 3 ways:<br>
<br>via a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>'s start condition
<br>Directly scheduling it via the command's .schedule() method.
<br>Automatically as a DefaultCommand
<br>They can be stopped via a few methods<br>
<br>When the command returns true from it's isFinished() method
<br>When launched by a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>, and the run condition is no longer met
<br>Calling a command's .cancel() method directly
<br>When the command is cancelled by a new command that claims a required subsystem.
<br><br>It's often the case that a subsystem will have a clear, preferred action when nothing else is going on. In some cases, it's stopping a spinning roller, intake, or shooter. In others it's retracting an intake. Maybe you want your lights to do a nice idle pattern. Maybe you want your chassis joystick to just start when the robot does.<br>Default commands are ideal for this. Default commands run just like normal commands, but are automatically re-started once nothing else requires the associated subsystem resource.<br>Just like normal command, they're automatically stopped when the robot is disable, and cancelled when something else requires it.<br>
Unlike normal commands, it's not allowed to have the command return true from isFinished(). The scheduler expects default commands to run until they're cancelled. <br>Also unlike other commands, a subsystem must require the associated subsystem, and cannot require other subsystems. <br>Command groups + default commands
It's worth making a note that a Default Command cannot start during a Command Group that contains a command requiring the subsystem! If you're planning complex command sequences like an auto, make sure they don't rely on DefaultCommands as part of their operation.
<br><br>As you're writing new subsystems, make sure you consider whether you should require a subsystem. <br>You'll always want to require subsystems that you will modify, or otherwise need exclusive access to. This commonly involves commands that direct a motor, change settings, or something of that sort. <br>In some cases, you'll have a subsystem that only reads from a subsystem. Maybe you have an LED subsystem, and want to change lights according to an Elevator subsystems's height.<br>
One way to do this is have a command that requires the LEDs (needs to change the lights), but does not require the Elevator (it's just reading the encoder).<br>As a general rule, most commands you write will simply require exactly one subsystem. Commands that need to require multiple subsystems can come up, but typically this is handled by command composition and command groups.<br><br>Every new project will have an example command in a dedicated file, which should look familiar<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){
		//Runs once when the command is created as the robot boots up.
		//Register required subsystems, if appropriate
		//addRequirements(subsystem1, subsystem2...);
	}
	public void initialize(){
		//Runs once when the command is started/scheduled
	}
	public void execute(){
		//Runs every code loop
	}
	public boolean isFinished(){
		//Returns true if the command considers it's task done, and should exit
		return false;
	}
	public void end(boolean cancelled){
		//Perform cleanup; Can do different things if it's cancelled
	}
}
<br>This form of command is mostly good for instructional purposes while you're getting started. <br>On more complex robot projects, trying to use the file-based Commands forces a lot of mess in your Subsystems; In order for these to work, you need to make many of your Subsystem details public, often requiring you to make a bunch of extra functions to support them. <br><br>Command factories are the optimal way to manage your commands. With this convention, you don't create a separate  Command files, but create methods in your <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> that build and return new Command objects. This convention is commonly called a "Factory" pattern.<br>
Here's a short example and reference layout:<br>//In your subsystem
Roller extends SubsystemBase{
	Roller(){}

	public Command spinForward(){
		return Commands.run(()-&gt;{
			System.out.println("Spin Forward!!");
		},this);
	}
}
<br>//In your robotContainer, let's create a copy of that command
RobotContainer{
	RobotContainer(){
		joystick.a().whileTrue(roller.spinForward());
	}
}

<br>That's it! Not a lot of code, but gives you a flexible base to start with.<br>This example uses Commands.run() one of the many options in the <a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" target="_blank">Commands Class</a>. These command shortcuts let you provide <a data-href="Lambdas" href="misc/lambdas.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas</a> representing some combination of a Command's normal Initialize, Execute, isFinished, or End functions. A couple notable examples are<br>
<br>Commands.run : Takes a single lambda for the Execute blocks
<br>Commands.startRun : Takes two lambdas for the Initialize and Execute blocks
<br>Commands.startEnd : Takes two lambdas for the Initialize and End Blocks
<br>Most commands you'll write can be written like this, making for simple and concise subsystems. <br>Watch the Requires
Many Commands helpers require you to provide the required subsystem after the lambdas. If you forget, you can end up with multiple commands fighting to modify the current subsystem
<br>Building on the above, Subsystems have several of these command helpers build in! You can see this.startRun(...), this.run(..) etc; These commands work the same as the Commands. versions, but automatically include the current subsystem.<br>There's a notable special case in new FunctionalCommand(...), which takes 4 lambdas for a full command, perfectly suitable for those odd use cases.<br><br>The real power of commands comes from the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" target="_blank">Command Compositions</a> , and "decorator" functions. These functions enable a lot of power, allowing you to change how/when commands run, and pairing them with other commands for complex sequencing and autos. <br>For now, let's focus on the two that are more immediately useful: <br>
<br>command.withTimeout(time) , which runs a command for a set duration. 
<br>command.until(()-&gt;someCondition) , which allows you to exit a command on things like sensor inputs. 
<br>Commands also has some helpful commands for hooking multiple commands together as well. The most useful is a simple sequence.<br>Commands.sequence(
	roller.spinForward().withTimeout(0.1),
	roller.spinBackward().withTimeout(0.1),
	roller.spinForward().withTimeout(0.5)
)
Commands<br><br>
<br>Start a command when the robot is enabled, and ends automatically
<br>


<br><br>
<br>Support command+trigger subsystem interfaces
<br>Model system state into binary regions
<br>loose coupling of subsystems
<br>Tolerances on sensors
<br>Joystick buttons = trigger ; Hidden common use case
<br>Starting commands with triggers
<br>ending commands with triggers
<br>sequencing component
Triggers<br><br><br>
<br>Advantages
<br>Disadvantages
<br>Discontinuity handling
<br>Integration with relative encoders
Absolute Encoders<br><br>Understand how to efficiently communicate to and from a robot for diagnostics and control <br><br>
<br>


<br><br><br>
<br>Graphs
<br>Field2D
<br>Poses
<br>Folders
<br>Mechanism2d
<br><br>
<br>Widget options
<br>Driverstation setup
Basic Telemetry<br><br>
<br>???
<br>


<br><br>
<br>General Debugging
<br><a data-href="Limelight Basics" href="level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight Basics</a>
<br><a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>
<br><a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a>
<br>Odometry Tasks
NetworkTables<br><br><a data-href="SuperStructure Arm" href="level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br>
<a data-href="SuperStructure Elevator" href="level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
And will generally be done after most requirements for those systems<br><br>
<br>Home a subsystem using a Command-oriented method
<br>Home a subsystem using a state-based method
<br>Make a non-homed system refuse non-homing command operations
<br>Document the "expected startup configuration" of your robot, and how the homing sequence resolves potential issues.
<br><br>
<br>Configure encoders and other system configurations
<br>Construct a Command that homes the system
<br>Create a Trigger to represent if the system is homed or not
<br>Determine the best way to integrate the homing operation. This can be 

<br>Initial one-off sequence on enable
<br>As a blocking operation when attempting to command the system
<br>As a default command with a Conditional Command
<br>Idle re-homing (eg, correcting for slipped belts when system is not in use)
<br>


Homing Sequences<br>Requires:<br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br>
Reading Resources:<br>
<a data-href="Homing" href="Homing" class="internal-link" target="_self" rel="noopener nofollow">Homing</a><br><br>
<br>Create an Elevator subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current height
<br>Create a setHeight function that takes a height, and returns a command that runs indefinitely to the target height
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
SuperStructure Elevator<br>Requires:<br>
<a data-href="SuperStructure Rollers" href="level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="Sensing Basics" href="level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br>Recommends:<br>
<a data-href="State Machines" href="level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a><br>Requires as needed:<br>
<a data-href="SuperStructure Rollers" href="level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="SuperStructure Elevator" href="level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
<a data-href="SuperStructure Arm" href="level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br><br>
<br>Create an "over the bumper" intake system
<br>Add a controller button to engage the intake process. It must retract when released
<br>The button must automatically stop and retract the intake when a game piece is retracted
<br><br>Intake complexity can range from very simple rollers that capture a game piece, to complex actuated systems intertwined with other scoring mechanisms. <br>A common "over the bumper" intake archetype is a deployed system that<br>
<br>Actuates outward past the frame perimeter
<br>Engages rollers to intake game piece
<br>Retracts with the game piece upon completion of a game piece
<br>The speed of deployment and retraction both impact cycle times, forming a critical competitive aspect of the bot. <br>The automatic detection and retraction provide cycle advantages (streamlining the driver experience), but also prevent fouls and damage due to the collisions on the deployed mechanism.SuperStructure Intake<br>Requires:<br>
<a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>Recommends:<br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create a Roller subsystem
<br>Calibrate the system to use RPM
<br>Create Commands for running forward and backwards using the target RPM
<br>Bind them to commands to move the game piece forward or backward
<br>Create a default command that stops the subsystem
SuperStructure Rollers<br><br>
<br>Create a simple autonomous that drives forward and stops
<br>Create a two-step autonomous that drives forward and backward
<br>Create a four step autonomous that drives forward, runs a mock "place object" command, backs up, then turns around.
Auto Differential<br>Requires:<br>
<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a Differential Drivetrain
<br>Configure a Command to operate the drive using joysticks
<br>??? Add rate limiting to joysticks to make the system control better 
<br>??? Add  constraints to rotation to make robot drive better
Differential Drive<br>Requires:<br>
<a data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>Hardware: <br>
<br>Switches
<br>Encoder
<br>LaserCan
<br><br>
<br>Create a Trigger that represents a sensor condition
<br>Create a Joystick command that runs indefinitely, but stops when the Trigger is in a true condition. 
<br>Repeat with a different sensor type
<br>Create a Trigger that performs a Command automatically when triggered
<br><br>Sensing is interacting with physical objects, and changing robot behaviour based on it.<br>
This can use a variety of sensors and methods, and will change from system to systemSensing Basics<br><a href=".?query=tag:hardware" class="tag" target="_blank" rel="noopener nofollow">#hardware</a><br><br>
<br>Connect to the LaserCan using GrappleHook
<br>Create a new Lasercan sensor subsystem
<br>Create a Trigger that returns true while an object is within X" of the sensor
LaserCan<br>Requires:<br>
<a data-href="Triggers" href="level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>
<a data-href="NetworkTables" href="level-2/networktables.html" class="internal-link" target="_self" rel="noopener nofollow">NetworkTables</a><br><br>
<br>Configure a Limelight to 
<br>Identify an April Tag
<br>Create a trigger that returns true if a target is in view
<br>When a target is in view, print the offset between forward and the target
<br>Estimate the distance to the target
<br>Configure the LL to identify a game piece of your choice.
<br>Indicate angle between forward and game piece.
Limelight Basics<br>requires<br>
<a data-href="Auto Differential" href="level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Limelight Basics" href="level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight Basics</a><br><br>
<br>Create a button that aims your chassis at a target
<br>Ensure the above button allows drivers to move toward and away from target while it's held
<br>Create a pipeline that allows you to drive to the left/right of the target instead of directly at it
<br>Create a button that aligns you with a game piece, and allows drivers to drive at it
Limelight Assist Driving<br><br>
<br>
Configure a NavX or gyro on the robot

<br>
Find a way to zero the sensor when the robot is enabled in auto

<br>
Create a command that tells you when the robot is pointed the same way as when it started

<br>
Print the difference between the robot's starting angle and current angle

<br>
TODO

<br>
what's an mxp

<br>
what port/interface to use, usb

<br>
which axis are you reading

<br>
Gyro Sensing<br>Requires:<br>
<a data-href="Sensing Basics" href="level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br><br>
<br>
???

<br>
Covering system "state" is very useful, especially in subsystems

<br>
ConditionalCommand + SelectCommand can be useful for attributing actions and states on simple systems

<br>
Need to find a sensible formal way to cover it; It's easy to make "custom" state machines for simple systems, but hard to scale up in complexity with consistent patterns.

<br><br>
<br>States of Unloaded, unaligned, loaded, scoring
<br>Consideration: Explain state machines here, as an explanation of how they're used and what they represent<br>Actually make it a workshop later.State Machines<br>Requires<br>
<a data-href="Auto Differential" href="level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Gyro Sensing" href="level-1/gyro-sensing.html" class="internal-link" target="_self" rel="noopener nofollow">Gyro Sensing</a><br><br>
<br>Create a button that causes the robot to face a bearing of 0 degrees
<br>Create 3 additional buttons to face 90, 180, and 270. 
<br>Ensure that the drivers can hold those buttons and use the throttle to drive in the indicated direction
<br>Create an 4 step auto that traverses a predefined path using gyro headings and encoder distances
Gyro Driving<br>Requires:<br>
<a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create an Arm subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world angle values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current angle
<br>Create a setAngle function that takes a angle, and returns a command that runs indefinitely to the target angle
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
SuperStructure Arm<br>Requires<br>
<a data-href="Commands" href="level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Create a PID system on a test bench
<br>Tune necessary PIDs using encoders
<br>Set a velocity using a PID
<br>Set a angular position using a PID
<br>Set a elevator position using a PID
<br>Plot the system's position, target, and error as you command it.
<br><br>TODO:<br>
Add some graphs<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/DylanHojnoski/obsidian-graphs" target="_blank">https://github.com/DylanHojnoski/obsidian-graphs</a><br>
Write synopsis<br><br>A PID system is a <a data-href="Closed Loop Controller" href="misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controller</a> designed to reduce system error through a simple, efficient mathematical approach.<br>You may also appreciate Chapter 1 and 2 from <a data-href="controls-engineering-in-frc.pdf" href="misc/controls-engineering-in-frc.pdf" class="internal-link" target="_self" rel="noopener nofollow">controls-engineering-in-frc.pdf</a> , which covers PIDs very well. <br><br>To get an an intuitive understanding about PIDs and feedback loops, it can help to start from scratch, and kind of recreating it from the basic assumptions and simple code.<br>Let's start from the core concept of "I want this system to go to a position and stay there". <br>Initially, you might simply say "OK, if we're below the target position, go up.  If we're above the target position, go down." This is a great starting point, with the following pseudo-code.<br>setpoint= 15  //your target position, in arbitrary units
sensor= 0 //Initial position
if(sensor &lt; setpoint){ output = 1 }
else if(sensor &gt; setpoint){ output = -1 }
motor.set(output)
<br>However, you might see a problem. What happens when setpoint and sensor are equal? <br>If you responded with "It rapidly switches between full forward and full reverse", you would be correct. If you also thought "This sounds like it might damage things", then you'll understand why this controller is named a "Bang-bang" controller, due to the name of the noises it tends to make.<br>Your instinct for this might be to simply not go full power. Which doesn't solve the problem, but reduces it's negative impacts. But it also creates a new problem. Now it's going to oscillate at the setpoint (but less loudly), and it's also going to take longer to get there.<br>So, let's complicate this a bit. Let's take our previous bang-bang, but split the response into two different regions: Far away, and closer. This is easier if we introduce a new term: Error. Error just represents the difference between our setpoint and our sensor, simplifying the code and procedure. "Error" helpfully is a useful term, which we'll use a lot.<br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	error = setpoint-sensor 
	if     (error &gt; 5){ output = -1 }
	else if(error &gt; 0){ output = -0.2 }
	else if(error &lt; 0){ output = 0.2 }
	else if(error &lt; -5){ output = 1 }
	motor.set(output)
})
<br>We've now slightly improved things; Now, we can expect more reasonable responses as we're close, and fast responses far away. But we still have the same problem; Those harsh transitions across each else if. Splitting up into more and more branches doesn't seem like it'll help. To resolve the problem, we'd need an infinite number of tiers, dependent on how far we are from our targets. <br>With a bit of math, we can do that! Our error term tells us how far we are, and the sign tells us what direction we need to go... so let's just scale that by some value. Since this is a constant value, and the resulting output is proportional to this term, let's call it kp: Our proportional constant. <br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	kp = 0.1
	error = setpoint-sensor 
	output = error*kp
	motor.set(output)
)}
<br>Now we have a better behaved algorithm! At a distance of 10, our output is 1. At 5, it's half. When on target, it's zero! It scales just how we want. <br>Try this on a real system, and adjust the kP until your motor reliably gets to your setpoint, where error is approximately zero. <br>In doing so, you might notice that you can still oscillate around your setpoint if your gains are too high. You'll also notice that as you get closer, your output drops to zero. This means, at some point you stop being able to get closer to your target. <br>This is easily seen on an elevator system. You know that gravity pulls the elevator down, requiring the motor to push it back up. For the sake of example, let's say an output of 0.2 holds it up. Using our previous kP of 0.1, a distance of 2 generates that output of 0.2. If the distance is 1, we only generate 0.1... which is not enough to hold it! Our system actually is only stable below where we want. What gives! <br> This general case is referred to as "standing error" ; Every loop through our PID fails to reduce the error to zero, which eventually settles on a constant value. So.... what if.... we just add that error up over time? We can then incorporate that error into our outputs. Let's do it.<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
kp = 0.1
ki = 0.001
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	output = error*kp + errorsum*ki
	motor.set(output)
}
<br>The mathematical operation involved here is called integration, which is what this term is called. That's the "I" in PID.<br>
In many practical FRC applications, this is probably as far as you need to go! P and PI controllers can do a lot of work, to suitable precision. This a a very flexible, powerful controller, and can get "pretty good" control over a lot of mechanisms. <br>This is probably a good time to read across the  <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" target="_blank">WPILib PID Controller</a>  page; This covers several useful features. Using this built-in PID, we can reduce our previous code to a nice formalized version that looks something like this.<br>PIDController pid = new PIDController(kP, kI, kD);
run(()-&gt;{
	sensor = motor.getEncoder.getPosition();
	motor.set(pid.calculate(sensor, setpoint))
})
<br>A critical detail in good PID controllers is the iZone. We can easily visualize what problem this is solving by just asking "What happens if we get a game piece stuck in our system"?<br>
Well, we cannot get to our setpoint. So, our errorSum gets larger, and larger.... until our system is running full power into this obstacle. That's not great. Most of the time, something will break in this scenario. <br>So, the iZone allows you to constrain the amount of error the controller actually stores. It might be hard to visualize the specific numbers, but you can just work backward from the math. If output = errorsum*kI, then maxIDesiredTermOutput=iZone*kI. So iZone=maxIDesiredTermOutput/kI.<br>Lastly, what's the D in PID?<br>Well, it's less intuitive, but let's try. Have you seen the large spike in output when you change a setpoint? Give the output a plot, if you so desire. For now, let's just reason through a system using the previous example PI values, and a large setpoint change resulting in an error of 20. <br>Your PI controller is now outputting a value of 2.0 ; That's double full power! Your system will go full speed immediately with a sharp jolt, have a ton of momentum at the halfway point, and probably overshoot the final target. So, what we want to do is constrain the speed; We want it fast but not too fast. So, we want to reduce it according to how fast we're going.<br>
Since we're focusing on error as our main term, let's look at the rate the error changes. When the error is changing fast we want to reduce the output. The difference is simply defined as error-previousError, so a similar strategy with gains gives us output+=kP*(error-previousError) .<br>
This indeed gives us what we want: When the rate of change is high, the contribution is negative and large; Acting to reduce the total output, slowing the corrective action.<br>However, this term has another secret power, which disturbance rejection. Let's assume we're at a steady position, and the system is settled, and error=0. Now, let's bonk the system downward, giving us a positive error. Suddenly nonzero-0 is positive, and the system generates a upward force. For this interaction, all components of the PID are working in tandem to get things back in place.<br><br>OK, that's enough nice things. Understanding PIDs requires knowing when they work well, and when they don't, and when they actually cause problems. <br>
<br>PIDs are reactive, not predictive. Note our key term is "error" ; PIDs only act when the system is already not where you want it, and must be far enough away that the generated math can create corrective action.
<br>Large setpoint changes break the math. When you change a setpoint, the P output gets really big, really fast, resulting in an output spike. When the PID is acting to correct it, the errorSum for the I term is building up, and cannot decrease until it's on the other side of the setpoint. This almost always results in overshoot, and is a pain to resolve.  
<br>Oscillation: PIDs inherently generate oscillations unless tuned perfectly. Sometimes big, sometimes small.
<br>D term instability: D terms are notoriously quirky. Large D terms and velocity spikes can result in bouncy, jostly motion towards setpoints, and can result in harsh, very rapid oscillations around the zero, particularly when systems have significant <a data-href="mechanical backlash" href="mechanical backlash" class="internal-link" target="_self" rel="noopener nofollow">mechanical backlash</a>.
<br>PIDS vs Hard stops: Most systems have one or more <a data-href="Hard Stops" href="Hard Stops" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a>, which present a problem to the I term output. This requires some consideration on how your encoders are initialized, as well as your setpoints.
<br>Tuning is either simple....or very time consuming.
<br>So, how do you make the best use of PIDs?<br>
<br>Reduce the range of your setpoint changes. There's a few ways to go about it, but the easiest are <a data-href="clamping" href="clamping" class="internal-link" target="_self" rel="noopener nofollow">clamping</a> changes, <a data-href="Slew Rate Limiting" href="misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a> and <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> . With such constraints, your error is always small, so you can tune more aggressively for that range. 
<br>Utilize <a data-href="FeedForwards" href="level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> to create the basic action; Feed-forwards create the "expected output" to your motions, reducing the resulting error significantly. This means your PID can be tuned to act sharply on disturbances and unplanned events, which is what they're designed for.
<br>In other words, this is an error correction mechanism, and if you avoid adding error to begin with, you more effectively accomplish the motions you want. Throwing a PID at a system can get things moving in a controlled fashion, but care should be taken to recognize that it's not intended as the primary control handler for systems. <br><br>PID<br>Requires:<br>
<a data-href="Motor Control" href="level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a velocity FF for a roller system that enables you to set the output in RPM
<br>Create a gravity FF for a elevator system that holds the system in place without resisting external movement
<br>Create a gravity FF for an arm system that holds the system in place without resisting external movement
<br><br>Feedforwards model an expected motor output for a  system to hit specific target values.<br>
The easiest example is a motor roller. Let's say you want to run at ~3000 RPM. You know your motor has a top speed of ~6000 RPM at 100% output, so you'd correctly expect that driving the motor at 50% would get about 3000 RPM. This simple correlation is the essence of a feed-forward. The details are specific to the system at play. <br><br>The WPILib docs have good fundamentals on feedforwards that is worth reading.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br><br>Feed-forwards are specifically tuned to the system you're trying to operate, but helpfully fall into a few simple terms, and straightforward calculations. In many cases, the addition of one or two terms can be sufficient to improve and simplify control. <br><br>The simplest feedforward you'll encounter is the "static feed-forward". This term represents initial momentum, friction, and certain motor dynamics. <br>You can see this in systems by simply trying to move very slow. You'll often notice that the output doesn't move it until you hit a certain threshhold. That threshhold is approximately equal to kS.<br>The static feed-forward affects output according to the simple equation of  <br><br>a kG value effectively represents the value needed for a system to negate gravity. <br>Elevators are the simpler case: You can generally imagine that since an elevator has a constant weight, it should take a constant amount of force to hold it up. This means the elevator Gravity gain is simply a constant value, affecting the output as  ; You don't need any other considerations regarding the system motion, because gravity is always constant. <br>A more complex kG calculation is needed for pivot or arm system. You can get a good sense of this by grabbing a heavy book, and holding it at your side with your arm down. Then, rotate your arm outward, fully horizontal. Then, rotate your arm all the way upward. You'll probably notice that the book is much harder to hold steady when it's horizontal than up or down.<br>The same is true for these systems, where the force needed to counter gravity changes based on the angle of the system. To be precise, it's maximum at horizontal, zero when directly above or below the pivot. Mathematically, it follows the function  ratio, lending this version of the feed-forward the nickname kCos.<br>This form of the gravity constant affects the output according to<br>
, where  is is the maximum output, at horizontal. <a data-footref="kcos" href="about:blank#fn-1-b7886cfc06b1959f" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> <br><br>The velocity feed-forward represents the expected output to maintain a target velocity. This term accounts for physical effects like dynamic friction and air resistance, and a handful of  <br>This is most easily visualized on systems with a velocity goal state. In that case,  is easily known, and contributes to the output as  .<br>In contrast, for positional control systems, knowing the desired system velocity is quite a challenge. In general, you won't know the target velocity unless you're using a <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to to generate the instantaneous velocity target. <br><br>The acceleration feed-forward largely negates a few inertial effects. It simply provides a boost to output to achieve the target velocity quicker.<br>like ,  is typically only known when you're working with <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>. <br><br>Putting this all together, it's helpful to de-mystify the math happening behind the scenes.<br>A roller system will often simply be<br>
If you don't have a motion profile, kA will simply be zero, and and kS might also be negligible unless you plan to operate at very low RPM.<br>An elevator system will look similar:<br>
Without a motion profile, you cannot properly utilize kV and kA, which simplifies down to<br>
where  is generally derived by  (since you know the current and previous positions).<br>Lastly, elevator systems differ only by the cosine term to scale kG.<br>
Again simplifying for systems with no motion profile, you get<br>
It's helpful to recognize that because the angle is being fed to a  function, you cannot use degrees here! Make sure to convert. <br>Of course, the intent of a feed-forward is to model your mechanics to improve control. As your system increases in complexity, and demands for precision increase, optimal control might require additional complexity! A few common cases: <br>
<br>If you have a pivot arm that extends, your kG won't be constant! 
<br>Moving an empty system and one loaded with heavy objects might require different feed-forward models entirely.
<br>Long arms might be impacted by motion of systems they're mounted on, like elevators or the chassis itself! You can add that in and apply corrective forces right away.
<br><br>Since a feed-forward is prediction about how your system behaves, it works very well for fast, responsive control. However, it's not perfect; If something goes wrong, your feed-forward simply doesn't know about it, because it's not measuring what actually happens. <br>In contrast, feed-back controllers like a  <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> are designed to act on the error between a system's current state and target state, and make corrective actions based on the error. Without first encountering system error, it doesn't do anything.<br>The combination of a feed-forward along with a feed-back system is the power combo that provides robust, predictable motion.<br><br>WPILib has several classes that streamline the underlying math for common systems, although knowing the math still comes in handy! The docs explain them (and associated warnings) well.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br>Integrating in a robot project is as simple as crunching the numbers for your feed-forward and adding it to your motor value that you write every loop.<br>ExampleSystem extends SubsystemBase(){

	SparkMax motor = new SparkMax(...)
	// Declare our FF terms and our object to help us compute things.
	double kS = 0.0;
	double kG = 0.0;
	double kV = 0.0;
	double kA = 0.0;
	ElevatorFeedforward feedforward = new ElevatorFeedforward(kS, kG, kV, kA);
	
	ExampleSubsystem(){}

	Command moveManual(double percentOutput){
		return run(()-&gt;{
			var output ;
			//We don't have a motion profile or other velocity control
			//Therefore, we can only assert that the velocity and accel are zero
			output = percentOutput+feedforward.calculate(0,0);
			// If we check the math, this feedforward.calculate() thus 
			// evaluates as simply kg;
			
			// We can improve this by instead manually calculating a bit
			// since we known the direction we want to move in
			output = percentOutput + Math.signOf(percentOutput) + kG;
			motor.set(output);
		})
	}

	Command movePID(double targetPosition){
		return run(()-&gt;{
			//Same notes as moveManual's calculations 
			var feedforwardOutput = feedforward.calculate(0,0);
			// When using the Spark closed loop control, 
			// we can pass the feed-forward directly to the onboard PID
			motor
			.getClosedLoopController()
			.setReference(
				targetPosition,
				ControlType.kPosition,
				ClosedLoopSlot.kSlot0,
				feedforwardOutput, 
				ArbFFUnits.kPercentOut
			);
			//Note, the ArbFFUnits should match the units you calculated!
		})
	}

	Command moveProfiled(double targetPosition){
		// This is the only instance where we know all parameters to make 
		// full use of a feedforward.
		// Check [[Motion Profiles]] for further reading
	}
	
}
<br><br>High gains
When tuning feed-forwards, it's helpful to recognize that values being too high will result in notable problems, but gains being too low generally result in lower performance.<br>
Just remember that the lowest possible value is 0; Which is equivalent to not using that feed forward in the first place. Can only improve from there. 
<br><br>These two terms are defined at the boundary between "moving" and "not moving", and thus are closely intertwined. Or, in other words, they interfere with finding the other. So it's best to find them both at once.<br>It's easiest to find these with manual input, with your controller input scaled down to give you the most possible control.<br>Start by positioning your system so you have room to move both up and down. Then, hold the system perfectly steady, and increase output until it just barely moves upward. Record that value.<br>
Hold the system stable again, and then decrease output until it just barely starts moving down. Again, record the value. <br>Thinking back to what each term represents, if a system starts moving up, then the provided input must be equal to ; You've negated both gravity and the friction holding it in place. Similarly, to start moving down, you need to be applying . This insight means you can generate the following two equations  <br><br>Helpfully, for systems where  like roller systems, several terms cancel out and you just get  .<br>For pivot/arm systems, this routine works as described if you can calculate kG at approximately horizontal. It cannot work if the pivot is vertical. If your system cannot be held horizontal, you may need to be creative, or do a bit of trig to account for your recorded  being decreased by <br>Importantly, this routine actually returns a kS that's often slightly too high, resulting in undesired oscillation. That's because we recorded a minimum that causes motion, rather than the maximum value that doesn't cause motion. Simply put, it's easier to find this way. So, we can just compensate by reducing the calculated kS slightly; Usually multiplying it by 0.9 works great. <br><br>Because this type of system system is also relatively linear and simple, finding it is pretty simple. We know that , and expect . <br>We know  is going to be constrained by our motor's maximum RPM, and that maxOutput is defined by our api units (either +/-1.0 for "percentage" or +/-12 for "volt output"). <br>This means we can quickly assert that  should be pretty close to . <br><br>Beyond roller kV, kA and kV values are tricky to identify with simple routines, and require <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to take advantage of. As such, they're somewhat beyond the scope of this article.<br>The optimal option is using <a data-href="System Identification" href="level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a> to calculate the system response to inputs over time. This can provide optimal, easily repeatable results. However, it involves a lot of setup, and potentially hazardous to your robot when done without caution.<br>The other option is to tune by hand; This is not especially challenging, and mostly involves a process of moving between goal states, watching graphs, and twiddling numbers. It usually looks like this:<br>
<br>Identify two setpoints, away from hard stops but with sufficient range of motion you can hit target velocities. 
<br>While cycling between setpoints, ihen increase kV until the system generates velocities that match the target velocities. They'll generally lag behind during the accelleration phase. 
<br>Then, increase kA until the accelleration shifts and the system perfectly tracks your profile. 
<br>Increase profile constraints and and repeat until system performance is attained. Starting small and slow prevents damage to the mechanics of your system.
<br>This process benefits from a relatively low P gain, which helps keep the system stable. Once your system is tuned, you'll probably want a relatively high P gain, now that you can assert the feed-forward is keeping your error close to zero. <br><br>
<br>
<br>Note, you might observe that the kCos output,   is reading the current system state, and say "hey!  That's a feed back system, not a feed forward!" and you are technically correct; the best kind of correct. However, kCos is often implemented this way, as it's much more stable than the feed-forward version. In that version, you apply , regardless of what  happens to actually be. Feel free to do a thought experiment on how this might present problems in real-world systems.<a href="about:blank#fnref-1-b7886cfc06b1959f" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
FeedForwards<br><br>Understand the typical Git operations most helpful for day-to-day programming<br><br>This module is intended to be completed alongside other tasks.<br>
<br>Initialize a git repository in your project
<br>Create an initial commit
<br>Create several commits representing simple milestones in your project
<br>When moving to a new skill card, create a new branch to represent it. Create as many commits on the new branch as necessary to track your work for this card. 
<br>When working on a skill card that does not rely on the previous branch, switch to your main branch, and create a new branch to  represent that card.
<br>On completion of that card (or card sequence), merge the results of both branches back into Main.
<br>Upon resolving the merge, ensure both features work as intended.
<br><br>
<br>Understanding git
<br>workspace, staging, remotes
<br>fetching
<br>Branches + commits
<br>Pushing and pulling
<br>Switching branches
<br>Merging
<br>Merge conflicts and resolution
<br>Terminals vs integrated UI tools
<br>In general<br><br><br><a rel="noopener nofollow" class="external-link" href="https://mermaid.live/edit#pako:eNqFUM1OxiAQfJUve24aaAulXDXx5AuYXrDsR4kFGgSjNn13sZ8_ica4p9nZmdlkNpiCRpBgbLqJap1HfyozBeds-o3vo_LTfNL4hEtYP-4zTg8hpx_sHwlfaqesv1AOo8H_3FCBiVaDTDFjBcVTAsoK27tqhDSjwxFkgRrPKi9phNHvxbYqfxeC-3TGkM0M8qyWx7LlVauE11aZqL4l6DXGq5B9AkmHIwLkBs8gG8Fq3lLBeccY6QWt4KWwhNU960jXsn6ghDK-V_B6PCW1oJQ2HWt4OwhOBasAtU0h3l6KP_rf3wA0I3rV" target="_blank">https://mermaid.live/edit#pako:eNqFUM1OxiAQfJUve24aaAulXDXx5AuYXrDsR4kFGgSjNn13sZ8_ica4p9nZmdlkNpiCRpBgbLqJap1HfyozBeds-o3vo_LTfNL4hEtYP-4zTg8hpx_sHwlfaqesv1AOo8H_3FCBiVaDTDFjBcVTAsoK27tqhDSjwxFkgRrPKi9phNHvxbYqfxeC-3TGkM0M8qyWx7LlVauE11aZqL4l6DXGq5B9AkmHIwLkBs8gG8Fq3lLBeccY6QWt4KWwhNU960jXsn6ghDK-V_B6PCW1oJQ2HWt4OwhOBasAtU0h3l6KP_rf3wA0I3rV</a>Git Basics<br>See Official Documentation
The official radio documentation is complete and detailed, and should serve as your primary resource.<br>
<a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/" target="_blank">https://frc-radio.vivid-hosting.net/</a>
However, It's not always obvious what you need to look up to get moving. Consider this document just a simple guide and jumping-off point to find the right documentation elsewhere
<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/quick-start-guide" target="_blank">https://frc-radio.vivid-hosting.net/overview/quick-start-guide</a><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html" target="_blank">https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html</a><br><br>You don't! The Field Technicians at competitions will program the radio  for competitions. <br>When configured for competition play, you cannot connect to the radio via wifi. Instead, use an ethernet cable, or <br><br>The home radio configuration is a common pain point<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview" target="_blank">https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview</a><br><br>This option is the simplest: Just connect the robot via an ethernet or USB, and do whatever you need to do. For quick checks, this makes sense, but obviously is suboptimal for things like driving around. <br><br>The radio does have a 2.4ghz wifi hotspot, albeit with some limitations. This mode is suitable for many practices, and is generally the recommended approach for most every-day practices due to ease of use.<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions" target="_blank">https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions</a><br>Note, this option requires access to the tiny DIP switches on the back of the radio! You'll want to make sure that your hardware teams don't mount the radio in a way that makes this impossible to access. <br><br>This option uses a second radio to connect your laptop to the robot. This is the most cumbersome and limited way to connect to a robot, and makes swapping who's using the bot a bit more tricky. <br>However, this is also the most performant and reliable connection method. This is recommended when doing extended driving sessions, final performance tuning, and  other scenarios where you're trying to simulate competition-ready environments. <br>This option has a normal robot on one end, and your driver-station setup will look the following image.  See <a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/practicing-at-home" target="_blank">https://frc-radio.vivid-hosting.net/overview/practicing-at-home</a> for full setup directions<br>
<img alt="vidid-radio-wifi-bridge.png.png" src="assets/vidid-radio-wifi-bridge.png.png"><br><br><br>Port forwarding allows you to bridge networks across different interfaces. <br>The practical application in FRC is being able to access network devices via the USB interface! This is mostly useful for quickly interfacing with Vision hardware like the <a data-tooltip-position="top" aria-label="Limelight Basics" data-href="Limelight Basics" href="level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight</a> or <a data-tooltip-position="top" aria-label="PhotonVision Basics" data-href="PhotonVision Basics" href="level-2/photonvision-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Photonvision</a> at competitions.<br>//Add in the constructor in Robot.java or RobotContainer.java

// If you're using a Limelight
PortForwarder.add(5800, "limelight.local", 5800);
// If you're using PhotonVision
PortForwarder.add(5800, "photonvision.local", 5800);
<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html" target="_blank">https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html</a><br><br>The radio has some scriptable interfaces, allowing programmatic access to quickly change or read settings. <br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced" target="_blank">https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced</a>Robot Radio]]></description><link>stormbreakers-tree.html</link><guid isPermaLink="false">StormBreakers Tree.canvas</guid><pubDate>Thu, 19 Jun 2025 06:01:43 GMT</pubDate><enclosure url="assets/driverstation.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/driverstation.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[General Details]]></title><description><![CDATA[ 
 <br><br>
<br>Standardize "Success Criteria" for proving you've completed a particular skill
<br>Add Learning Objective to some/all items
<br><br>
<br>PID: Position control vs velocity control
<br>Joystick and Input Basics
<br>Solenoids + Pnuematics
<br>Rev Hardware Client
<br>PWM Output
<br>DigitalInput channels and switches
<br>LEDs
<br>SPI, I2C, other communication busses
<br>Custom controllers
<br>bang-bang-controllers
<br>Git as a lesson plan
<br>Code structuring (Stormbreakers)
<br>How to identify when to refactor
<br>How to read documentation
<br><br><a data-href="clamping" href="clamping" class="internal-link" target="_self" rel="noopener nofollow">clamping</a><br>
<a data-href="units" href="units" class="internal-link" target="_self" rel="noopener nofollow">units</a><br>
<a data-href="mechanical backlash" href="mechanical backlash" class="internal-link" target="_self" rel="noopener nofollow">mechanical backlash</a><br>
<a data-href="Hard Stops" href="Hard Stops" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a><br><a data-href="Scheduler" href="Scheduler" class="internal-link" target="_self" rel="noopener nofollow">Scheduler</a> &lt;-- ? <br>Data Structures: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=KwBuV7YZido" target="_blank">https://www.youtube.com/watch?v=KwBuV7YZido</a><br><br>
<br>Rev Hardware Client
<br>Pathplanner/choreo
<br>GrappleHook
<br><a data-href="Driver Station" href="misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a>
]]></description><link>todo.html</link><guid isPermaLink="false">TODO.md</guid><pubDate>Thu, 19 Jun 2025 01:56:27 GMT</pubDate></item></channel></rss>