<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[CodeTest]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://stormbots.github.io/KnowledgeBase/</link><image><url>https://stormbots.github.io/KnowledgeBase/lib/media/favicon.png</url><title>CodeTest</title><link>https://stormbots.github.io/KnowledgeBase/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 03 Oct 2025 20:13:20 GMT</lastBuildDate><atom:link href="https://stormbots.github.io/KnowledgeBase/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 03 Oct 2025 20:13:18 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Compound Subsystem]]></title><description><![CDATA[ 
 <br>A compound subsystem is one that has multiple, interlinked mechanisms. Many common systems as <a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intakes</a> or <a data-tooltip-position="top" aria-label="Superstructure Shooter" data-href="Superstructure Shooter" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Shooters</a> fall into this, as do complex kinematic systems like extendable <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a>, or Arms riding <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a> form a compound subsystem.<br>These systems have common quirks in how they interact with <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> and <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> control flow.<br><br>Generally, you do not want to bundle two or more actuators together into the same subsystem; Inevitably, you will need a Command that tries to require() one, but forcibly require the second. <br>This makes some command sequences awkward, since you need to require and control an actuator you don't care about. Alternatively, streamlining the system to automatically control just one or the other means extending the subsystem with multiple state tracking, as you can't rely on defaultCommands() which won't be active.<br>Combining multiple actuators in one system also can lead you to cases that block code re-use. Having simple commands that control "half" the system cannot be run in parallel without obscure, poorly documented command modifiers or forcibly removing the command mutexes. <br>Lastly, you need to name and manage commands to interact with both actuators, making the subsystem large and complicated.<br><br>A better structure is to simply break them into two subsystems, giving them the minimal controls needed to act independently. <br>You can then use a separate container class to house utility functions, or combined Command classes that interact with both systems.<br>Note, the wrapper class will not be a subsystem itself: WPILib does not support "requires" through nested subsystems.<br><br>DefaultCommands by their nature must require themselves, and can only require themselves; This means it's not possible to have a "default" for two subsystems. <br>In some cases, you may be able to simply leave each individual part with a default command. <br>However, if you wish to have them default as a group, you can emulate the "default command" behavior through the use of a Trigger, and detection of the currently commanded state of any controlled systems. <br><br><br><br>Scheduling some actions based on sensors might wind up interfering with other ongoing robot tasks. Remember, they're exactly like a driver hitting a button!<br>For example, if you automatically "grab" a loaded game piece, like this: <br>public class IntakeSubsystem extends SubsystemBase{
	public IntakeSubsystem(){
		new Trigger(isGamePieceLoaded).onTrue(holdGamePiece());
	}
	public Command holdGamePiece(){
		return run(()-&gt;motor.set(0.1));
	}
	
}
<br>and then try to run a sequence like this:<br>public class RobotContainer(){
	public Command fancyGrabGamepiece(){
		return new SequentialCommand(){
			elevator.goToBottom(),
			intake.intake(), //&lt;-- This causes your trigger to run! 
			//Command will get cancelled here
			elevator.goToScoringPosition() //won't run
		}
	}
}
<br>You will be annoyed by the unexpected behavior. Worse, if there's a sensor glitch, you might cancel scoring operations too! Instead of getting points, you just suck the game piece back in. <br>In cases where such conflicts might come up, you can detect if a Command requires the subystem, by adding some conditions to the trigger, preventing unexpected launches during other actions. <br>java1<br>2<br>3	//Check to see if *any* command is scheduled.
	new Trigger(isGamePieceLoaded)
	.and(this.getCurrentCommand()==null) //Null returned if no command running
	.onTrue(holdGamePiece());

	//Check to see if the current command is "default"
	// We probably don't mind interrupting the default.
	new Trigger(isGamePieceLoaded)
	.and(this.getCurrentCommand()==this.getDefaultCommand())
	.onTrue(holdGamePiece());
	//Note, if you have no defaultCommand getDefaultCommand() will 
	//return null!
<br>These methods allow your trigger to intentionally set its own priority below other commands that might be interacting with the system. <br><br><br>If your systems should be operating with dependent kinematics or logic for decision making, you can do this a couple ways:<br>// Via Dependency injection of state functions
BottomSystem bottom = new BottomSystem();
TopSystem top = new TopSystem(bottomsystem::getPosition);
<br>This allows a clear distinction of systems, while still permitting TopSystem to access details it may need to see on the bottom.<br>This interaction is pretty ineffective things such as two-way collision conflicts. For such cases, you likely want to use a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machine</a> to control motion.<br>While not recommended, you can bind cross-dependencies between two systems. However, this cyclic connection should clue you to the need to <a data-tooltip-position="top" aria-label="Refactoring" data-href="Refactoring" href="https://stormbots.github.io/KnowledgeBase/misc/refactoring.html" class="internal-link" target="_self" rel="noopener nofollow">Refactor</a> some of your code interactions. <br>//Construct the subsystem 
public class BottomSystem extends SubsystemBase{
	// Leaving this blank will likely result in runtime errors, 
	// so initialize it with an appropriate Supplier function
	DoubleSupplier topPosition = ()-&gt;0 ;
	
	//Create a function to register it
	public void addTopPositionSupplier(DoubleSupplier supplier){
		topPosition=supplier;
	}
}
public class RobotContainer{
	// Create the appropriate systems
	BottomSystem bottom = new BottomSystem();
	TopSystem top = new TopSystem();
	RobotContainer(){
		bottom.addTopPositionSupplier(top.getPosition());
		top.addBottomPositionSupplier(bottom.getPosition());
	}
}
<br><br>New Process!
This subsystem type tends to be rare, and as such we do not implement this often to fully validate best practices. Feedback on the documentation and trial methods for optimal layout is requested!
<br>Sometimes, your robot will have a subsystem that is two "identical" parts that are not kinetically linked. In these cases, the subsystem split can be quirky, and they tend to provide different tradeoffs<br>
<br>Handling each half as it's own subsystem with independent code generates a lot of copy-pasted code, repeated bugfixes, and increased maintenance overhead. 
<br>Bundling both in the same subsystem can result in duplicate code to drive the separate motors,  especially if they each run independent, non-trivial logic like <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> 
<br>Providing a "base class" and then creating two instances: This simplifies control logic and reduces code duplication, but pushes all a fair amount of configuration and combined logic to higher-level code structures (such as RobotContainer . 
<br>However, in general the final option is often worth it to prevent errors and streamline debugging. With proper naming, abstraction, and parameterize, these systems can be handled without significant overhead. <br><br>While there's a few ways we could structure this in general we want to keep subsystem logic<br>
contained in it's own file for easy tracking, viewing, and modification. Since we expect twinned systems to have few difference, this structure provides a simple way to easily manage the adjustments.<br>//This forms our the base class both ExampleTwin systems will use 
class ExampleTwinBase extends SubsystemBase{
	//Private to prevent unexpected creation anywhere
	private ExampleTwinBase(boolean invert, double switchChannel){
		//Configure the motor using the provided parameters
		// making sure to use the parameters as appropriate.
		// In this example, 
		// using "invert" for motor direction, 
		// and switchChannel for a rio DIO port for something
		// but provide the necessary ones in whatever form makes sense.
	}
	
	public static BuildExampleLeft(){
		var inverted=false; //
		var channel=0; //example 
		return new ExampleTwinBase(inverted,channel);
	}
	
	public static BuildExampleRight(){
		var inverted=true; //
		var channel=1; //example 
		return new ExampleTwinBase(inverted,channel);
	}
	
	//Do the rest of your normal, non-static instance classes here.
}
<br>public class RobotContainer{
	//We can now build the two seperately, using the static functions
	// to handle the difference in configuration
	ExampleTwinBase exampleLeft=ExampleTwinBase.BuildExampleLeft();
	ExampleTwinBase exampleRight=ExampleTwinBase.BuildExampleRight();
}
<br>Rev's Config api has a useful feature that allows you to combine configs; This facilitates splitting logic, and even allows you to provide a Spark config as a parameter directly.<br>public ExampleRevParam(SparkBaseConfig customConfig){
	SparkBaseConfig config = new SparkMaxConfig();
	config./*whatever your configs that apply in both cases*/

	config.apply(customConfig); // Copy the special configs to the base config

	//Apply your config normally, getting everything at once
	motor.configure(
		config,
		ResetMode.kResetSafeParameters, 
		PersistMode.kNoPersistParameters
	);
};
<br>We now have two subsystems.... which is not exactly optimal for clean Command setup. However, a simple wrapper class will help us out!<br>public Example{ //NOTE: Not a subsystem! Just a generic class
	ExampleTwinBase left;
	ExampleTwinBase right;
	public ExampleSubsystem(ExampleTwinBase left, ExampleTwinBase right){
		this.left=left;
		this.right=right;
	}
	//Now, we can use *this* to house all our combo commands nice and cleanly!
	// Parallel runs both at once, and each end independently if configured.
	// When both are done, the parallel ends. 
	public Command doTheThing(){
		returns Commands.parallel(
			left.doTheThing(),
			right.doTheThing()
		);
	}
	
}
<br>public class RobotContainer{
	//We can now build the two seperately, using the static functions
	// to handle the difference in configuration
	ExampleTwinBase exampleLeft=ExampleTwinBase.BuildExampleLeft();
	ExampleTwinBase exampleRight=ExampleTwinBase.BuildExampleRight();
	Example example = Example(exampleLeft,exampleRight);
}
<br>Cleanup Note We could also just move the whole Builder calls directly in the wrapper, or directly into the Example file itself! Depending on the goals, this may or may not be ideal. Sometimes having access to each side is nice, so consider leaving yourself an easy option should the need arise.<br>//Example of the streamlined, cleaned up code. The individual sides are now not accessable without going through our wrapper.
public class RobotContainer{
	Example example = Example(
		ExampleTwinBase.BuildExampleLeft(),
		ExampleTwinBase.BuildExampleRight()
	);
}
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/compound-subsystem.html</link><guid isPermaLink="false">Level 1/Compound Subsystem.md</guid><pubDate>Fri, 03 Oct 2025 09:53:10 GMT</pubDate></item><item><title><![CDATA[Homing Sequences]]></title><description><![CDATA[ 
 <br>Homing is the process of recovering physical system positions, typically using relative encoders.<br><br><a data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br>
<a data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
And will generally be done after most requirements for those systems<br><br>
<br>Home a subsystem using a Command-oriented method
<br>Home a subsystem using a state-based method
<br>Make a non-homed system refuse non-homing command operations
<br>Document the "expected startup configuration" of your robot, and how the homing sequence resolves potential issues.
<br><br>
<br>Configure encoders and other system configurations
<br>Construct a Command that homes the system
<br>Create a Trigger to represent if the system is homed or not
<br>Determine the best way to integrate the homing operation. This can be 

<br>Initial one-off sequence on enable
<br>As a blocking operation when attempting to command the system
<br>As a default command with a Conditional Command
<br>Idle re-homing (eg, correcting for slipped belts when system is not in use)
<br>


<br><br>
<br>Home an elevator system using system current
<br>home an arm system using system current
<br>Home a system 
<br><br>When a system is booted using <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a>, the encoder boots with a value of 0, like you'd expect. However, the real physical system can be anywhere in it's normal range of travel, and the bot has no way to know the difference.<br>Homing is the process of reconciling this difference, this allowing your code to assert a known physical position, regardless of what position it was in when the system booted. <br><br>Homing is not a hard requirement of <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> or <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> systems. As long as you boot your systems in known, consistent states, you operate without issue.<br>However, homing is generally recommended, as it provides benefits and safeguards<br>
<br>You don't need strict power-on procedures. This is helpful at practices when the bot will be power cycled and get new uploaded code regularly. 
<br>Power loss protection: If the bot loses power during a match, you just lose time when re-homing; You don't lose full control of the bot, or worse, cause serious damage.
<br>Improved precision: Homing the system via code ensures that the system is always set to the same starting position. 
<br><br>Hard stops
When looking at homing, the concept of a "Hard Stop" will come up a lot. A hard stop is simply a physical constraint at the end of a system's travel, that you can reliably anticipate the robot hitting without causing system damage.<br>
In some bot designs, hard stops are free. In other designs, hard stops require some specific engineering design.
<br>Safety first!
Any un-homed system has potential to perform in unexpected ways, potentially causing damage to itself or it's surroundings.<br>
We'll gloss over this for now, but make sure to set safe motor current constraints by default, and only enable full power when homing is complete.
<br><br>With this method, the consistency comes from the physical reset of the robot when first powering on the robot. Humans must physically set all non-homing mechanisms, then power the robot. <br>From here, you can do anything  you would normally do, and the robot knows where it is. <br>This method is often "good enough", especially for testing or initial bringup. For some robots, gravity makes it difficult to boot the robot outside of the expected condition.<br>Watch your resets!
With this method, make sure your code does not reset encoder positions when initializing.<br>
If you do, code resets or power loss will cause a de-sync between the booted position and the operational one. You have to trust the motor controller + encoder to retain positional accuracy. 
<br><br>Current detection is a very common, and reliable method within FRC. With this method, you drive the system toward a hard stop, and monitor the system current.<br>When the system hits the hard stop, the load on your system increases, requiring more power. This can be detected by polling for the motor current. When your system exceeds a specific current for a long enough time, you can assert that your system is homed! A <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> is a great tool for helping monitor this condition.<br><br>Speed Detection works by watching the encoder's velocity. You expect that when you hit the hard stop, the velocity should be zero, and go from there. However, there's some surprises that make this more challenging than current detection. <br>Velocity measurements can be very noisy, so using a <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/index.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/index.html" target="_blank">filter</a> is generally required, although debounced <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> can sometimes work.<br>This method also suffers from the simple fact that the system velocity will be zero when homing starts. And zero is also the speed you're looking for as an end condition. You also cannot guarantee that the system speed ever increases above zero, as it can start against the hard stop.<br>
As such, you can't do a simple check, but need to monitor the speed for long enough to assert that the system should have moved if it was able to. <br><br>Limit switches are a tried and true method in many systems. You simply place a physical switch at the end of travel; When the bot hits the end of travel, you know where it is.<br>Mechanical Robustness Required
Limit switches require notable care on the design and wiring to ensure that the system reliably contacts the switch in the manner needed.
<br>The apparent simplicity of a limit switch hides several design and mounting considerations. In an FRC environment, some of these are surprisingly tricky.<br>
<br>A limit switch must not act as an end stop. Simply put, they're not robust enough to sustain impacts and will fail, leaving your system in an uncontrolled, downward driving stage. 
<br>A limit switch must be triggered at the end of travel; Otherwise, it's possible to start below the switch. 
<br>A switch must have a consistent "throw" ; It should trip at the same location every time. Certain triggering mechanisms and arms can cause problems.
<br>If the hard stop moves or is adjusted, the switch will be exposed for damage, and/or result in other issues
<br>Because of these challenges, limit switches in FRC tend to be used in niche applications, where use of hard stops is restricted. One such case is screw-driven <a data-href="Linear Actuators" href="https://stormbots.github.io/KnowledgeBase/Linear Actuators" class="internal-link" target="_self" rel="noopener nofollow">Linear Actuators</a>, which generate enormous amounts of force at very low currents, but are very slow and easy to mount things to.<br>Switches also come in multiple types, which can impact the ease of design. In many cases, a magnetic hall effect sensor is optimal, as it's non-contact, and easy to mount alongside a hard stop to prevent overshoot.<br>Most 3D printers use limit switches, allowing for very good demonstrations of the routines needed to make these work with high precision.<br>For designs where hard stops are not possible, consider a Roller Arm Limit Switch and run it against a CAM. This configuration allows the switch to be mounted out of the line of motion, but with an extended throw. <br><img alt="limit-switch-cam.svg" src="https://stormbots.github.io/KnowledgeBase/lib/media/limit-switch-cam.svg"><br><br>Index switches work similarly to Limit Switches, but the expectation is that they're in the middle of the travel, rather than at the end of travel. This makes them unsuitable as a solo homing method, but useful as an auxiliary one. <br>Index switches are best used in situations where other homing routines would simply take too long, but you have sufficient knowledge to know that it should hit the switch in most cases.<br>
This can often come up in <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> systems where the robot starting configuration puts the carriage far away from the nearest limit. <br>In this configuration, use of a non-contact switch is generally preferred, although a roller-arm switch and a cam can work well.<br><br>In some cases we can use absolute sensors such as <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a>, <a data-tooltip-position="top" aria-label="Gyro Sensing" data-href="Gyro Sensing" href="https://stormbots.github.io/KnowledgeBase/level-1/gyro-sensing.html" class="internal-link" target="_self" rel="noopener nofollow">Gyros</a>, or <a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">Range Finders</a> to directly detect information about the robot state, and feed that information into our other sensors. <br>This method works very effectively on <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> based systems; <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a> on an output shaft provide a 1:1 system state for almost all mechanical designs. <br>Elevator systems can also use these routines using <a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">|Range Finders</a> , detecting the distance between the carriage and end of travel. <br>Clever designers can also use <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a> for elevators in a few ways <br>
<br>You can simply assert a position within a narrow range of travel
<br>You can gear the encoder to have a lower resolution across the full range of travel. Many encoders have enough precision that this is perfectly fine.
<br>You can use multiple absolute encoders to combine the above global + local states
<br>For a typical system using Spark motors and Through Bore Encoders, it looks like this:<br>public class ExampleSubsystem{
	SparkMax motor = new Sparkmax(/*......*/);
	ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		//Configure the motor's encoders to use the same real-world unit
		armMotor.configure(config,/***/);
		
		//We can now compare the values directly, and initialize the 
		//Relative encoder state from the absolute sensor.
		var angle = motor.getAbsoluteEncoder.getPosition();
		motor.getEncoder.setPosition(angle);
	}
}
<br><br>A relatively simple routine, but just running your system with a known minimum power for a set length of time can ensure the system gets into a known position. After the time, you can reset the encoder. <br>This method is very situational. It should only be used in situations where you have a solid understanding of the system mechanics, and know that the system will not encounter damage when ran for a set length of time. This is usually paired with a lower current constraint during the homing operation.<br><br>In some cases you might be able to find the system home state (using gravity or another method), but find <a data-tooltip-position="top" aria-label="Mechanical Backlash" data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">backlash</a> is preventing you from hitting desired consistency and reliability.<br>This is most likely to be needed on <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> systems, particularly actuated <a data-tooltip-position="top" aria-label="Superstructure Shooter" data-href="Superstructure Shooter" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Shooter</a> systems. This is akin to a "calibration" as much as it is homing.<br>In these cases, homing routines will tend to find the absolute position by driving downward toward a hard stop. In doing so, this applies drive train tension toward the down direction. However, during normal operation, the drive train tension will be upward, against gravity. <br>This gives a small, but potentially significant difference between the "zero" detected by the sensor, and the "zero" you actually want. Notably, this value is not a consistent value, and wear over the life of the robot can impact it.<br>Similarly, in "no-homing" scenarios where you have gravity assertion, the backlash tension is effectively randomized. <br>To resolve this, backlash compensation then needs to run to apply tension "upward" before fully asserting a fully defined system state. This is a scenario where a time-based operation is suitable, as it's a fast operation, from a known state. The power applied should also be small, ideally a large value that won't cause actual motion away from your hard stop (meaning, at/below <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">kS+kG</a> ).<br>For an implementation of this, see <a data-tooltip-position="top" aria-label="https://github.com/stormbots/Crescendo/blob/main/src/main/java/frc/robot/commands/CalibrateShooter.java" rel="noopener nofollow" class="external-link" href="https://github.com/stormbots/Crescendo/blob/main/src/main/java/frc/robot/commands/CalibrateShooter.java" target="_blank">CalibrateShooter</a> from Crescendo.<br><br>Nominally, homing a robot is done once at first run, and from there you know the position. However, sometimes the robot has known mechanical faults that cause routine loss of positioning from the encoder's perspective. However, other sensors may be able to provide insight, and help correct the error.<br>
This kind of error most typically shows up in belt or chain skipping. <br>To overcome these issues, what you can do is run some condition checking alongside your normal runtime code, trying to identify signs that the system is in a potentially incorrect state, and correcting sensor information.<br>This is best demonstrated with examples: <br>
<br>If you home a elevator to the bottom of a drive at position 0, you should never see encoder values be negative. As such, seeing a "negative" encoder value tells you that the mechanism has hit end of travel.
<br>If you have a switch at the limit of travel, you can just re-assert zero every time you hit it. If there's a belt slip, you still end up at zero.
<br>If an arm should rest in an "up" position, but the slip trends to push it down, retraction failures might have no good detection modes. So, simply apply a re-homing technique whenever the arm is in idle state.
<br>Band-Aid Fix
Online Position Recovery is a useful technique in a pinch. But, as with all other hardware faults, it's best to fix it in hardware. Use only when needed.
<br>If the system is running nominally, these techniques don't provide much value, and can cause other runtime surprises and complexity, so it's discouraged.<br>
In cases where such loss of control is hypothetical or infrequent, simply giving drivers a homing/button tends to be a better approach. <br><br>When doing homing, you typically have 4 system states, each with their own behavior. Referring it to it as a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machine</a> is generally simpler <br><br><br>The UnHomed state should be the default bootup state. This state should prepare your system to <br>
<br>A boolean flag or state variable your system can utilize
<br>Safe operational current limits; Typically this means a low output current or speed control.
<br>It's often a good plan to have some way to manually trigger a system to go into the Unhomed state and begin homing again. This allows your robot drivers to recover from unexpected conditions when they come up. There's a number of ways your robot can lose position during operation, most of which have nothing to do with software.<br><br>The Homing state should simply run the desired homing strategy. <br>Modeling this sequence tends to be the tricky part, and a careless approach will typically reveal a few issues<br>
<br>Modelling the system with driving logic in the subsystem and Periodic routine typically clashes with the general flow of the Command structure. 
<br>Modelling the Homing as a command can result in drivers cancelling the command, leaving the system in an unknown state
<br>And, trying to continuously re-apply homing and cancellation processes can make the drivers frustrated as the system never gets to the known state.
<br>Trying to make many other commands check homing conditions can result in bugs by omission.
<br>The obvious takeaway is that however you home, you want it to be fast and preferably completed before the drivers try to command the system. Working with your designers can streamline this process.<br>Use of the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> decorator withInterruptBehavior(...) allows an easy escape hatch. This flag allows an inversion of how Command are scheduled; Instead of new commands cancelling running ones, this allows your homing command to forcibly block others from getting scheduled.<br>If your system is already operating on an internal state machine, homing can simply be a state within that state machine.<br><br>This state is easy: Your system can now assert the known position, set your Homed state, apply updated power/speed constraints, resume normal operation.<br><br><br>Conveniently, the whole homing process actually fits very neatly into the <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> model, making for a very simple implementation<br>
<br>init() represents the unhomed state and reset
<br>execute() represents the homing state
<br>isFinished() checks the system state and indicates completion
<br>end(cancelled) can handle the homed procedure
<br>class ExampleSubsystem extends SubsystemBase(){
	SparkMax motor = ....;
	private boolean homed=false;
	ExampleSubsystem(){
		motor.setMaxOutputCurrent(4); // Will vary by system
	}

	public Command goHome(){
		return new FunctionalCommand(
			()-&gt;{
				homed=false;
				motor.setMaxOutputCurrent(4);
			},
			()-&gt;{motor.set(-0.5);},
			()-&gt;{return motor.getAppliedCurrent()&gt;3}, //isFinished
			(cancelled)-&gt;{
				if(cancelled==false){
					homed = true;
					motor.setMaxOutputCurrent(30);
				}
			};
		)
		//Optionally: prevent other commands from stopping this one
		//This is a *very* powerful option, and one that
		//Should only be used when you know it's what you want.
		.withInterruptBehavior(kCancelIncoming)
		// Failsafe in case something goes wrong,since otherwise you 
		// can't exit this command by button mashing
		.withTimeout(5);
	}
} 
<br>This command can then be inserted at the start of autonomous, ensuring that your bot is always homed during a match. It also can be easily mapped to a button, allowing for mid-match recovery. If needed, it can also be broken up into a slightly more complicated command sequence.<br>For situations where you won't be running an auto (typical testing and practice field scenarios), the use of <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> can facilitate automatic checking and scheduling<br>class ExampleSubsystem extends SubsystemBase(){
	ExampleSubsystem(){
		Trigger.new(Driverstation::isEnabled)
		.and(()-&gt;isHomed==false)
		.whileTrue(goHome())
	}
}
<br>Alternatively, if you don't want to use the withInterruptBehavior(...) option, you can hijack other command calls with Commands.either(...) or new ConditionalCommand(...)<br>class ExampleSubsystem extends SubsystemBase(){
/* ... */
	//Intercept commands directly to prevent unhomed operation
	public Command goUp(){
		return either(
		stop(),
		goHome(),
		()-&gt;isHomed
	}
/* ... */
<br>While generally not preferable, a DefaultCommand and the either/ConditionalCommand notation can be used to  initiate homing. This is typically not recommended due to defaultCommands having an implicit low priority, while homing is a very high priority task.]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html</link><guid isPermaLink="false">Level 1/Homing Sequences.md</guid><pubDate>Fri, 03 Oct 2025 08:40:36 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/limit-switch-cam.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/limit-switch-cam.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SuperStructure Climber]]></title><description><![CDATA[ 
 <br><br>
<br>Configure the climber system's encoder
<br>Configure soft limits to restrict motion
<br>Write a homing routine
<br>Write triggers to indicate climber's target positions/states
<br>Write a viable control mode for the climber
<br><br>A climber represents a subsystem which is intended to raise the robot off of the ground. This is a common game task, although the requirements for "climbing" vary from year to year. <br>These can range from <br>
<br>obtain and climb a rope
<br>grab a horizontal bar and do a hold yourself up
<br>somehow get 2 feet off the ground onto a platform 
<br>In general, climbing tasks also require that you remain in the climbed position after the game ends, providing interesting mechanics and control considerations.<br><br>Torque. Climbers typically represent a significant amount of power, and if left running uncontrolled, will destroy your robot and contacting objects in slow motion while you scramble to disable it. <br>As a result, consistent <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> routines and strong enforcement of the homed state is critical to a successful climber. These systems are often difficult or impossible to move by hand, and will often not be in the correct "starting position" when the robot is enabled.<br>In some cases, the significant torque makes tuning and calibration trivial; You just give it a P value and it eventually gets to the new place, regardless of if it's lifting a bot or not.<br>
In other cases, the significant change in load on the motor means you need to change <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> and <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> gains based on whether you're actually climbing, or just moving the system while not climbing.<br>In many cases, the act of climbing will add additional physical constraints on the robot. Commonly, if you grab a bar, the bar and/or wall now form significant obstacles that restrict the actuator range. You might have other actuators that need to be in custom positions.<br><br>While somewhat uncommon, sometimes an arm is used to raise the robot. No special notes beyond the standard differences.<br><br>Systems that grab a dangling field element (a chain or rope) work similar to <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a> have no initial homing process, but do develop physical constraints once a rope is secured.<br>For these systems, you would want to make sure that you can detect the attached field element, and then enable safe upper constraints limits to prevent your bot from running out of chain, or otherwise driving through systems. <br>Note, that this can be very difficult! Winding ropes and chains may collect unevenly, and you should ensure you have appropriate considerations for various ways it can wind. If your system cannot reliably detect end-of-motion conditions, such a system may need an additional switch or contact plate to provide additional data.<br><br>Winch systems are <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a> permanently attached to a rope; Generally, these are a split subsystem with a separate, low-power mechanism that secures the rope to the field, followed by the winch doing the high-torque action. <br>Unlike other roller systems, these are more closely tied to <a data-href="#Linear Climbers" href="https://stormbots.github.io/KnowledgeBase/about:blank#Linear_Climbers" class="internal-link" target="_self" rel="noopener nofollow">Linear Climbers</a> and <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a>, as they generally require a homing process based on the unspooled length of rope, often equated to the height of the hook/grabber. <br>In many cases, the bot designers will simply make the "attachment" mechanisms spring loaded or passive, and automatically driven through unspooling the winch.<br>In other cases, Winches involve active placement mechanisms. In this setup, the two actuators need to be moved together accurately to avoid causing physical conflicts and damage. Using good <a data-href="Forward Kinematics" href="https://stormbots.github.io/KnowledgeBase/level-2/forward-kinematics.html" class="internal-link" target="_self" rel="noopener nofollow">Forward Kinematics</a> and <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> is essential to ensuring both systems move at the same rates, which will necessarily be the speed of the slower system.<br>
During the climb action, setting the placement mechanism to "coast mode" and disabling output is often advisable; This prevents surprises when forces in the robot cause unexpected motion that would cause the actuated placement system to fight eachother. <br>When working with Winch systems, having excess unspooled rope is extremely hazardous; This can bind wires, tangle other subsystems, or get re-spooled wrong, and with the significant power on winch shafts, it's easy to cause damage. It's important to make a re-spooling or re-homing option readily available for effective resets and preperation.<br><br>These systems work similarly to <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a>. <br>Generally, you will operate these with extremely low current limits during homing and "preparation" motions, and shifting to "full power" modes once the driver properly initializes the climb, or if you can detect an engaged field element. <br><br>In some cases, climbers might several different actuating parts working together due to design goals. This is likely either a generic <a data-href="Compound Subsystem" href="https://stormbots.github.io/KnowledgeBase/level-1/compound-subsystem.html" class="internal-link" target="_self" rel="noopener nofollow">Compound Subsystem</a> with different actuator types, or a <a data-tooltip-position="top" aria-label="Compound Subsystem > Handling &quot;twinned&quot; subsystems" data-href="Compound Subsystem#Handling &quot;twinned&quot; subsystems" href="https://stormbots.github.io/KnowledgeBase/level-1/compound-subsystem.html#Handling_&quot;twinned&quot;_subsystems" class="internal-link" target="_self" rel="noopener nofollow">Twinned Subsystem</a> with two mostly identical actuators operated separately but simultaneously due to design constraints.<br><br>For many climbing tasks, the robot must "be in the air" for several seconds after the match ends and the motor controllers are disabled. <br>The typical way to facilitate this is via the use of Brake mode on the climbing system; With high torque systems, this will create significant resistance, and the robot will generally stay up long enough to secure points. <br>In other cases, it may be necessary to actuate a mechanism to "lock" the bot in place. <br>In all cases, care should be taken to ensure that the robot is safely reset after climbs, prior to the next attempted motion. <br><br>Due to the need to hang, we can assert that we should always end matches in Brake mode. <br>When the robot is powered off, the motor is (effectively) in coast mode.<br>However, when the drivers need to manipulate the bot (such as in practice or queuing for a match), we generally also want it in coast mode.<br>As a result, the typical climber states for Brake/Coast is as follows:<br>
<br>Initialize on boot to coast mode (allowing human adjustment) before matches start.
<br>When initiating the climb, or a climb attempt is detected, apply Brake mode.
<br>The other considerations vary on climb: <br>
<br>If the robot can safely de-climb in coast mode, apply Coast when the robot is enabled. This facilitates resets during practices, since the bot can be enabled+disabled to allow human assistance
<br>If the robot cannot safely de-climb via coast, but can via actuation, provide this to your drivers for quick field resets.
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/superstructure-climber.html</link><guid isPermaLink="false">Level 1/SuperStructure Climber.md</guid><pubDate>Fri, 03 Oct 2025 20:09:01 GMT</pubDate></item><item><title><![CDATA[PID]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:todo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#todo</a> 
 <br>Requires<br>
<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Create a PID system on a test bench
<br>Tune necessary PIDs using encoders
<br>Set a velocity using a PID
<br>Set a angular position using a PID
<br>Set a elevator position using a PID
<br>Plot the system's position, target, and error as you command it.
<br><br>TODO:<br>
Add some graphs<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/DylanHojnoski/obsidian-graphs" target="_blank">https://github.com/DylanHojnoski/obsidian-graphs</a><br>
Write synopsis<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/revlib/spark/closed-loop" target="_blank">https://docs.revrobotics.com/revlib/spark/closed-loop</a><br><br>A PID system is a <a data-href="Closed Loop Controller" href="https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controller</a> designed to reduce system error through a simple, efficient mathematical approach.<br>You may also appreciate Chapter 1 and 2 from <a data-href="controls-engineering-in-frc.pdf" href="https://stormbots.github.io/KnowledgeBase/misc/controls-engineering-in-frc.pdf" class="internal-link" target="_self" rel="noopener nofollow">controls-engineering-in-frc.pdf</a> , which covers PIDs very well. <br><br><br><br>Often in robotics, we care a lot about the final state of a system: The position it's at, the rate it's going, the height of an elevator, etc. <br>However, the process of getting and maintaining this target state might not be trivial. It might require a variety of motor outputs to get there, change over time,  or be unpredictable due to external factors like game piece weight.<br>A closed loop controller is designed to manage exactly this. Instead of simply setting the output directly (a motor speed), we can instead provide a setpoint, representing the target state of our system. This can be a position, rate, temperature, brightness, or any other  measurable quantity. It's sometimes considered the "goal state".<br>A closed loop controller's job is to then manage the measured quantity and adjust the output to maintain that setpoint. In technical terms, we "feed back" the output as an input to this controller, forming a "closed loop" in our process diagram.<br><img alt="open-loop-closed-loop-diagram.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/open-loop-closed-loop-diagram.png"><br><br>Before getting started, we  need to identify a few things: <br>
<br>A setpoint: This is the goal state of your system. This will have units in that target state, be it height, meters, rotations/second, or whatever you're trying to do. 
<br>An output: This is often a motor actuator, and likely 
<br>A measurement: The current state of your system from a sensor; It should have the same units as your Setpoint.
<br>Controller: The technical name for the logic that is controlling the motor output. In our case, it's a PID controller, although many types of controllers exist.
<br><br>To get an an intuitive understanding about PIDs and feedback loops, it can help to start from scratch, and kind of recreating it from the basic assumptions and simple code.<br>Let's start from the core concept of "I want this system to go to a position and stay there". <br>Initially, you might simply say "OK, if we're below the target position, go up.  If we're above the target position, go down." This is a great starting point, with the following pseudo-code.<br>setpoint= 15  //your target position, in arbitrary units
sensor= 0 //Initial position
if(sensor &lt; setpoint){ output = 1 }
else if(sensor &gt; setpoint){ output = -1 }
motor.set(output)
<br>However, you might see a problem. What happens when setpoint and sensor are equal? <br>If you responded with "It rapidly switches between full forward and full reverse", you would be correct. If you also thought "This sounds like it might damage things", then you'll understand why this controller is named a "Bang-bang" controller, due to the name of the noises it tends to make.<br>Your instinct for this might be to simply not go full power. Which doesn't solve the problem, but reduces it's negative impacts. But it also creates a new problem. Now it's going to oscillate at the setpoint (but less loudly), and it's also going to take longer to get there.<br>So, let's complicate this a bit. Let's take our previous bang-bang, but split the response into two different regions: Far away, and closer. This is easier if we introduce a new term: Error. Error just represents the difference between our setpoint and our sensor, simplifying the code and procedure. "Error" helpfully is a useful term, which we'll use a lot.<br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	error = setpoint-sensor 
	if     (error &gt; 5){ output = -1 }
	else if(error &gt; 0){ output = -0.2 }
	else if(error &lt; 0){ output = 0.2 }
	else if(error &lt; -5){ output = 1 }
	motor.set(output)
})
<br>We've now slightly improved things; Now, we can expect more reasonable responses as we're close, and fast responses far away. But we still have the same problem; Those harsh transitions across each else if. Splitting up into more and more branches doesn't seem like it'll help. To resolve the problem, we'd need an infinite number of tiers, dependent on how far we are from our targets. <br>With a bit of math, we can do that! Our error term tells us how far we are, and the sign tells us what direction we need to go... so let's just scale that by some value. Since this is a constant value, and the resulting output is proportional to this term, let's call it kp: Our proportional constant. <br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	kp = 0.1
	error = setpoint-sensor 
	output = error*kp
	motor.set(output)
)}
<br>Now we have a better behaved algorithm! At a distance of 10, our output is 1. At 5, it's half. When on target, it's zero! It scales just how we want. <br>Try this on a real system, and adjust the kP until your motor reliably gets to your setpoint, where error is approximately zero. <br>In doing so, you might notice that you can still oscillate around your setpoint if your gains are too high. You'll also notice that as you get closer, your output drops to zero. This means, at some point you stop being able to get closer to your target. <br>This is easily seen on an elevator system. You know that gravity pulls the elevator down, requiring the motor to push it back up. For the sake of example, let's say an output of 0.2 holds it up. Using our previous kP of 0.1, a distance of 2 generates that output of 0.2. If the distance is 1, we only generate 0.1... which is not enough to hold it! Our system actually is only stable below where we want. What gives! <br> This general case is referred to as "standing error" ; Every loop through our PID fails to reduce the error to zero, which eventually settles on a constant value. So.... what if.... we just add that error up over time? We can then incorporate that error into our outputs. Let's do it.<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
kp = 0.1
ki = 0.001
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	output = error*kp + errorsum*ki
	motor.set(output)
}
<br>The mathematical operation involved here is called integration, which is what this term is called. That's the "I" in PID.<br>
In many practical FRC applications, this is probably as far as you need to go! P and PI controllers can do a lot of work, to suitable precision. This a a very flexible, powerful controller, and can get "pretty good" control over a lot of mechanisms. <br>This is probably a good time to read across the  <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" target="_blank">WPILib PID Controller</a>  page; This covers several useful features. Using this built-in PID, we can reduce our previous code to a nice formalized version that looks something like this.<br>PIDController pid = new PIDController(kP, kI, kD);
run(()-&gt;{
	sensor = motor.getEncoder.getPosition();
	motor.set(pid.calculate(sensor, setpoint))
})
<br>A critical detail in good PID controllers is the iZone or ErrorZone. We can easily visualize what problem this is solving by just asking "What happens if we get a game piece stuck in our system"?<br>
Well, we cannot get to our setpoint. So, our errorSum gets larger, and larger.... until our system is running full power into this obstacle. That's not great. Most of the time, something will break in this scenario. <br>So, the iZone allows you to constrain the amount of error the controller actually stores. It might be hard to visualize the specific numbers, but you can just work backward from the math. If output = errorsum*kI, then maxIDesiredTermOutput=iZone*kI. So iZone=maxIDesiredTermOutput/kI.<br>Lastly, what's the D in PID?<br>Well, it's less intuitive, but let's try. Have you seen the large spike in output when you change a setpoint? Give the output a plot, if you so desire. For now, let's just reason through a system using the previous example PI values, and a large setpoint change resulting in an error of 20. <br>Your PI controller is now outputting a value of 2.0 ; That's double full power! Your system will go full speed immediately with a sharp jolt, have a ton of momentum at the halfway point, and probably overshoot the final target. So, what we want to do is constrain the speed; We want it fast but not too fast. So, we want to reduce it according to how fast we're going.<br>
Since we're focusing on error as our main term, let's look at the rate the error changes. When the error is changing fast we want to reduce the output. The difference is simply defined as error-previousError, so a similar strategy with gains gives us output+=kP*(error-previousError) .<br>
This indeed gives us what we want: When the rate of change is high, the contribution is negative and large; Acting to reduce the total output, slowing the corrective action.<br>However, this term has another secret power, which disturbance rejection. Let's assume we're at a steady position, and the system is settled, and error=0. Now, let's bonk the system downward, giving us a sudden large, positive error. Suddenly nonzero-0 is positive, and the system generates a upward force. For this interaction, all components of the PID are working in tandem to get things back in place quickly.<br>Adding this back in, gives us the fundamental PID loop:<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
lastSensor=0
kp = 0.1
ki = 0.001
kd = 0.01
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	errordelta = sensor-lastSensor
	lastSensor=sensor
	output = error*kp + errorsum*ki + errordelta*kd
	motor.set(output)
}
<br><br>OK, that's enough nice things. Understanding PIDs requires knowing when they work well, and when they don't, and when they actually cause problems. <br>
<br>PIDs are reactive, not predictive. Note our key term is "error" ; PIDs only act when the system is already not where you want it, and must be far enough away that the generated math can create corrective action.
<br>Large setpoint changes break the math. When you change a setpoint, the P output gets really big, really fast, resulting in an output spike. When the PID is acting to correct it, the errorSum for the I term is building up, and cannot decrease until it's on the other side of the setpoint. This almost always results in overshoot, and is a pain to resolve.  
<br>Oscillation: PIDs inherently generate oscillations unless tuned perfectly. Sometimes big, sometimes small.
<br>D term instability: D terms are notoriously quirky. Large D terms and velocity spikes can result in bouncy, jostly motion towards setpoints, and can result in harsh, very rapid oscillations around the zero, particularly when systems have significant <a data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanical Backlash</a>.
<br>PIDS vs Hard stops: Most systems have one or more <a data-href="Hard Stops" href="https://stormbots.github.io/KnowledgeBase/level-1/hard-stops.html" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a>, which present a problem to the I term output. This requires some consideration on how your encoders are initialized, as well as your setpoints.
<br>Tuning is either simple....or very time consuming.
<br>Only works on "Linear" systems: Meaning, systems where the system's current state does not impact how the system responds to a given output. <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> are an example of a non-linear system, and to a given output very differently when up and horizontally. These cannot be properly controlled by just a PID. 
<br>So, how do you make the best use of PIDs?<br>
<br>Reduce the range of your setpoint changes. There's a few ways to go about it, but the easiest are <a data-href="clamping" href="https://stormbots.github.io/KnowledgeBase/misc/clamping.html" class="internal-link" target="_self" rel="noopener nofollow">clamping</a> changes, <a data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a> and <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> . With such constraints, your error is always small, so you can tune more aggressively for that range. 
<br>Utilize <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> to create the basic action; Feed-forwards create the "expected output" to your motions, reducing the resulting error significantly. This means your PID can be tuned to act sharply on disturbances and unplanned events, which is what they're designed for.
<br>In other words: This is an error correction mechanism. By reducing or controlling the initial error a PID would act on, you can greatly simplify the PID's affect on your system, usually making it easier to get better motions. Using a PID as the "primary action" for a system might work, but tends to generate unexpected challenges.<br><br>Tuning describes the process of dialing in our "gain values"; In our examples, we named these kP, kI, and kD. These values don't change the process of our PID, but it changes how it responds.<br>There's actually several "formal process" for tuning PIDs; However, in practice these often are more complicated and aggressive than we really want. You can read about them if you'd like <a data-tooltip-position="top" aria-label="https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_(Woolf)/09%3A_Proportional-Integral-Derivative_(PID)_Control/9.03%3A_PID_Tuning_via_Classical_Methods" rel="noopener nofollow" class="external-link" href="https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_(Woolf)/09%3A_Proportional-Integral-Derivative_(PID)_Control/9.03%3A_PID_Tuning_via_Classical_Methods" target="_blank">PID Tuning via Classical Methods</a><br>In practice though, the typical PID tuning process is more straightforward, but finicky.<br>
<br>Define a small range you want to work with: This will be a subset of 
<br>Create a plot of your setpoint, current state/measurements, and system output. <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a> is usually good enough here.
<br>Starting at low values, increase the P term until your system starts to oscillate near the goal  state. Reduce the P term until it doesn't. Since you can easily 
<br>Add an I term, and increase the value until your system gets to the goal state with minimal overshoot. Often I terms should start very small; Often around 1%-10% of your P term. Remember, this term is summed every loop; So it can build up very quickly when the error is large. 
<br>If you're tuning a shooter system, get it to target speed, and feed in a game piece; Increase the D term until you maintain the RPM to an effective extent. 
<br>Rev Velocity Filtering
Rev controllers by default implement a velocity filter, making it nearly impossible to detect rapid changes in system velocity. This in turn makes it nearly impossible to tune a D-term.<br>
<a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a> Document how to remove these filters
<br>Hazards of Tuning
Be aware that poorly tuned PIDs might have very unexpected, uncontrolled motions, especially when making big setpoint changes.<br>
They can jolt unexpectedly, breaking chains and gearboxes. They can overshoot, slamming into endstops and breaking frames. They'll often oscillate shaking loose cables, straps, and stressing your robot.<br>
Always err on the side of making initial gains smaller than expected, and focus on safety when tuning. 
<br>Setpoint Jumps + Disabled robots
Remember that for PID systems the setpoint determines motor output;  If the bot  is disabled, and then re-enabled, the bot will actuate to the setpoint!<br>
Make sure that your bot handles re-enabling gracefully; Often the best approach is to re-initialize the setpoint to the bot's current position, and reset the PID controller to clear the I-term's error sum.
<br><br>In seasons past, a majority of our programming time was just fiddling with PID values to get the bot behaviour how we want it. This really sucks. Instead, there's more practical routines to avoid the need for precision PID tuning. <br>
<br>Create a plot of your setpoint, current state/measurements, and system output. <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a> is usually good enough here.
<br>Add a <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> : It doesn't have to be perfect, but having a basic model of your system massively reduces the error, and significantly reduces time spent fixing PID tuning. This is essential for Arms; The FeedForward can easily handle the non-linear aspects that the PID struggles with.
<br>In cases where game pieces contribute significantly to the system load, account for it with your FeedForward: Have two different sets of FeedForward values for the loaded and unloaded states
<br>Use <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>: A Trapezoidal profile is optimal and remarkably straightforward. This prevents many edge cases on PIDs such as sharp transitions and overshoot. It provides very controlled, rapid motion. 

<br>Alternatively, reduce setpoint changes through use of a Ramp Rate or <a data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a>. This winds up being as much or more work than Motion Profiles with worse results, but can be easier to retrofit in existing code.
<br>An even easier and less effective option is simply <a data-tooltip-position="top" aria-label="clamping" data-href="clamping" href="https://stormbots.github.io/KnowledgeBase/misc/clamping.html" class="internal-link" target="_self" rel="noopener nofollow">Clamp</a> clamp the setpoint within a small range around the current state. This provides a max error, but does not eliminate the sharp transitions.


<br>Set a very small ClosedLoopRampRate; Just enough to prevent high-frequency oscillations, which will tend to occur when the setpoint is at rest, especially against <a data-href="Hard Stops" href="https://stormbots.github.io/KnowledgeBase/level-1/hard-stops.html" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a> or if <a data-tooltip-position="top" aria-label="Mechanical Backlash" data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Backlash</a> is involved. This is just a <a data-tooltip-position="top" aria-label="Slew Rate Limiting" data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiter</a> being run on the motor controller against the output.
<br>From here, the actual PID values are likely to barely matter, making tuning extremely straightforward: <br>
<br>Increase the P term until you're on target through motions and not oscillating sharply at rest
<br>Find a sensible output value that fixes static/long term disturbances (change in weight, friction, etc). Calculate the target iZone  to a sensible output just above what's needed to fix those. 
<br>Start with I term of zero; Increase the I term if your system starts lagging during some long motions, or if it sometimes struggles to reach setpoint during
<br>If your system is expected to maintain it's state through predictable disturbances (such as maintaining shooter RPM when launching a game piece), test the system against those disturbances, and increase the D term as needed. You may need to decrease the P term slightly to prevent oscillations when doing this.
<br>Watch your plots. A well tuned system should 

<br>Quickly approach the target goal state
<br>Avoid overshooting the target
<br>Settle on a stable output value
<br>Recover to the target goal state (quickly if needed)


<br><br>
<br>Discontinuity + setpoint wrappping for PIDs + absolutes
<br>
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/pid.html</link><guid isPermaLink="false">Level 1/PID.md</guid><pubDate>Tue, 30 Sep 2025 05:30:51 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/open-loop-closed-loop-diagram.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/open-loop-closed-loop-diagram.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SuperStructure Elevator]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br>
Reading Resources:<br>
<a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a><br><br>
<br>Create an Elevator subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current height
<br>Create a setHeight function that takes a height, and returns a command that runs indefinitely to the target height
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
<br><br>Elevators are a common linear motion system in FRC, generally used to raise game pieces from the floor to a high scoring objective. <br>While mechanically straightforward, Elevators wind up generating a notable step up in code and control complexity compared to <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Roller</a> systems.<br><br>Elevators introduce several areas where you can inadvertently cause damage to the environment and robot. When prototyping and developing them, there's a few important considerations:<br>
<br>Elevators have a limited range of motion: Carelessly commanding them beyond their physical constraints can damage the robot, the motors, and eject parts at nearby people!
<br>Elevators and drive belts/ropes generate many pinch points that can snag fingers if the system is moved by hand, even when disabled. 
<br>Rapid motion can de-stabilize a robot that's sitting on a cart or on blocks
<br>When making changes to elevator behaviors and tuning, make sure someone nearby is ready to disable the robot if anything goes wrong.<br><br>Controlling an elevator requires the use of a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>, and greatly benefits from aspects of both <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> and <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>.<br>A PID by itself can control an elevator, but it will be difficult to tune and require significant time and resources to "hack" into a usable state. Any time you change setpoints, the whole system is in for a bad time: The output power rapidly changes to move to the new position,  putting significant strain on the robot, causing excess wear, and potential damage. Moving a significant distance can also slam the elevator carriage into the limits of motion, causing damage.<br>FeedForwards, or at least the kS and kG terms, will greatly improve stability and accuracy, and reduce the time it takes for tuning a PID. However, it does not mitigate the issues cause changing setpoints.<br><a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> fix the setpoint problem, and lock the setpoint changes into a nicely defined ramp-up and ramp-down when changing positions. This means your PID never misbehaves, and provides additional feed-forward information to further simplify tuning. <br>While the combination may seem daunting at first, each of these 3 solves a particular motion problem effectively, and with straightforward individual adjustments. Using all 3 together provides a better performing system, with much less effort overall. <br>On occasion, you'll encounter linear systems with extremely high-torque gearing, such as screw-drive systems. These really do perform perfectly fine with just a PID controller, since the motor itself is never loaded, and a full motor output generates a slow motion with little inertia. In that case, you can simply ignore the FeedForward and Motion Profile.<br><br>The first few steps can be done before spinning the motor<br>
<br>temporarily define the <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> behavior as bootup zero. This streamlines the initial process.
<br>Calibrate the encoder on the elevator to Inches, and ensure the encoder increases as you gain height. These steps were encountered in <a data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a>
<br>Verify the correct calibration and encoder values by moving the elevator by hand when disabled.
<br>Define soft limits to prevent driving past the frame limits. The important limit is the "reverse" limit heading toward the bottom, but the top limit can be set to an approximate or low value temporarily.
<br>Estimate and configure a low P value. This will be used for controlled preliminary motion, and just needs to move the system and not oscillate at setpoints. 
<br>Estimate and configure sane maxVelocity and maxAccelleration values for the motion profile.
<br>plot motor output voltage and height, which you'll need for tuning.
<br>You will need a setPower style command that allows arbitrary input.
<br><br>With the system and code prepared, you can now work with the system a bit.<br>
<br>Determine the approximate system kG: For this, you can use the manual command to drive the motor upward away from the hard stop, then and hold it still. Record the voltage, and add it to your feed-forward.
<br>Now you can use easily use your manual adjustment command and approximate kG calculate a precise kS and kG, as indicated in <a data-href="FeedForwards#Finding kS and kG" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html#Finding_kS_and_kG" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards &gt; Finding kS and kG</a>. It helps to divide the joystick value by 4 to 10 to give you more range on the physical input side.
<br>With the FeedForward configured, almost any kP will work to get the system to setpoints, but slowly. If your system is oscillating, you can lower kP. 
<br>Optionally, you can attempt to calculate kV and kA, or use <a data-href="System Identification" href="https://stormbots.github.io/KnowledgeBase/level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a> to assist.
<br>At this point, your system should be travelling between setpoints fairly cleanly. The plot of your position during motion should be smooth, and your velocity a clean trapezoidal shape.
<br>Now that you have optimized motion, you can set the upper soft limit properly.
<br>Check your current limits! Now is a reasonable time to increase them, and you will want to plot them to see what currents are needed so you can limit them properly. 
<br><br>
<br>System oscillates or rattles around setpoint: This is likely due to a high kS value, but it may be caused by a high kP value.
<br>There's odd hitches/jolts during a motion: Your kV or kA gain is probably too high. Set kA to zero, and then lower kV until it moves smoothly. Then try to add kA back in, lowering if needed. This is possible with a high P gain, but less probable.
<br>The system drifts up/down: Your kG is too high or too low.
<br>System not getting to setpoint: If it's not going up enough, kG+kS is too small. If it's not going down enough, kG-kS is too small. Recalculate those two.
<br>Any of the above, but only when loaded/unloaded with game pieces: This can be caused due to the weight difference causing your gains to no longer properly approximate your system output. One option is to tune for the "lightest" elevator, which should result in stable motion when weight is added, and will lean on the PID to handle the error. The ideal option is to configure two or more feed-forwards, and swap the feed-forward values when each condition occurs.
<br>Any of the above, but only in some parts of the travel. This can be caused by design quirks, as some elevator configurations have physical differences at different points in travel. Similar to above, you can tune to the "lowest output" variant and let the PID handle problems, or configure several feed-forwards and select them as your elevator enters specific regions of travel.
<br><br><img alt="motion-profile-time-plots.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/motion-profile-time-plots.png"><br>
If your FF+PID tuning looks good, it's time to play with the Motion Profile. The goal is to make your max Velocity and max Accel as high as possible, representing the fastest possible motion. However, you do not want to set these higher than the system can physically manage, and it should never move so fast as to be unsafe or self-damaging. So, it's something of an iterative, incremental increase until you get the motions you want.<br>The best two plots for this are <br>
<br>Current height and setpoint height
<br>Current velocity and setpoint velocity<br>
These both represent what you're telling the system to do and what it's actually doing. 
<br>Once you have plots, you just need two buttons on a controller, moving the elevator to two different heights. You should choose heights far apart to have a relatively long travel, but stays a couple inches away from any hard stops or soft limits. The extra space at the end provides a safety net in case of an error, and allows the system to avoid crashing into them at high speeds. The long travel ensures you can reach high speeds during the motion, and test the max velocity.<br>Now, you should be able to see both the height and velocity closely track the setpoint versions. There's a few ways that they can deviate<br>
<br>The velocity setpoint graph is always a triangle, never a trapezoid: This is ok! This just means you're constrained by range and the acceleration. As you increase acceleration, you 
<br>The real velocity/position "lags" behind the setpoint. This is expected if you do not have a kV or kA on your feedforward. Adding a kV will bring them closer together and reduce this lag. A kA can also help, but is less critical.
<br>The real position/velocity "bounces": See troubleshooting above. It's likely that your P gain is too high.
<br>Instead of a trapezoidal shape, the velocity start and end have curved lines, and/or overshoots setpoint: This means your max acceleration is too high, and the motor cannot output enough power to hit the target velocity. Check your current limit, increase if needed. If you cannot provide more current, or do not wish to do so, decrease the acceleration until the system is on track.
<br>The robot emits concerning creaky/crunchy noises: Your acceleration is higher than the bot is capable of surviving. The motor can keep up, but the geartrain will explode in short order. Lower the acceleration until it goes away. Remember, F=M*A : The acceleration is what imparts the force to the elevator. 
<br><br>Until now, we've assumed an initial physical position against a hard stop. This is perfectly suitable for setup, testing, and diagnostics, but can be hazardous over the full life cycle of a robot.<br>Every time the battery is changed or the power is cycled, there's a chance that the robot wasn't where you expected, and if caught off guard you can damage the robot pretty severely, on top of failing to play the game as intended. <br>Elevators tend to require <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> more than other systems, as there's no robust, readily available sensor to capture the height directly. <br>There's several valid homing strategies, but often elevators start near the lowest point of travel, making it simple to use a <a data-tooltip-position="top" aria-label="Homing Sequences > Current Detection" data-href="Homing Sequences#Current Detection" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html#Current_Detection" class="internal-link" target="_self" rel="noopener nofollow">Current Detection</a> process. Helpfully, our feed forward analysis also tell you what the needed output power is: something just below  .<br>Homing should start automatically (or be run at start of auto), but it's also wise to give Drivers a "home" button just in case. They can't touch the robot on the field, making a home operation a necessary option for recovery from reboots or unexpected field events.<br><br>This uses the streamlined WPILib <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/profiled-pidcontroller.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/profiled-pidcontroller.html" target="_blank">ProfiledPIDController</a> providing the simplest complete implementation.<br>
There's many useful methods here : <a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/controller/ProfiledPIDController.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/controller/ProfiledPIDController.html" target="_blank">ProfiledPIDController Method Reference</a><br>UNITS  This is configured to use Volts for feedforward and PID gains, so be mindful!<br>Homing This template does not include <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a>, and assumes a "zeroed on boot" approach. It's recommended to determine and implement  a robust strategy for most bots.<br>ExampleElevator extends SubsystemBase{
	SparkMax motor = new SparkMax(42,kBrushless);

	//Define our system's maximum motion constraints
	//When in doubt, 
	//- set maxVelocity at a low value. 12 in/s is a great starter value 
	//- set kMaxAccelleration high, at roughly 4*kMaxVelocity
	private final TrapezoidProfile.Constraints constraints =
		new TrapezoidProfile.Constraints(kMaxVelocity, kMaxAcceleration);
	//Create a PID that obeys those constraints in it's motion
	//Likely, you will have kI=0 and kD=0
	private final ProfiledPIDController controller =
		new ProfiledPIDController(kP, kI, kD, constraints, 0.02);
	//Our feedforward object
	//When in doubt, set these to zero (equivilent to no feedforward)
	//Will be calculated as part of our tuning.
	private final ElevatorFeedforward feedforward = 
		new ElevatorFeedforward(kS, kG, kV);
	
	ExampleElevator(){
		//These documented below to better demonstrate the general structure
		configMotor();
		configProfiledPID();
		//DefaultCommands help avoid leaving a system in an uncontrolled
		//state. For elevators, we often want no motion
		setDefaultCommand(stop());
		//For systems using an I gain, you likely want to 
		//command the PID controller at all times rather than use stop(), 
		//which behaves better with the I term's summing behavior.
		//holdPosition() is better than stop() for this use case.
	}
	
	///Prepare Telemetry for tuning
	public void periodic(){
		var output=motor.getAppliedOutput();
		// We cannot get the applied voltage directly, but since
		// it's a percentage we can multiply by the provided battery voltage
		var voltage=motor.getAppliedOutput()*RobotController.getBatteryVoltage();
		var height=motor.getEncoder().getPosition();
		var velocity=motor.getEncoder().getVelocity();
		var setpoint=controller.getSetpoint();
		
		Smartdashboard.putNumber("elevator/voltage",voltage);
		Smartdashboard.putNumber("elevator/height",height);
		Smartdashboard.putNumber("elevator/velocity",velocity);
		Smartdashboard.putNumber("elevator/set position",setpoint.position);
		Smartdashboard.putNumber("elevator/set velocity",setpoint.velocity);
	}

	//Triggers form the optimal way to transfer subsystem states/conditions
	//to external subsystems.
	//The PID contains this method, so we can just check it
	//ProfiledPID objects's other useful indicators of completion as well,
	//such as .timeRemaining for the intended motion.
	public Trigger isAtPosition = new Trigger(controller::atGoal);
	
	/// Return the height of our elevator, using Unit measures
	public Distance getHeight(){
		return Inches.of(motor.getEncoder().getPosition)
	}
	
	/// Provide manual output. Should only be used for
	/// debugging, tuning, and homing
	public Command setPower(DoubleSupplier percentOutput){
		//Including the feed-forward here, but can be removed
		//if your testing is easier without it.
		return run(()-&gt;motor.setVoltage(
			percentOutput.getAsDouble()*RobotController.getBatteryVoltage()
			+ ff.getKg()
			)
		); 
	}
	
	/// Disable the elevator's motion entirely
	public Command stop(){
		//Note, an output of 0 usually falls down, which is *not* the 
		//same as stopping! So, we instead use kg to resist gravity.
		//A "stopped" subsystem can still be moved by hand or 
		//external forces though!
		return setPower(feedforward::getKg)
	}
	
	/// Actively maintain the position command was started at
	public Command holdPosition(){
		var currentHeight=getHeight();
		return setHeight(()-&gt;currentHeight);
	}

	///Command the Elevator to go to the target position
	public Command setHeight(Supplier&lt;Distance&gt; position){
		return startRun(
		()-&gt;{
			//Set our initial goal prior to starting the command
			// Optional? Used previously to prevent trigger glitches
			controller.setGoal(position.get().in(Inches));
		},
		()-&gt;{
			//Update our goal with any new targets
			controller.setGoal(position.get().in(Inches));
			//Calculate the voltage
			voltage=
			motor.setVoltage(
				controller.calculate(motor.getEncoder().getPosition()) 
				+ feedforward.calculate(controller.getSetpoint().velocity)
			);
		});
	}
}
<br>// Important configuration parameters for an Elevator subsystem
void configMotor(){
	//These are the important ones for Elevators specifically
	SparkBaseConfig config = new SparkMaxConfig();
	//Default current limit should be low until the system is homed.
	//.. but this requires a homing process.
	config.smartCurrentLimit(40);
	//You want "forward" to be positive, with increasing encoder values
	config.inverted(false); 
	//Soft 
	config.softLimit
	.forwardSoftLimit(18) //Whatever max height is
	.forwardSoftLimitEnabled(true)
	.reverseSoftLimit(0) //Sometimes zero, or the lost attainable height
	.reverseSoftLimitEnabled(true);
	;
	//The conversion/gearing needed to put your system in a sensible
	// unit; Often Inches.
	var elevatorConversionfactor = 1;
	elevatorConfig.encoder
	.positionConversionFactor(elevatorConversionfactor)
	.velocityConversionFactor(elevatorConversionfactor / 60.0)
	;
	//Apply the configs
	elevatorMotor.configure(
		config,
		ResetMode.kResetSafeParameters,
		PersistMode.kPersistParameters
	);
}

void configProfiledPID(){
	//Configure the ProfiledPIDController
	
	//This value constraints the output added by the I term 
	//in the PID controller. This is very helpful to prevent damage in cases
	//where the elevator system jams or collides with the environment and 
	//cannot move.
	// This will be system dependent, and should (needs testing) be 
	// in PID ouptut units (normally Volts)
	controller.setIntegratorRange(-1, 1); //Configure to +/-1 volt
	
	//When the robot is disabled, the elevator might move, invalidating
	// the controller's internal state, and invalidating the I term's sum.
	//This needs to be reset whenever the robot is enabled, and a Trigger
	// provides a clean way of handling this
	new Trigger(DriverStation::isEnabled).onTrue(
		()-&gt;controller.reset(motor.getEncoder.getPosition())
	);
	
	//There's other methods for interacting with the PID values 
	// and constraints, should the need arise
}
<br>Advanced usage can easily extend this to handle position dependent constraints, or provide alternate constraints for certain motions. <br><br>New API incoming
Rev is developing a new Spark API that can run Feedforwards + Motion profiles entirely on the Spark Motor controller.<br>
TrapezoidalProfiles + external PID is messy, and thus documented to a minimal extent below
<br>Implementing mixed Spark PID + Trapezoidal  is not strongly recommended, due to the high levels of code jank and surprise complexity, combined with limited benefit in this context. However, a full example can be found in <a data-tooltip-position="top" aria-label="https://github.com/stormbots/Reefscape/tree/main/src/main/java/frc/robot/subsystems/Elevator#L264" rel="noopener nofollow" class="external-link" href="https://github.com/stormbots/Reefscape/tree/main/src/main/java/frc/robot/subsystems/Elevator#L264" target="_blank">2025 Stormbots Reefscape</a>  <br>The primary difference from above<br>
<br>The need to create a Trapazoidal Profile object directly, rather than a ProfiledPID
<br>You need to set the PID in the trapezoidal Profile to determine the expected state 
<br>Need to query the calculated state and pass the value to the external PID.
<br>Need to track the "Goal state" for completion testing
<br>Note that a "Goal State" represents the final objective for the trap profile, which is used to calculate setpoints, serving as intermediate targets for motion.<br>
private TrapezpoidProfile.Constraints constraints = 
new TrapezpoidProfile.Constraints(
	kElevatorMaxVelocity,
	kElevatorMaxAcceleration
);
private final TrapezoidProfile elevatorTrapezoidProfile = 
	new TrapezoidProfile(constraints);
	
//Needed to store the Final state of the motion so triggers can 
//calculate finished motion
TrapezoidProfile.State elevatorGoal=new TrapezoidProfile.State(0,0);
//We also need to retain the intermediate steps; When these match, 
//our planned motion has been completed.
TrapezoidProfile.State elevatorSetpoint=new TrapezoidProfile.State(0,0);

private Command setHeight(DoubleSupplier position){
	return new SequentialCommandGroup(
		//Seed the initial state/setpoint with the current state
		//Maybe optional?
		new InstantCommand( ()-&gt;{
			elevatorSetpoint = new TrapezoidProfile.State(
				getAngle().in(Degrees),
				elevatorMotor.getEncoder().getVelocity()
			);
		}),
		  
		new RunCommand(()-&gt;{
			//Make sure the goal is dynamically updated
			elevatorGoal = new TrapezoidProfile.State(
				position.getAsDouble(),
				0
			);
			//update our existing setpoint to the next achievable state
			elevatorSetpoint = elevatorTrapezoidProfile
				.calculate(0.02, elevatorSetpoint, elevatorGoal);
			//Query our feedforward for projected output
			var ff = elevatorFF.calculate(
				elevatorSetpoint.position,
				elevatorSetpoint.velocity
			);
			//Pass all our info out to the motor for output and PID control
			elevatorMotor.getClosedLoopController()
			.setReference(
				elevatorSetpoint.position,
				ControlType.kPosition, ClosedLoopSlot.kSlot0,
				ff, ArbFFUnits.kVoltage
			);
		})
	);
	}

}
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html</link><guid isPermaLink="false">Level 1/SuperStructure Elevator.md</guid><pubDate>Tue, 30 Sep 2025 05:26:59 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/motion-profile-time-plots.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/motion-profile-time-plots.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SuperStructure Intake]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:todo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#todo</a> 
 <br>Requires:<br>
<a data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br>Recommends:<br>
<a data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a><br>Requires as needed:<br>
<a data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
<a data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br><br>
<br>Create an "over the bumper" intake system
<br>Add a controller button to engage the intake process. It must retract when released
<br>The button must automatically stop and retract the intake when a game piece is retracted
<br><br>Intake complexity can range from very simple rollers that capture a game piece, to complex actuated systems intertwined with other scoring mechanisms. <br>A common "over the bumper" intake archetype is a deployed system that<br>
<br>Actuates outward past the frame perimeter
<br>Engages rollers to intake game piece
<br>Retracts with the game piece upon completion of a game piece
<br>The speed of deployment and retraction both impact cycle times, forming a critical competitive aspect of the bot. <br>The automatic detection and retraction provide cycle advantages (streamlining the driver experience), but also prevent fouls and damage due to the collisions on the deployed mechanism.<br>Intakes often are a <a data-tooltip-position="top" aria-label="Compound Subsystem" data-href="Compound Subsystem" href="https://stormbots.github.io/KnowledgeBase/level-1/compound-subsystem.html" class="internal-link" target="_self" rel="noopener nofollow">Compound Subsystem</a> , and come with several quirks for structuring and control<br><br>The major practical difference between intakes and other "subsystems" is their routine interaction with unknowns. Intake arms might extend into walls, intake rollers might get pressed into a loading station, and everything is approaching game pieces in a variety of speeds and states. Every FRC intake is different, but this one aspect is consistent.<br>Good mechanical design goes a long way to handling unknowns, but programming is affected too.  Programming a robust intake demands identifying and resolving ways that these interactions can go wrong, and resolving them in a way that leaves the robot in an operational state (and preferably, with a game piece). Sometimes this is resolved in code, and sometimes requires hardware or design tweaks. Intakes tend to have more physical iterations than many other parts of the robot.<br><br>For most intakes, you want a clear confirmation that the intake process is Done and a game piece is loaded. This typically means reviewing the mechanical design, and identifying what, if any, sensing methods will work reliably to identify successful intake.<br>Common approaches are<br>
<br>Break beams / Range finders like <a data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">LaserCan</a> : Since these sensors are non-contact, they provide a easy to use, and relatively safe way to interact with game pieces with little design overhead. 
<br>A backplate with a switch/button: This requires special mechanical design, but gives a simple boolean state to indicate successful loading. This typically only works with intakes that interact with a back-stop, but can be made to work with other mechanisms that can actuate a switch when objects are in a known position
<br>Current Detection: This is a common option for intakes that pull in directly into a backstop, particularly for rigid game pieces. Like other places where current detection is used, it's either trivial + very effective, or ineffective + extremely challenging, depending on the design and interactions. 
<br>Speed/Stall Detection: Like above but measuring roller speed rather than motor current. 
<br>A good understanding of <a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a> , and familiarity with our other sensors available will go a long way to making a robust intake.<br><br>When intaking objects, many things can go wrong with. Here's a quick list of considerations:<br>
<br>A game piece can be oriented wrong, jamming the intake.
<br>A game piece can be loaded from weird angles or during unexpected motions, jamming the intake
<br>A game piece can be loaded at the edge of the intake, binding against mechanical supports
<br>A game piece load can be interrupted by drivers, leaving the intake in a "default command" state  while half-loaded
<br>A game piece can be damaged, loading in incorrectly or binding
<br>A game piece can be stretched/deformed inside the bot or intake
<br>A game piece can be smaller/larger than originally expected, causing various effects
<br>The game piece can be damaged due to excess force when stalled/jammed
<br>The game piece can be damaged due to initial contact with rollers at a high speed
<br>The intake can be extended past frame perimeter, and then slam into a wall
<br>The intake can be extend past the frame perimeter into a wall. 
<br>The rollers can jam against an intake pressed against a wall
<br>The rollers+game piece can force other systems into unexpected angles due to wall/floor/loading station interactions
<br>Intakes can fling past the robot perimeter during collisions, colliding with other robots (collecting fouls or snagging wires)
<br>Murphy's law applies! If anything can go wrong, it will. When testing, you might be tempted to assume errors are a one-off, but instead record them and try to replicate errors as part of your testing routine. It's easier to fix at home than it is in the middle of a competition. <br>When coding, pay close attention to <br>
<br>Expected mechanism currents: Make sure that your intake is operating with reasonable current limits, and set high enough to work quickly, but low enough to prevent harm when something goes wrong.
<br>Intake Default Commands: Ideally, the code for your intake should ensure the system ends up in a stable, safe resting location.
<br>The expected and actual positions: In some cases, if there's a large mismatch between expected positions and the current one, you might infer there's a wall/object in the way and halt loading, or apply a different routine.
<br>Command conditions: Make sure that your start/stop conditions work reliably under a variety of conditions, and not just the "values when testing". You might need to increase them or add additional states in which sensor values are handled differently or ignored.
<br><br>A good intake doesn't need to perfectly load a game piece in every scenario, but it does need to have a way to recover so you can resume the match. Let's look at a couple approaches<br><br>The optimal result, of course, is successfully resolving the fault and loading the game piece. Several fault conditions can be resolved through a more complex routine. A couple common ones are <br>
<br>Stop + restart the intake (with motor coast mode). This works surprisingly well, as it lets the game piece settle, slip away from obstructions, and then another intake attempt might successfully complete the load operation.
<br>Reverse + restart the intake. A more complex (and finicky) option, but with the same effect. This an help alleviate many types of jamming, stretching, squishing, and errant game piece modes, as well as re-seat intake wheels.
<br>Re-orient + restart: This can come up if there's mechanical quirks, such as known collision or positional errors that can result in binding (like snagging on a bumper). Moving your system a bit might fix this, allowing a successful intake
<br>A good load routine might need support from your mechanical teams to fix some edge cases. Get them involved!<br><br>If we can't fix it, let's not break it: This is a fault mitigation tactic, intended to preserve game piece and robot safety, and allow the robot to continue a match.<br>The most important part of this is to facilitate the drivers: They need an Eject button, that when held tries to clear a game piece from the system, putting it outside the frame perimeter. A good eject button might be a simple "roller goes backwards", but also might have more complex logic (positioning a system a specific way first) or even controlling other subsystems (such as feeders, indexers, or shooters). <br>Historically, a good Eject button solves a huge amount of problems, with drivers quickly identifying various error cases, and resolving with a quick tap. Often drivers can tap eject to implement "load it anyway" solution, helping prove it on the field before it's programmed as a real solution.<br><br>The big oof 💀. When this happens, your robot is basically out of commission on the field, or your drivers are  slamming it against a wall to knock things loose.<br>In this case, you should be aiming to identify, replicate, and resolve the root cause. It's very likely that this requires mechanical teams to assist. <br>If the jam is not able to be mechanically prevented, then Programming's job is to resolve the intake process to make it impossible, or at least convert it to a temporary stall. <br><br>Within the vast possibility space of the intake you'll handle, there's a few good practices<br>
<br>Test early, test often, capture a lot of errors.
<br>Revise the hardware, then revise the software: Fix the software only as needed to keep things working. Don't spend the time keeping junked intake designs limping along, unless needed for further testing.
<br>Closed loop: Several fault conditions can be avoided by using a velocity PID and feed-forwards to generate a slower, more consistent initial interaction with game pieces, and automatically apply more power in fault condition.
<br>Operate at the edge cases: Do not baby the intake, and do your best to generate repeatable fault conditions to inform the design. 
<br>Operate in motion: Feeding the intake on a stationary chassis tends to feed differently than a mobile chassis and stationary game piece, or a mobile chassis + Mobile Game Piece. 
<br><br><br>Generally,  intakes are not one "system", but often actuated to deploy it beyond the frame perimeter, or line it up with intake positions. These are often done using <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> or <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a>. In some cases, it's a deployable linkage using motors or <a data-tooltip-position="top" aria-label="Level 1/Pnuematics" data-href="Level 1/Pnuematics" href="https://stormbots.github.io/KnowledgeBase/Level 1/Pnuematics" class="internal-link" target="_self" rel="noopener nofollow">Pnuematic Solenoids</a> .<br>Intakes often also interact with gamepiece management systems, usually an <a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexer/Passthrough</a> that helps move the game piece through a scoring mechanism. In some systems, the intake is the scoring mechanism.<br><br>Regardless of the system setup, good <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> design remains, and the "Intake" name tends to be given to the end effector (usually <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a>) contacting the game piece, with intake actuators being named appropriately (like IntakeArm or IntakeElevator)<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html</link><guid isPermaLink="false">Level 1/SuperStructure Intake.md</guid><pubDate>Wed, 01 Oct 2025 20:21:39 GMT</pubDate></item><item><title><![CDATA[Motion Profiles]]></title><description><![CDATA[ 
 <br><br>
<br>Configure a motion system with PID and FeedForward
<br>Add a trapezoidal motion profile command (runs indefinitely)
<br>Create a decorated version with exit conditions
<br>Create a small auto sequence to cycle multiple points
<br>Create a set of buttons for different setpoints
<br><img alt="motion-profile-time-plots.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/motion-profile-time-plots.png">]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html</link><guid isPermaLink="false">Level 2/Motion Profiles.md</guid><pubDate>Sun, 28 Sep 2025 05:50:34 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/motion-profile-time-plots.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/motion-profile-time-plots.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PhotonVision Basics]]></title><description><![CDATA[ 
 <br><br>Interact with the PhotoVision UI and basic code structures<br><br>
<br>Connect to the WebUI
<br>Set up a camera
<br>Set up AprilTag Target
<br>Read target position via NT
<br><br>This allows you to access PhotonVision via the roborio USB port.<br>
This can be useful when debugging at competitions<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.photonvision.org/en/latest/docs/quick-start/networking.html" target="_blank">https://docs.photonvision.org/en/latest/docs/quick-start/networking.html</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/photonvision-basics.html</link><guid isPermaLink="false">Level 2/PhotonVision Basics.md</guid><pubDate>Tue, 30 Sep 2025 05:29:42 GMT</pubDate></item><item><title><![CDATA[PhotonVision Bringup]]></title><description><![CDATA[ 
 <br><br>
<br>Configure the PV networking
<br>Configure the PV hardware
<br>Set up a camera
<br>Create a Vision code class
<br>Configure PV class to communicate with the hardware
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/photonvision-bringup.html</link><guid isPermaLink="false">Level 2/PhotonVision Bringup.md</guid><pubDate>Tue, 30 Sep 2025 05:30:06 GMT</pubDate></item><item><title><![CDATA[PhotonVision Model Training]]></title><description><![CDATA[ 
 <br><br>
<br>Oh no
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/photonvision-model-training.html</link><guid isPermaLink="false">Level 2/PhotonVision Model Training.md</guid><pubDate>Tue, 30 Sep 2025 05:30:33 GMT</pubDate></item><item><title><![CDATA[PhotonVision Object Detection]]></title><description><![CDATA[ 
 <br><br>
<br>Add a Object detection pipeline
<br>Detect a game piece using color detection
<br>if available, detect it using a ML object model 
<br><br><a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/open-source-real-time-game-piece-position-estimation-for-frc-robots/506640" target="_blank">https://www.chiefdelphi.com/t/open-source-real-time-game-piece-position-estimation-for-frc-robots/506640</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/photonvision-object-detection.html</link><guid isPermaLink="false">Level 2/PhotonVision Object Detection.md</guid><pubDate>Tue, 30 Sep 2025 05:30:22 GMT</pubDate></item><item><title><![CDATA[PhotonVision Odometry]]></title><description><![CDATA[ 
 <br><br>
<br>Set up a pipeline to identify april tags
<br>Configure camera position relative to robot center
<br>Set up a
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/photonvision-odometry.html</link><guid isPermaLink="false">Level 2/PhotonVision Odometry.md</guid><pubDate>Tue, 30 Sep 2025 05:29:59 GMT</pubDate></item><item><title><![CDATA[QuestNav]]></title><description><![CDATA[ 
 ]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/questnav.html</link><guid isPermaLink="false">Level 2/QuestNav.md</guid><pubDate>Tue, 30 Sep 2025 05:27:28 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 <br><br>README<br><br><br>This is the Skyview Robotics training wiki and educational resources<br>You can find a web version of this documentation at<br>
<a rel="noopener nofollow" class="external-link" href="https://stormbots.github.io/KnowledgeBase" target="_blank">https://stormbots.github.io/KnowledgeBase</a><br><br>Robotics does not have a linear path to success; There's a lot of variety in what you'll need to do, and a bigger variety in what you want to do. So, instead of a standard curriculum, our resources are broken down as skill trees that build up and out from smaller, foundational sections.<br><br>Brand new programmers will likely need to start with the very fundamentals of coding:<br>
<a data-tooltip-position="top" aria-label="Coding Basics.canvas" data-href="Coding Basics.canvas" href="https://stormbots.github.io/KnowledgeBase/level-0/coding-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Basics</a><br>Once you're ready to move some hardware, the <a data-tooltip-position="top" aria-label="StormBreakers Tree.canvas" data-href="StormBreakers Tree.canvas" href="https://stormbots.github.io/KnowledgeBase/stormbreakers-tree.html" class="internal-link" target="_self" rel="noopener nofollow">StormBreakers Tree</a> is intended to guide new students to meet the challenges of a fully working, competitive Kitbot. <br><img alt="StormBreakers Tree" src="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1" referrerpolicy="no-referrer"><br><br>Lastly, our <a data-tooltip-position="top" aria-label="Stormbots Tree.canvas" data-href="Stormbots Tree.canvas" href="https://stormbots.github.io/KnowledgeBase/stormbots-tree.html" class="internal-link" target="_self" rel="noopener nofollow">Stormbots Tree</a>  builds on experience, and emphasizes deeper dives into advancing specific skills, and blending varied skill sets together. This tree is intended to guide students through more complex designs and higher performance targets. It also builds and relies upon the <a data-tooltip-position="top" aria-label="StormBreakers Tree.canvas" data-href="StormBreakers Tree.canvas" href="https://stormbots.github.io/KnowledgeBase/stormbreakers-tree.html" class="internal-link" target="_self" rel="noopener nofollow">StormBreakers Tree</a>, which will remain a valuable resource.<br><img alt="Stormbots Tree" src="https://github.com/user-attachments/assets/0a43acb5-d197-4e00-8eb5-28ca4c408e23" referrerpolicy="no-referrer"><br>
While any particular page will likely prove somewhat useful on it's own, everything will be written with the assumption you're caught up according to these trees. <br><br>This notebook is an <a data-tooltip-position="top" aria-label="https://obsidian.md" rel="noopener nofollow" class="external-link" href="https://obsidian.md" target="_blank">Obsidian.md</a> notebook, and some features of it may not fully work outside of Obsidian.]]></description><link>https://stormbots.github.io/KnowledgeBase/index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Wed, 01 Oct 2025 01:13:50 GMT</pubDate><enclosure url="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Skyview Robotics Knowledgebase]]></title><description><![CDATA[ 
 <br><br>This is the Skyview Robotics training wiki and educational resources<br>You can find a web version of this documentation at<br>
<a rel="noopener nofollow" class="external-link" href="https://stormbots.github.io/KnowledgeBase" target="_blank">https://stormbots.github.io/KnowledgeBase</a><br><br>Robotics does not have a linear path to success; There's a lot of variety in what you'll need to do, and a bigger variety in what you want to do. So, instead of a standard curriculum, our resources are broken down as skill trees that build up and out from smaller, foundational sections.<br><br>Brand new programmers will likely need to start with the very fundamentals of coding:<br>
<a data-tooltip-position="top" aria-label="Coding Basics.canvas" data-href="Coding Basics.canvas" href="https://stormbots.github.io/KnowledgeBase/level-0/coding-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Basics</a><br>Once you're ready to move some hardware, the <a data-tooltip-position="top" aria-label="StormBreakers Tree.canvas" data-href="StormBreakers Tree.canvas" href="https://stormbots.github.io/KnowledgeBase/stormbreakers-tree.html" class="internal-link" target="_self" rel="noopener nofollow">StormBreakers Tree</a> is intended to guide new students to meet the challenges of a fully working, competitive Kitbot. <br><img alt="StormBreakers Tree" src="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1" referrerpolicy="no-referrer"><br><br>Lastly, our <a data-tooltip-position="top" aria-label="Stormbots Tree.canvas" data-href="Stormbots Tree.canvas" href="https://stormbots.github.io/KnowledgeBase/stormbots-tree.html" class="internal-link" target="_self" rel="noopener nofollow">Stormbots Tree</a>  builds on experience, and emphasizes deeper dives into advancing specific skills, and blending varied skill sets together. This tree is intended to guide students through more complex designs and higher performance targets. It also builds and relies upon the <a data-tooltip-position="top" aria-label="StormBreakers Tree.canvas" data-href="StormBreakers Tree.canvas" href="https://stormbots.github.io/KnowledgeBase/stormbreakers-tree.html" class="internal-link" target="_self" rel="noopener nofollow">StormBreakers Tree</a>, which will remain a valuable resource.<br><img alt="Stormbots Tree" src="https://github.com/user-attachments/assets/0a43acb5-d197-4e00-8eb5-28ca4c408e23" referrerpolicy="no-referrer"><br>
While any particular page will likely prove somewhat useful on it's own, everything will be written with the assumption you're caught up according to these trees. <br><br>This notebook is an <a data-tooltip-position="top" aria-label="https://obsidian.md" rel="noopener nofollow" class="external-link" href="https://obsidian.md" target="_blank">Obsidian.md</a> notebook, and some features of it may not fully work outside of Obsidian.]]></description><link>https://stormbots.github.io/KnowledgeBase/readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Wed, 01 Oct 2025 01:14:05 GMT</pubDate><enclosure url="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://github.com/user-attachments/assets/bf5f9b03-5e07-4e0c-8e29-bf16f6d1a7c1"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Stormbots Tree]]></title><description><![CDATA[ 
 SuperStructure FocusSpecialized DependenciesSwerve FocusVision FocusSimulation, Logging, Visualization<br><br>
<br>Set up a mock project  with a nominal, standard code structure
<br>Project should have a subsystem that<br>
<br>Is in a subsystem folder
<br>Has 3 components in a (logic, <a data-href="Physics Simulation" href="https://stormbots.github.io/KnowledgeBase/level-2/physics-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">Physics Simulation</a>, <a data-href="Mechanism2d" href="https://stormbots.github.io/KnowledgeBase/level-2/mechanism2d.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanism2d</a>)
<br>Has a factory method to get a control command (can be mocked up)
<br>Has a trigger that indicates a mechanism state (can be mocked up based on timers)<br>
Has an additional sensor subsystem system that
<br>Provides a trigger for a condition (can be mocked up)<br>
Has a controller and<br>
Has an Autos class to hold autos
<br>With an auto chooser initialization 
<br>A single basic auto using subsystem and sensor
Code Structuring<br><br>
<br>Create a Singleton class
<br>Use it in multiple places in your code
<br><br>Singletons are a coding structure (or "pattern") that represents a unique entity. It's designed to allow one, and only one instance of a class.<br>This tends to be useful for controlling access to unique items like physical hardware, IO channels, and other such items. <br>The techniques used in this pattern are also helpful for cases where you might be fine with multiple instances, but you need to restrict the total number, or keep track in some way.<br><br>public ExampleSingleton{
    private static ExampleSingleton instance;

	//note private constructor
    private ExampleSingleton(){}
    
    public static ExampleSingleton getInstance(){
        //Check to see if we have an instance; If not, create it. 
        if(instance==null) instance = new ExampleSingleton();
        //If so, return it. 
        return instance;
    }
    
	// Methods just work normally.
	public double exampleMethod(){
        return 0; 
    }
}
<br>There's a few key details here: <br>
<br>private ExampleSingleton(){} The constructor is private, meaning you cannot create objects using new ExampleSingleton(). If you could do that, then you would create a second instance of the class! So, this is private, meaning only an instance of the class itself can create an instance.
<br>public static ExampleSingleton getInstance() ; This does the heavy lifting: It sees if we have an instance, and if not, it actually creates one. If we have an instance, it just returns a reference to it. This is how we ensure we only ever create one instance of the class. This is static, which allows us to call it on the base class (since we won't have an instance until we do).
<br>private static ExampleSingleton instance; This is the reference for the created instance. Notice that it's static, meaning that the instance is "owned" by the base class itself. 
<br><br>public ExampleSensorSystem{
    private static ExampleSensorSystem instance;
    
    //Example object representing a physical object, belonging to
    //an instance of this class.
    //If we create more than one, our code will crash!
    //Fortunately, singletons prevent this. 
    private Ultrasonic sensor = new Ultrasonic(0,1);

    private ExampleSensorSystem(){} //note private constructor
    
    public static ExampleSensorSystem getInstance(){
        //Check to see if we have an instance; If not, create it. 
        if(instance==null) instance = new ExampleSensorSystem();
        //If so, return it. 
        return instance;
    }
    
    public double getDistance(){
        return sensor.getRangeInches();
    }
}
<br>Elsewhere, these are all valid ways to interface with this sensor, and get the data we need<br>ExampleSensorSystem.getInstance().getDistance();


var sensor = ExampleSensorSystem.getInstance();
// do other things
sensor.getDistance();
<br><br>Rarely is often the right answer. While Singletons are useful in streamlining code in some circumstances, they also can obscure where you use it, and how you're using it. Here's the general considerations<br>
<br>You have something that is necessarily "unique"
<br>It will be accessed by several other classes, or have complicated scope.
<br>it is immutable: Once created, it won't be changed, altered or re-configured.
<br>You will not have any code re-use
<br>In cases where it's less obvious, the "dependency injection" pattern makes more sense. You'll see the Dependency pattern used in a lot of FRC code for subsystems. Even though these are unique, they're highly mutable, and we want to track access due to the Requires and lockouts. <br>Similarly, for sensors we probably one multiple of the same type. This means if we use a Singleton, we would have to re-write the code several times! (or get creative with class abstractions). <br>Dependency Injection
This pattern consists of passing a reference to items in a direct, explicit way, like so. 
//We create an item
ExampleSubsystem example = new ExampleSubsystem();

ExampleCommand example = new ExampleCommand(exampleSubsystem);

class ExampleCommand(){
	ExampleSubsystem example;
	ExampleCommand(ExampleSubsystem example){
			this.example = example;
	}
	public void exampleMethod(){
		//has access to example subsystem
	}	
}

Singletons<br>A Future is a simplified, and much more user friendly application of threading<br><br>
<br>???
<br><br>A "thread" normally refers to a single chain of code being executed. Most code is "single threaded", meaning everything happens in order; For something to be done, it has to wait its turn.<br>With proper code setup, you can make it appear that code is doing multiple things at once. There's a few terms for this, but usually "concurrency" or "time sharing" come up here. However, you're still fundamentally waiting for other code to finish, and a slow part of code holds up everything. This might be a complex computation, or a slow IO transfer across a network or data bus.<br>
Tasks like these don't take computational time, but do take real world time in which we could be doing other things. <br>Threads, on the other hand, can utilize additional processor cores to run code completely isolated and independently. Which is where the trouble starts.<br><br>Threads come with a bit of inherent risk: Because things are happening asynchronously (as in, not in sync with each other), you can develop issues if things are not done when  you expect them to be <br>//Set up two variables
var x;
var y;
//These two tasks are slow, so make a thrad for it!
Thread.spawn(()-&gt; x=/*long computation for X*/)
Thread.spawn(()-&gt; y=/*long computation for y*/)
//Sum things up!
var z = x+y
<br>This will completely crash; It's unlikely that both threads A and B will have finished by the time the main thread tries to use their values. This example is obvious, but in practice, this can be very sneaky and difficult to pin down. <br>Keep in mind anything running a co-processor is inherently a separate thread! These are usually wrapped by helpful containers to streamline interactions, but there's times where this distinction is important.<br><br>In 2024, we had code managing Limelight data, which would <br>
<br>Check tv, the target valid data: This value means everything else is valid
<br>Get tx and ty, along with getBotPose
<br>Try to computer our pose
<br>.... and data is wrong?
<br>What happened was simply that in some cases, after checking tv to assert valid data, the data changed, causing our calculations to break. The remote system (effectively a different thread) changed the data underneath us.<br>In some cases, we'd get values that should be valid, but instead they resulted in crashes. <br><br>There's lots of strategies to manage threads, most with notable downsides. <br>
<br>Avoiding threads: The easiest strategy, but you don't improve performance
<br>Mutexes: Short for "mutually exclusive", and represents a lock. When using data shared with threads, you lock it, and unlock it when you're done. Notably, this means you spend a good amount of effort and time trying to deal with these locks, and make sure they're where they should be. 
<br>Splits and joins: If a thread ends, you don't have problems! So, you can just check a thread state and see if it's done with your value. Don't forget to restart it if needed.
<br>Message passing: Simply don't share data. Instead, just throw it in a queue, and let stuff handle it when it needs to. 
<br>There's other strategies as well, but this brings us to...<br><br>A Future combines several of those into one, very user friendly package. Conceptually, it represents a "future value" that has not yet been calculated, while actually containing the code to get that value.<br>Because it's oriented with this expectation, they're easy to think about and use. They're almost as straightforward as any other variable.<br>//create a future and pass it some work.
CompletableFuture&lt;double&gt; future = new CompletableFuture.supplyAsync( ()-&gt; {Timer.delay(5); /*some long running calculaton*/ return 4;} );
System.out.println("waiting....");
System.out.println( future.get() )
<br>That's it. For the simplicity involved, it doesn't feel like you're using threads.... but you are. Notice that waiting prints out instantly; about 5 seconds before the number, in fact.<br>Futures handle most of the "busywork" for you; Managing thread operation, checking to see if it's done, and what the return value is. The thread runs in the background, but if it's not done by the time you get to future.get(), it'll automatically stop the main thread, wait until the future thread is done, get the value, and then resume the main thread. This will demonstrate it clearly. However, if the future is done, you just race on ahead. <br>//create a future and pass it some work.
CompletableFuture&lt;double&gt; future = new CompletableFuture.supplyAsync( ()-&gt; {Timer.delay(5); /*some long running calculaton*/ return 4;} );
System.out.println("waiting....");
Timer.delay(6); // do some busywork on the main thread too
System.out.println("Done with main thread!");
System.out.println( future.get() ); //will print instantly; The thread finished during main thread's work!
<br><br>Threads would be really nice in a few places, but in particular, building autos. Autos take a very long time to build, and you have a lot of them. And you don't want them wasting time if you're not actually running an auto. <br>But remember that Futures represent a "future value", and "contain the code to build it". A Command is a future value, and has a process to build it.... so it's a perfect fit. But you also have to select one of several autos. This is easily done: <br>CompletableFuture&lt;Command&gt; selectedAutoFuture = CompletableFuture.supplyAsync(this::doNothing);
SendableChooser&lt;Supplier&lt;Command&gt;&gt; autoChooser = new SendableChooser&lt;&gt;();
<br>A full example is in <a data-href="/Programmer Guidance/auto-selection" href="https://stormbots.github.io/KnowledgeBase/Programmer Guidance/auto-selection" class="internal-link" target="_self" rel="noopener nofollow">/Programmer Guidance/auto-selection</a>, but the gist is that <br>
<br>A Future takes a Supplier&lt;Command&gt;: A function that returns a command
<br>The AutoChooser then has a list of functions that build and return an auto command. 
<br>When you change the chooser, you start a new future, and start building it. 
<br>If and when the auto process should start.... the code just waits for the process to finish as needed, and runs it. 
<br>Conveniently, you don't need to return values. You can, if needed, run the void version, using a Runnable or non-returning lambda.<br>CompletableFuture&lt;?&gt; voidedFuture = CompletableFuture.supplyAsync(()-&gt;{}); 
if(voidedFuture.isDone()) /* do a thing */ ;
<br>While not exactly the intended use case, this allows you to easily run and monitor background code without worry. <br><br>Be aware, that as with all threads you generally should not <br>
<br>Write to data accessible by other threads; You don't know when something is trying to read that value. Do writes in the main thread. 
<br>Read data being written to by other threads; This should be easy to reason about. Constants and fixed values are fine, but don't trust state variables.
<br>Additionally, Futures are most effective when your code starts a computation, and then reacts to the completion of that computation afterward. They're intended for run-once use cases. <br>For long-running background threads, you'd want to use something else better suited to it. <br><br>Psuedo-threads are "thread-like" code structures that look and feel like threads, but aren't really. <br>WPILib offers a convenient way to run psuedo-threads through the use of addPeriodic(). This registers a Runnable at a designated loop interval, but it's still within the thread safety of normal robot code. <br>For many cases, this can certain time-sensitive features, while mitigating the hazards of real threads. <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/convenience-features/scheduling-functions.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/convenience-features/scheduling-functions.html</a><br><br>Native Java Threads are a suitable way to continuously run background tasks that need to truly operate independent of the main thread. However, any time they interface with normal threads, you expose the hazard of data races or data corruption; Effectively, data changes underneath you, causing weird numerical glitches, or outright crashes.<br>In these cases, you need to meticulously manage access to the threaded data. Java has numerous built in helpers, but there's no shortcut for responsible coding. <br><br>The easiest way is use of the synchronized keyword in java; This is a function decorator (like public or static), which declares that a function <br>private double number=0;

public synchronized double increment(){
    number+=1;
}
public synchronized double double_increment(){
    number+=2;
}
// do some threads and run our code
public periodicThreadA(){ increment(); }
public periodicThreadB(){ double_increment(); }
<br>This is it; If both A and B try to run increment simultaneously, it's thread will block until increment is accessable. Because of how we structure FRC code, this is often a perfectly suitable strategy; Any function trying to run a synchronized call has to wait until the other synchronized functions are done. <br>However, this comes with potential performance issues: The lock is actually protecting the base object (this, or the whole class object), rather than the more narrow value of number. So all synchronized objects share one mutex; Meaning if you have multiple, independently updating values, they're blocking each other needlessly. <br>We can get finer-grain control by use of structures like this: <br>private double number=0;
private Object numberLock = new Object(); 

public double increment(){
    synchronized (numberLock){
        number+=1;
    }
}

public double double_increment(){
    synchronized (numberLock){
        number+=2;
    }
}

// do some threads and run our code
public periodicThreadA(){ increment(); }
public periodicThreadB(){ double_increment(); }
<br>This structure is identical, but now we've explicitly stated the mutex; We can see it's locking on the function increment, rather than the data we care about, which is number.<br>Note that in both cases, any access to number needs to go through a synchronized item.<br>Helpfully, you can clean this up for many common cases, as shown in the following example: Any Object class (any class or data structure; effectively everything but Int, Float, and boolean), can be locked directly; Avoiding a separate mutex. However, we may want to develop a notation to demarcate thread-accessed objects like this.<br>private Pose2D currentPose = new Pose2D(); 

public double do_pose_things(){
    synchronized (currentPose){ //item can hold it's own thread mutex
        currentPose = new Pose2d();
    }
}
<br><br>Message passing is another threading technique that allows threads to interact safely. You simply take your data, and toss it to another thread, where it can pick it up as it needs to.<br>SynchronousQueue is a useful and simple case; This is a queue optimized to interface handoffs between threads. Instead of suppliers adding values indirectly, this queue allows functions to directly block until the other thread arrives with the data it wants. This is useful when one side is significantly faster than the other, making the time spent waiting non-critical. There's methods for both fast suppliers with slow consumers, and fast consumers with slow suppliers.<br>SynchronousQueue&lt;integer&gt; queue = new SynchronousQueue&lt;integer&gt;;

public void fastSupplier(){ //ran at high speeds
    int value = 0; /*some value, such as quickly running sensor read*/
    queue.offer(value); //will not block; Will simply see there's no one listening, and give up
}
public void slowConsumer(){ //ran at low speeds
    int value = queue.take(); //will block this thread, waiting until fastSupplier tries to make another offer.
    //do something with the value
}
<br>In most cases though, you want to keep track of all reported data, but the rate at which it's supplied doesn't always match the rate at which it's consumed. A good example is vision data for odometry. It might be coming in at 120FPS, or 0FPS. Even if it's coming in at the robot's 50hz, it's probably not exactly timed with the function.<br>Depending on the requirements, a ArrayBlockingQueue (First in First Out) or LinkedBlockingDeque (Last in First Out). These both have different uses, depending on the desired order.<br>ArrayBlockingQueue&lt;Pose2d&gt; queue = new ArrayBlockingQueue&lt;Pose2d&gt;();

public void VisionSupplier(){
    Optional&lt;Pose2d&gt; value = vision.getPoseFromAprilTags();
    if(value.isPresent(){
        if(queue.remainingCapacity() &lt; 1) queue.poll() // delete the oldest item if we don't have space
        queue.offer(value); //add the newest value.
    }
}

public void VisionConsumer(){ //ran at low speeds
    var value = queue.take(); //grab the oldest value from the queue or block to wait for it
    odometry.update(value);
}
<br>Message passing helps you manage big bursts of data, have threads block/wait for new data, but do introduce one problem: You have to make sure your code behaves well when your queue is full or empty. <br>In this case, it's sensible to just throw away the oldest value in our queue; We'll replace it with a more up-to-date one anyway.<br>
We also block when trying to retrieve new data. This is fine for a dedicated thread, but when ran on our main thread this would cause our bot to halt if we drive away from a vision target. In that case, we'd want to check to see if there's a value first, or use poll() which returns null instead of waiting. The java docs can help you find the desired behavior for various operations.<br>Also be wary about the default sizes: By default, both queues can be infinitely large, meaning if your supplier is faster, you'll quickly run out of memory. Setting a maximum (reasonable) size is the best course of action. Threading<br><br>Understand the typical Git operations most helpful for day-to-day programming<br><br>This module is intended to be completed alongside other tasks: Learning Git is best done by doing, and doing requires having code to commit.<br>
<br>Read through the <a data-href="#Git Fundamentals" href="https://stormbots.github.io/KnowledgeBase/about:blank#Git_Fundamentals" class="internal-link" target="_self" rel="noopener nofollow">Git Fundamentals</a> section
<br>Initialize a git repository in your project
<br>Create an initial commit
<br>Create several commits representing simple milestones in your project
<br>When moving to a new skill card, create a new branch to represent it. Create as many commits on the new branch as necessary to track your work for this card. 
<br>When working on a skill card that does not rely on the previous branch, switch to your main branch, and create a new branch to  represent that card.
<br>On completion of that card (or card sequence), merge the results of both branches back into Main.
<br>Upon resolving the merge, ensure both features work as intended.
<br><br>
<br>Understanding git
<br>workspace, staging, remotes
<br>fetching
<br>Branches + commits
<br>Pushing and pulling
<br>Switching branches
<br>Merging
<br>Merge conflicts and resolution
<br>Terminals vs integrated UI tools
<br><br>Git is a "source control" tool intended to help you manage source code and other text data.<br>Git has a lot of utility, but the core concept is that git allows you to easily capture your files at a specific point in time. This allows you to see how your code changes over time, do some time travel to see how it used to look, or just see what stuff you've added since your last snapshot.<br>Git does this by specifically managing the changes to your code, known as "commits". These build on each other, forming a chain from the start of project to the current code. <br>At the simplest, your project's history something like the following<br><br>Git is very powerful and flexible, but don't be intimidated! The most valuable parts of git are hidden behind just a few simple commands, and the complicated parts you'll rarely run into. Bug understanding how it works in concept lets you leverage it's value better.<br><br>Fundamental to Git is the concept of a "difference", or a diff for short. Rather than just duplicating your entire project each time you want to make a commit snapshot, Git actually just keeps track of only what you've changed.<br>In a simplified view, updating this simple subsystem<br>/**Example class that does a thing*/
class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
	ExampleSubsystem(){}
	public void runMotor(){
		motor.run(1);
	}
	public void stop(){/*bat country*/}
	public void go(){/*fish*/}
	public void reverse(){/*shows uno card*/}
}
<br>to this<br>/**Example class that does a thing*/
class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
	private Encoder encoder = new Encoder();
	ExampleSubsystem(){}
	public void runMotor(double power){
		motor.run(power);
	}
	public void stop(){/*bat country*/}
	public void go(){/*fish*/}
	public void reverse(){/*shows uno card*/}
}
<br>would be stored in Git as <br>class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
+	private Encoder encoder = new Encoder();
	ExampleSubsystem(){}
-	public void runMotor(1){
-		motor.run(1);
+	public void runMotor(double power){
+		motor.run(power);
	}
	public void stop(){/*bat country*/}
<br>With this difference, the changes we made are a bit more obvious. We can see precisely what we changed, and where we changed it.<br>
We also see that some stuff is missing in our diff: the first comment is gone, and we don't see go(), reverse() or our closing brace. Those didn't change, so we don't need them in the commit. <br>However, there are some unchanged lines, near the changed lines. Git refers to these as "context". These help Git figure out what to do in some complex operations later. It's also helpful for us humans just taking a casual peek at things. As the name implies, it helps you figure out the context of that change.<br>We also see something interesting: When we "change" a line, Git actually <br>
<br>Marks it as deleted
<br>adds a new line that's almost the same<br>
Simply put, just removing a line and then adding the new one is just easier most of the time. However, some tools detect this, and will bold or highlight the specific bits of the line that changed.
<br>When dealing with whole files, it's basically the same! The "change" is the addition of the file contents, or a line-by-line deletion of them!<br><br>Now that we have some changes in place, we want to "Commit" that change to Git, adding it to our project's history. <br>A commit in git is a just a collection of smaller changes, along with some extra data for keeping track. The most relevant is  <br>
<br>A commit "hash", which is a unique key representing that specific change set
<br>The "parent" commit, which these changes are based on
<br>The actual changes + files they belong to.
<br>Date, time, and author information
<br>A short human readable "description" of the commit. 
<br>These commits form a sequence, building on top from the earliest state of the project. We generally assign a name to these sequences, called "branches". <br>A typical project starts on the "main" branch, after a few commits, you'll end up with a nice, simple history like this. <br><br>It's worth noting that a branch really is just a name that points to a commit, and is mostly a helpful book-keeping feature. The commits and commit chain do all the heavy lifting. Basically anything you can do with a branch can be done with a commit's hash instead if you need to! <br><br>We're now starting to get into Git's superpowers. You're not limited to just one branch. You can create new branches, switch to them, and then commit, to create commit chains that look like this:<br><br>Here we can see that mess for qual 4  and mess for qual 8  are built off the main branch, but kept as part of the competition branch. This means our main branch is untouched. We can now switch back and forth using  git switch main  and git switch competition to access the different states of our codebase. <br>We can, in fact, even continue working on main adding commits like normal. <br><br>Being able to have multiple branches like this is a foundational part of how Git's utility, and a key detail of it's collaborative model. This is more traditionally referred to as a "git tree", since we can see it starts from a single trunk and then branches out into all these other branches.<br>However, you might notice the problem: We currently can access the changes in competition or main, but not both at once.  <br><br>Merging is what allows us to do that. It's helpful to think of merging the commits+changes from another branch into your current branch.<br>If we merge competition into main, we get this. Both changes ready to go! Now main can access the competition branch's changes. <br><br>However, we can equally do main into competition, granting competition access to the changes from main. <br><br>Now that merging is a tool, we have unlocked the true power of git. Any set of changes is built on top of each other, and we can grab changes without interrupting our existing code and any other changes we've been making! <br>This feature powers git's collaborative nature: You can pull in changes made by other people just as easily as you can your own. They just have to have the same parent somewhere up the chain so git can figure out how to step through the sequence of changes.<br><br>When managing changes, there's a couple places where they actually live. <br>The most apparent one is your actual code visible on your computer, forming the "Workspace". As far as you're concerned, this is just the files in the directory, or as seen by VSCode. However, Git sees them as the end result of all changes committed in the current branch, plus any additional, uncommitted changes.<br>The next one is "staging": This is just the next commit, but in an incomplete state. When setting up a commit, staging is where things are held in the meantime. Once you complete a commit, the staging area is cleared, and the changes are moved to a proper commit in your git tree.<br>
Staging is not quite a commit, as the changes represented here can be easily over-written by staging new changes from your Workspace. But, it's not quite the workspace either, and doesn't automatically follow modifications to your code.<br>
Because of this, Staging is extremely useful for code review! Staging a specific change is a great way to assert that that part is working and tested, even if you're not ready to make a commit yet.<br>In terms of our usual git tree, Staging and Workspace fit in right at the end, like so.<br><br>Lastly, is the actual commits that form your history. We generally won't deal with them individually, and instead just bundle them up in "branch". A branch is is just a helpful shorthand that names a specific commit, but in practice is used to refer to all prior changes leading up to that current commit.<br><br>Git is a distributed system, and intentionally designed so that code can be split up and live in a lot of different places at once, but interact with each other in sensible ways for managing the code.<br>The most obvious place it lives is your computer. You have a full copy of the git tree, plus your own staging and workspace. This is often called the "local" repository.<br>Next is a "remote" repository, representing a remote git server. Often this is Github, using the default remote name of "origin".<br>The important consideration is that your computer operates totally independently of the remote unless you intend to interact with it! This means you can do almost any Git task offline, and don't even need a remote to make use of Git. <br>Of course, being set up this way means that if you're not paying attention, you might not catch differences between Remote and Local git states. It's rarely an actual problem, but can be confusing and result in extra work. It's good practice to be aware of where your code is relative to origin, and make sure you push your code up to it  when appropriate.<br>When the origin is indicated specifically, you'll see it shown before the branch name: Main would go from main -&gt; origin/main, like you see here in <a data-tooltip-position="top" aria-label="Git from VSCode" data-href="#Git from VSCode" href="https://stormbots.github.io/KnowledgeBase/about:blank#Git_from_VSCode" class="internal-link" target="_self" rel="noopener nofollow">Git Graph</a>, showing that we have 1 commit locally that doesn't exist on the origin. Or, we're ahead by one commit.<br><img alt="git-graph-commit-history.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-graph-commit-history.png"><br><br>Often when doing merges, you'll run into a "merge conflict", and some parts of your code get replaced with massive compiler errors and weird syntax. Don't panic! <br>Merge conflicts happen when two branches change the same code. Git can't figure out what the "right answer" is, and so it needs a helping hand. To facilitate this, it has some special syntax so that you can see all information at a glance, but it's not always obvious that it's just being helpful! <br>Let's look at the simplest possible merge conflict: Being in main, and merging dessert<br><br>From an original file containing <br>Best food is pizza
<br>The commit in main has the following change<br>-Best food is pizza
+Best food is salad
<br>with dessert having this change<br>-Best food is pizza
+Best food is cheesecake
<br>The merge is then making Git decide what's the optimal food. Git is not equipped for this debate, so it's up to us humans. Git prepares the file in question using "merge markers" around the issue, which provide some useful info to resolve it<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  
Best food is salad  
=======  
Best food is cheesecake  
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dessert
<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD -&gt; indicates the start of a merge conflict. HEAD just means "last commit on current branch". Since we're on main, that means this code is just the result of following the code along the Main branch. VSCode will add additional information above this to help clarify.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dessert -&gt; is the end of merge conflict. dessert is the branch you're merging from; In other words, it's the result of following the proposed changes along the cheesecake branch. Again, VSCode will add additional info  to help. <br>======= -&gt; is the separator between the two branches'  code.<br>It's helpful to remember the goal of a merge: To put the two codebases together in a way that makes sense and is correct! So a merge conflict is resolved by making code that works, meaning there's several different ways to fix it!<br>One option is just accepting the change in your current branch, yielding<br>Best food is salad
<br>This just means you've ignored the proposed change from the other branch (dessert in this case)<br>The other option is accept the incoming change, and ignore what your branch had.<br>Best food is cheesecake  
<br>In some cases it's both! Maybe you're just fine with two best foods. <br>Best food is salad
Best food is cheesecake  
<br>Of course, you're after correctness. It's possible that after the update neither branch is quite right, and you have to adjust both.<br>Best side dish is salad
Best dessert is cheesecake  
<br>Or, it could be neither! Maybe the right solution has become something else entirely. <br>Best food is breakfast burritos
<br>Most of the time, a merge conflict should be very easy to deal with if you know the parts of the code you're working with.<br>
Just move the code around until it works like both branches expected, then delete the merge marker, separator, and any unnecessary code, and you're good to go!<br>And, don't worry if you missed one! Git will spot these conflict markers if you try to commit one without sorting it out. <br>If you get lost, ask for help! When dealing with code someone else wrote, you simply might not know what the best option is when coming out of it. That's fine! No tool can replace good communication.<br><br>Merge conflicts aside, just because a merge didn't have a conflict, doesn't mean the code works. A sometimes surprising result stems from the fact that Git doesn't understand code, it just understands changes! <br>The most likely reason you'll see this is someone changing a function name in one branch, while the other branch adds a new occurrence of it. Let's consider adding this code in our current branch<br>@@ MainBranch: RobotContainer.java @@
   //filecontext
+  exampleSubsystem.callSomeFunction();
   //filecontext
<br>and merging in this change from another branch.<br>@@ CleanupBranch: ExampleSubsystem.java @@
   //filecontext
-  public void callSomeFunction(){
+  public void betterNamedFunction(){
   //filecontext
<br>In this case, main doesn't know about the name change, and CleanupBranch doesn't know that you added a new call to it. This means callSomeFunction() no longer exists, leading to an error.<br>As with merge conflicts, it's up to you to figure out what's correct. In cases like this, you just want to adjust your new code to use the new name. But it sometimes happens that the other branch did something that needs to be changed back, such as deleting a function no one was using... until now you're using it.<br>Again, the purpose of the merge is to make it work! You're not done with a merge until everything works together as intended.<br><br>A lot of Git's power boils down to just using the simple usage of a few basic commands. <br>Git via command line vs Graphical tools 
While using the command line is optional, most good Git tools retain the name of these operations in graphical interfaces. After all, they're using the same operations behind the scenes.<br>
Because of this, a bit of command line knowledge can help clarify what the more user-friendly tools are trying to do, and show you exactly why they're helpful. 
<br><br>git init will creates a new git repository for your current project. It sets the "project root" as the current folder, so you'll want to double-check to make sure you're in the right spot! <br>VSCode's built in terminal will default to the right folder, so generally if your code compiles, you should be in the right spot. Once the repository is created, git commands will work just fine from anywhere inside your project.<br><br>Knowing what your code is up to is step 1 of git. These commands<br>git status just prints out the current repo status, highlighting what files are staged, and what have unstaged changes, and where you are relative to your remote. If you've used other git commands, the effects will show up in git status. Run it all the time!<br>git log will open a small terminal dialogue walking you through changes in your branch (hit q to exit). However, it's often unhelpful; It contains a lot of data you don't care about, and is missing clarity on ones you do.<br>git log --oneline tends to be more helpful ; This just prints a one-line version of relevant commits, making it much more useful. <br><br>git add &lt;files&gt; is all that's needed in most cases: This will add all changes present in a specific file. <br>git add &lt;directories&gt; works too! This adds all changes below the specified folder path. Be mindful to not add stuff you don't want to commit though! Depending on the project and setup, you may or may not want to add all files this way.<br>git add .  is a special case you'll often see in git documentation; . is just a shorthand for "the current folder" . Most documentation uses this to indicate "Stage the entire project", and is mostly helpful for your very first commit. Afterwards, we'd recommend a more careful workflow.<br>git reset &lt;staged file/dir&gt; will will remove a file's changes from Staging and put them back in the Workspace ; Meaning, the change itself is preserved, but it won't be changed.  In practice, you probably won't  do this much, as it's easier to use a GUI for this. <br><br>git commit -m "describe changes here" tends to be the beginner friendly approach. This makes a new commit with any staged changes.<br>git commit will usually open a small terminal editor called Vim with commit information and let you type a commit message. However, this editor is famous for it's "modal" interface, which is often surprising to work with at first. We'll generally avoid using it in favor of VSCode's commit tooling.<br>Quick Vim tutorial
If you get caught using the Vim editor for a commit, this is a quick rundown of the critical interaction.<br>
escape key-&gt; undo whatever command you're doing, and and exit any modes. Mash if you're panicking.<br>
i -&gt; When not in any mode, enter Insert mode (INSERT will be shown at the bottom). You can then type normally. Hit escape to go back to "command mode"<br>
: -&gt; start a command string; Letters following it are part of an editor command.<br>
:w -&gt; Run a write command (this saves your document)<br>
:q -&gt; Run a quit command (exit the file). This will throw an error if you have unsaved changes.<br>
:q! -&gt; The ! will tell Vim to just ignore warnings and leave. This is also the "panic quit" option.<br>
:wq -&gt; Runs "save" and then "quit" using a single command<br>
This means the typical interaction is i (to enter insert mode), type the message, escape, then :wq to save and quit.<br>
You can also abandon a commit by escape + :q!, since an empty commit message is not allowed by default. 
<br><br>git branch NameOfNewBranch: This just makes a new branch with the current name. Note, it does not switch to it! You'd want to do that before trying to do any commits!<br>Note, the parent node is the last commit of your current branch; This is not usually surprising if you're working solo, but for group projects you probably want to make sure your local branch is up to date with the remote!<br><br>git switch NameOfBranch: This one's pretty simple! It switches to the target branch. <br>git switch --detach &lt;commithash&gt; : This lets you see the code at a particular point in time. Sometimes this can be useful for diagnosing issues, or if you want to change where you're starting a new branch (maybe right before a merge or something). --detach just means you're not at the most recent commit of a branch. <br>You might see git checkout NameOfBranch in some documentation; This is a common convention to "check out" a branch. However, the git checkout command can do a lot of other stuff too. For what we need, git switch tends to be less error prone.<br>Switching + uncommitted changes
Note, Git will sometimes block you from changing branches! This happens if you have uncommitted changes that will conflict with the changes in the new branch. It's a special kind of merge conflict.<br>
Git has a number of tools to work around this, but generally, there's a few simpler options, depending on the code in question

<br>Delete/undo the changes: This is a good option if the changes are inconsequential such as accidental whitespace changes, temporarily commented out code for testing, or "junk" changes. Just tidy up and get rid of stuff that shouldn't be there. 
<br>Clean up and commit the changes: This is ideal if the changes belong to the current branch, and you just forgot them previously
<br>"Work in progress" commit: If you can't delete something, and it's not ready for a proper commit, just create a commit with message beginning with  "WIP"; This way, it's clear to you and others that the work wasn't done, and to not use this code. 
<br>use "git stash" the changes: This is git's "proper" resolution for this, but the workflow can be complicated, easy to mess up, and it's out of scope for this document. We won't use it often.

<br><br>git merge otherBranchName : This grabs the commits from another branch, and starts applying them to your current branch. Think of it as merging those changes into yours. If successful, it creates a merge commit for you.<br>git merge otherBranchName --no-commit : This does the merge, but doesn't automatically make a commit even when successful! This is often preferable, and makes checking and cleanup a bit easier. Once you've ran it, you can finish the commit in the usual way with git commit<br>git merge --abort is a useful tool too! If your merge is going wrong for whatever reason, this puts you  back to where you were before running it! <br>git merge (note no branch name) merges in new commits on the same branch; This is useful for  collaborate projects, where someone else might update a branch. <br><br>git fetch connects to your remote (Github), and makes a local copy of everything the remote system has! This is one of the few commands that actually needs internet to function. <br>Note, this does not change anything on your system. It does as the name implies, and just fetches it. Your local copies of branches remain at the commit you left them, so git fetch is always safe to run, and some tools run it automatically.<br><br>git pull will contact the remote system, and apply changes from the remote branch to your local branch.<br>Behind the scenes, this is just running git fetch and then git merge. So, if you run git fetch and then try to work without internet, you can still get things done! Just use git merge with no branch name.<br><br>git push does this. By default it uses the same name, making this a short and simple one. <br>Success not guaranteed
 git push will fail if the push would cause a merge conflict on the remote system. This can happen if the remote branch has been modified since you branched off of it.<br>
If this happens, you'll need to update your repository with git fetch or  git pull , resolve the conflict, and try again
<br><br>Handling Git operations from VS Code is normally a very streamlined operation, and it has good interfaces to do otherwise tricky operations. <br><br>This plugin provides some notable visualization tools that further improves Git handling in VS Code. We'll assume this is installed for the remainder of the tutorial here.<br>
<a rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" target="_blank">https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph</a><br>Install that first!<br><br>The  icon on left side will open the git sidebar, which is the starting point for many git operations. <br>Opening it will provide some at a glance stuff to review.<br><img alt="git-window+sidbar.png.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-window+sidbar.png.png"><br>We can see a lot of useful things:<br>At the top we can see any uncommitted changes, and the file they belong to. We'll deal with this when reviewing changes and making new commits.<br>
<img alt="git-commit-interface.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-commit-interface.png"><br>At the bottom (which might be folded down and labelled &gt; Outline or &gt; Graph), we can see our commit history for the current branch. The @main represents the current branch state, and  icon represents the Origin (Github). If we're ahead or behind the origin, we can see it at a glance here.  <br><img alt="git-sidebar-commit-log.png.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-commit-log.png.png"><br>Note, we also see main at the very bottom; That's always there, giving us our current branch at a glance. <br><br>The easiest way to review changes is through the Git Sidebar: Just click the file,and you'll see a split view. <br>Changes will be shown in one of two ways. "Additions" are shown as a green highlight on the right side. On the left, you can see a ///////////////// placeholder; This helps align the code so that you can easily keep track of where stuff gets inserted!<br><img alt="git-diffview-addition.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-diffview-addition.png"><br>Deletions look similar, but reversed. Left gets a red, right gets a placeholder.<br>
<img alt="git-diffview-deletion.png.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-diffview-deletion.png.png"><br>Changes to part of a line are either an addition and removal, or a small highlighted change of the particular bits. <br>Note, you can actually type here! The right hand side is editable, allowing you to revise things if you see a change that's concerning. That side just represents the current state of the file in the workspace.<br>
The left side is locked; This represents the prior state of the file, which can only be changed by adding more commits. <br>You can approve/confirm changes in a couple ways. The easiest is to simply use the "Stage Changes" button by the filename in the sidebar; This stages all changes in a particular file.<br>
<img alt="git-sidebar-state-changes.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-state-changes.png"><br>In many cases, it's helpful to handle them one by one: If you right click on a change (or selected text that includes one or more changes), you'll see some options besides the normal text editing ones<br>
<img alt="git-diffview-rightclick-stage.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-diffview-rightclick-stage.png"><br>As the name implies, you can Stage changes if you want them, Unstage them (if you want to remove it from the commit you're putting together).<br>
Note, you can also Revert it. In this case, reverting means that the change is gone! Added lines vanish, changed numbers go back to what they were, and reverting a deletion puts all the lines back! Be very careful here to not undo your work!<br>Note, that there's also a Revert/Discard Changes button too! Fortunately, this one checks with you. We'll rarely use it, but make sure to not hit it accidentally!<br>
<img alt="git-sidebar-discard-changes.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-discard-changes.png"><br>Once we've staged some changes, we'll any staged changes separate from any unstaged changes<br><img alt="git-sidebar-staging-field.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-staging-field.png"><br>
You can commit with un-staged changes just fine, just be mindful! We'll touch on best practices later. <br>Once you've added all changes you want to include in the commit, just enter the message and click "Commit". Done! <br><br>VS Code has some useful built in operations to push or pull branches! These will typically pop up automatically, with the helpful options being <br>
<br>Push -&gt; Does a standard push
<br>Pull -&gt; Does a standard pull
<br>Publish Branch -&gt; This is a normal Push, but applies to newly created local branches. This normally requires a couple other small steps, which this handles automatically
<br>Sync -&gt; Don't use this one!
<br>The "Sync" button
Be careful about the "Sync" button! Unlike other VSCode options, "Sync" will try to push and pull at the same time; However, in case of a merge conflict, it might try to resolve it using esoteric git operations behind the scenes. While this sometimes works, when something goes wrong fixing it properly is extremely challenging!<br>
In almost all cases, using a git pull , verifying the merge, and then a git push is a better workflow!
<br><br>We're now looking at the <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" target="_blank">Git Graph</a> specific stuff, so make sure that's installed!<br>There's two ways to launch it. One is using VS Code's Command Palette, activated by CTRL+Shift+P then typing "View Git Graph" or "git log" to pull up this particular one.<br>
<img alt="git-gitgraph-command-palette.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-command-palette.png"><br>The other is by clicking "Git Graph" along the bottom toolbar.<br>
<img alt="git-gitgraph-bottom-bar.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-bottom-bar.png"><br>Both of these will take you to a good review interface, where you can see the status of many branches, the commit log, and how things merged and diverted! This is from our 2025 season code.<br><img alt="git-gitgraph-interface.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-interface.png"><br>Just this interface provides a lot of value: You can easily see the commit history, how branches have diverged and been merged, and check to see what branches are ahead or behind of the  origin. <br>If you click a commit, you get a more detailed status, but most notably what files were altered.<br>
<img alt="git-gitgraph-diff-detail.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-diff-detail.png"><br>
And, if you click the file in the commit details, it'll show you what that commit changed!<br>
<img alt="git-gitgraph-diffview.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-diffview.png"><br>
This is a very fast and effective way to look through your project and catch up on what's happening. <br>There's a lot of other value here if you click around, including being able to right click and checkout or switch to various branches!<br><br>VS Code's terminal often pops up during many other operations, but if you don't see it, you can access it through the menu.<br>
<img alt="git-terminal-new.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-terminal-new.png"><br>Since we usually work on Windows, this will often open up a Powershell, which is usually sub-optimal for what we want to use a terminal for. Git Bash is usually nicer. You can change this with the Command Pallete (CTRL+Shift+P), and selecting Terminal: Select Default Profile. <br><img alt="git-terminal-change-default.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-terminal-change-default.png"><br>If Bash is available, click it! Any new terminals will use the Git bash, which will have color, some at-a-glance git info, and generally more helpful all around. <br><br>There's a lot of tools that interact with your Git repository, but it's worth being mindful about which ones you pick! A lot of tools wind up changing normal git operations into renamed or altered versions that do a lot of things at once. This can make learning it harder, and if something goes wrong, fixing the results can be extremely difficult. Stick to the basics until you know what's happening and you can properly judge if a new tool is worth using.<br><br><br>Creating the initial project setup:<br>
<br>git init to set up our new project.
<br>git add .   to stage all the files in their blank, default state
<br>Commit the code, using VSCode's interface or with the terminal git commit -m "initial commit" 
<br>Doing the code work:<br>
<br>git branch featurebeingadded to set up a new branch for your task
<br>git switch featurebeingadded to select your new branch
<br>Add the code
<br>Review the new code using VSCode, staging parts that are confirmed to work
<br>Commit the code (via Code or terminal)
<br>Repeat commits until done
<br>Handling review and merging. Be mindful of local and remote branch states for this!<br>
<br>Test and review your  code! Make sure it works in the final state.
<br>git fetch to ensure your git repo is aware of any changes.
<br>git merge origin/main --no-commit -&gt; Bring in all new changes
<br>Fix, test, review your code with all the new base project code.
<br>git commit to finalize the merge.
<br>git push to push your branch with the merge completed.
<br>Work with your maintainer (a mentor or veteran) to pull your new, validated changes back into main! 
<br><br>Branches are best when they're small, focused, and well defined. <br>A great workflow is using so called "topic branches" or "feature branches": In this workflow, a branch represents a feature you're adding, or a bug you're fixing. Once the feature is added and working, the branch is Done. You merge your branch back into the Main branch, and you can move onto another feature in a new branch!<br>By doing this, you keep each branch simple, easy to test, and easy to merge. It also helps prevent the issue of long-running branches; Where your code is isolated from a long time, and drifts apart from everyone else's code in main. That ends up with you not working on quite the same code base as other people, and you'll miss out on features, fixes that everyone else has, and they'll miss out on yours. <br>A good feature branch name also helps keep you as a programmer constrained to the task at hand.<br><br>To facilitate "feature branch" convention, name your branches after feature itself, rather than the part of code it's affecting. Make sure that the branch name implies an "end state" at which point you can consider it Done and stop working on it. <br>As an example, some good initial branch names are add-far-shots, add-climb-routine, or fix-intake-stalling-issue. Since we're usually adding or fixing things, we can often omit that in the actual name leaving us with far-shots, climb-routine, intake-stall-issue), but it's helpful to always pretend it's there unless a clearer verb exists (like remove or adjust. <br>Early on, you might be tempted to name your branches after robot systems, like intake, shooter, or the like. But don't do this! The intake will always exist on the robot, so your branch has no clear end state!<br>
Instead, name it something like  intake-bringup. This provides an end-condition: Once the intake is brought up, functioning, and tested, the branch is done, and you can merge it back into main. <br>In some cases, it's helpful to indicate which part of the robot you're working on though: The optimal method is using subsystemname/feature. This is especially true of features relevant to various subsystems like bringup, which just yields intake/bringup, elevator/bringup, etc. <br><br>Merging is more useful than just sending your changes back to Main. You can use merging to keep up with other features that interact with the code you're working with.<br>As an example, let's say you're trying to bring up an Indexer system, which interacts with a Intake and a Shooter. During early development, you might see some branches like this<br><br>Intake and Shooter aren't done enough to merge back into main, but the indexer can't really be tested because you need to move it through the intake and shooter. But, you also don't want to actually do all that work yourself. <br>So, just merge the intake/bringup and shooter/bringup branches! <br><br>There you go! Now you can continue your work, using the preliminary work from the other branches. As they adjust and fix things, you can merge their code, and they could also merge yours into their branches before finally verifying 2 or 3 of these subsystems work properly.<br>There's a catch here: The branches in question might not be fully ready for you to pull them! It's always a good idea to talk to whoever's working on that code to make sure that it's in a state that's good to go. Sometimes they'll just need to adjust up one or two things, fix a variable/method name, or other times they might suggest you wait for some bigger cleanup or process fixes.<br><br>Similar in concept to the above in some ways! By our process definitions, Main should always be in a good state, meaning you can pull it at any time. So, before declaring your branch Done and getting it in Main, go ahead and pull Main and test things first!<br><br>Now you can test the indexer in the full codebase without any risk of accidentally putting a bug in main, and any adjustments are part of the indexer/bringup branch like shown here<br><br>At long last, with everything fully integrated, we can finally get our changes back into main, knowing with confidence it works as expected.<br>Git Basics<br><br><br>Interact with the PhotoVision UI and basic code structures<br><br>
<br>Connect to the WebUI
<br>Set up a camera
<br>Set up AprilTag Target
<br>Read target position via NT
<br><br>This allows you to access PhotonVision via the roborio USB port.<br>
This can be useful when debugging at competitions<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.photonvision.org/en/latest/docs/quick-start/networking.html" target="_blank">https://docs.photonvision.org/en/latest/docs/quick-start/networking.html</a>PhotonVision Basics<br><br><br>
<br>Configure the PV networking
<br>Configure the PV hardware
<br>Set up a camera
<br>Create a Vision code class
<br>Configure PV class to communicate with the hardware
PhotonVision Bringup<br><br><br>
<br>Set up a pipeline to identify april tags
<br>Configure camera position relative to robot center
<br>Set up a
PhotonVision Odometry<br><br><br>
<br>Add a Object detection pipeline
<br>Detect a game piece using color detection
<br>if available, detect it using a ML object model 
<br><br><a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/open-source-real-time-game-piece-position-estimation-for-frc-robots/506640" target="_blank">https://www.chiefdelphi.com/t/open-source-real-time-game-piece-position-estimation-for-frc-robots/506640</a>PhotonVision Object Detection<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> <br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>
<br>Create a Widget on a dashboard to show the field
<br>Populate the Field with your robot, and one or more targets
<br>Utilize the Field to help develop a "useful feature" displayed on the Field
<br>As a telemetry task, success is thus open ended, and should just be part of your development process; The actual feature can be anything, but a few examples we've seen before are<br>
<br>showing which of several targets your code has deemed best, and react to it
<br>a path your robot is following, and where the bot is while following it
<br>The current Vision targets and where your bot is when seeing them
<br>A field position used as an adjustable target 
<br>The projected path for a selected auto
<br>Inidcate proximity or zones "zones" for performing a task, such as the acceptable range for a shooting task or intaking process.
<br><br>Odometry is also known as Position Tracking. In FRC, this is generally regarded as knowing the position of your robot in the game field. It is most beneficial when combined with the robot to then have the robot move between positions on the field, and interact with other known positions. <br>Actually obtaining odometry depends on the design of the bot: <a data-tooltip-position="top" aria-label="Level 1/Differential Drive Odometry" data-href="Level 1/Differential Drive Odometry" href="https://stormbots.github.io/KnowledgeBase/Level 1/Differential Drive Odometry" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive Odometry</a> or <a data-href="Swerve Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Odometry</a> , and often involves vision systems via <a data-tooltip-position="top" aria-label="Limelight Odometry" data-href="Limelight Odometry" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">LimeLight Odometry</a> or <a data-href="PhotonVision Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">PhotonVision Odometry</a><br>This document is concerned with the prerequisite: Being able to actually view, compare, and validate positions using robot telemetry.<br><br><img alt="telemetry-elastic.png" src="https://stormbots.github.io/KnowledgeBase/assets/telemetry-elastic.png"><br>Telemetry for Odometry revolves around the Field2D object. Both Glass and Elastic can display the Field2D object as a game field on the dashboard, including associated robot positions and any secondary objects.<br>In general, Glass is the superior option for most programming tasks and development, allowing easier customization to help reduce clutter and provide clarity between objects. <br>The WPILib Docs are excellent at helping demonstrate many of these examples:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>In Robots, a Pose represents a specific location and state of a robot's actuator. Within the context of odometry, a pose represents the robot's location on a 2D plane. In most cases, this means the location on the game field. <br>In order to represent such a state, we need 3 things: The X position, the Y position, and a rotation. <br>In WPILib, this is handled by the <a data-href="Pose2d" href="https://stormbots.github.io/KnowledgeBase/misc/pose2d.html" class="internal-link" target="_self" rel="noopener nofollow">Pose2d</a> object, which can be provided to and returned from many utilities interacting with the robot position, including drivetrain path planning, vision, simulation, and telemetry.<br><br>The Field2D object in WPILib contains a number of utilities for keeping tabs on odometry. It can be added with just a couple lines. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		//We only want to send the actual Field object _once_,
		//so we often do it in the constructor. Changes will be 
		//sent automatically as the Field2d object itself is updated.
				
		//Preferred: Set the NetworkTables name explicitly, 
		//and give it a unique, descriptive name
		SmartDashboard.putData("ChassisField",field);
		
		// This form uses the default name "Field" as the key.
		// Not recommended in most cases
		//SmartDashboard.putData(field);
	}

}
<br>This creates a blank, empty field, with your robot position, probably at (0,0)  in the bottom left corner, on the blue side of the field. <br>Meaningfully updating the robot pose is out of scope, and differs by drivetrain type; However, the basic gist is <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	//Set up an odometry object to track our robot
	DifferentialDrivePoseEstimator odometry=new DifferentialDrivePoseEstimator(
	 /* Complex constructor parameters; not relevant*/
	)
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Read the odometry object and set the pose. //Reference only
		field.setRobotPose(odometry.getPoseMeters());
		
		// Or, we can just set it manually for testing.
		field.setRobotPose(new Pose2d(2.7,3.1, new Rotation2d(Math.PI/2.0) ));	
	}
}
<br>Now, when we open our Field2D widget in Glass, we'll see that our robot is at a new position. If we fully implemented our Pose Estimator object, we'd see that this provides realtime tracking of our position.<br>A .getRobotPose() also exists, but tends to be less useful in practice, as most classes that will interact with the Robot and Field will likely have access to the Odometry object directly. <br>Note, that the Field2d object we create is a unique reference, with it's own unique local data; only the NetworkTables key might have overlap when using default keys. This means if we want to properly share a Field across multiple classes, we either need to fetch the NetworkTables data and copy it over, create a single Field object in RobotContainer and pass it to, or create a DriverField object as a <a data-tooltip-position="top" aria-label="Singletons" data-href="Singletons" href="https://stormbots.github.io/KnowledgeBase/level-2/singletons.html" class="internal-link" target="_self" rel="noopener nofollow">Singleton</a> that can facilitate a single object.<br><br>Where Field2d objects really shine is in adding supplemental information about other field objects. The utility varies by game, but it's great for showing a variety of things such as <br>
<br>Targets/objectives
<br>Nearest/best target
<br>Nearest game piece (detected by vision systems)
<br>These can be done using the getObject(name) method; This grabs the named object from the field, creating it if it doesn't already exist.<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Can provide any number of pose arguments
		field.getObject("GamePieces").setPoses(
			new Pose2d(1,1),
			new Pose2d(1,2),
			new Pose2d(1,3),
		);
		//You can also pass a single List&lt;Pose2d&gt; 
		//if you have a list of poses already
		
		field.getObject("BestGamePiece").setPose(
			new Pose2d(1,2)	
		);
	}

}
<br>Note It's worth considering that for objects that never move, you could set  objects once in the constructor, and they work fine. However, if the user accidentally moves them in the UI, it creates a visual mis-match between what the code is doing and what the user sees. As a result, it's often better to just throw it in a Periodic.<br><br>A niche, but very useful application of field objects is to get precise driver feedback on field location data.  This can be done using the following code setup:<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command aimAtCustomTarget(){
		return run(()-&gt;{
			var target=field.getObject("DriverTarget").getPose();
			//Do math to figure out the angle to target
			//Set your drivetrain to face the target
		};
	}
	
	public void periodic(){
		//No setting DriverTarget pose here!
	};
}
<br>In this case, we take advantage of the "set once" approach in constructors; The drivers or programmers can modify the position, and then we now read it back into the code. <br>This can be very useful for testing to create "moving targets" to test dynamic behavior without having to drive the bot. It can also help you create "simulation" poses for testing math relating to Pose2D objects.<br> is especially true for simulation, as this allows you quickly test pose-related functions and makes sure that things happen how you expect.<br>One practical application is match-specific targets for cooperating with allies. An example is in 2024 Crescendo: a common game tactic was to "pass" rings across the field, by shooting to an open area near where your allies would be. However, since the game pieces can get stuck in/on robots, and different robots have different intakes, and each ally has different sight lines, making the ideal pass target unknown until the actual match is about to start. An adjustable target let the alliance sort it out before a match without having to change the code.<br><br>When doing path-planning for drivetrains, it's often helpful to display the full intended path, rather than a lot of individual poses. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command buildAuto1(){
		var  trajectory=// Get the trajectory object from your path tool
		field.getObject("autoTrajectory").setTrajectory(trajectory);
		return run(()-&gt;{
			//draw the rest of the owl
		};
	}
	

}
<br>In this use case, the work will likely be done inside your Auto class after selecting the appropriate one. Basic Odometry+Telemetry<br><br><br><br><br>
<br>Oh no
PhotonVision Model TrainingQuestNav<br><br><br>Understand how to efficiently communicate to and from a robot for diagnostics and control <br><br>
<br>Print a notable event using the RioLog
<br>Find your logged event using DriverStation
<br>Plot some sensor data (such as an encoder reading), and view it on Glass/Elastic
<br>Create a subfolder containing several subsystem data points.
<br>As a telemetry task, success is thus open ended, and should just be part of your development process; The actual feature can be anything, but a few examples we've seen before are<br><br>By definition, a program runs exactly as you the code was written to run. Most notably, this does not strictly mean the code runs as it was intended to. <br>When looking at a robot, there's a bunch of factors that can have be set in ways that were not anticipated, resulting in unexpected behavior.<br>Telemetry helps you see the bot as the bot sees itself, making it much easier to bridge the gap between what it's doing and what it should  be doing. <br><br>Simply printing information to a terminal is often the easiest form of telemetry to write, but rarely the easiest one to use. Because all print operations go through the same output interface, the more information you print, the harder it is to manage.<br>This approach is best used for low-frequency information, especially if you care about quickly accessing the record over time. It's best used for marking notable changes in the system: Completion of tasks, critical events, or errors that pop up. Because of this, it's highly associated with "logging".<br>The methods to print  are attached to the particular print channels<br>//System.out is the normal output channel
System.out.println("string here"); //Print a string
System.out.println(764.3); //you can print numbers, variables, and many other objects

//There's also other methods to handle complex formatting.... 
//But we aren't too interested in these in general.
System.out.printf("Value of thing: %n \n", 12);
<br>A typical way this would be used would be something like this:<br>public ExampleSubsystem{
	boolean isAGamePieceLoaded=false;
	boolean wasAGamePieceLoadedLastCycle=false;
	
	public Command load(){
		//Some operation to load a game piece and run set the loaded state
		return runOnce(()-&gt;isAGamePieceLoaded=true);
	}
	
	public void periodic(){
		if(isAGamePieceLoaded==true &amp;&amp; wasAGamePieceLoadedLastCycle==false){
			System.out.print("Game piece now loaded!");
		}
		if(isAGamePieceLoaded==false &amp;&amp; wasAGamePieceLoadedLastCycle==true){
			System.out.print("Game piece no longer loaded");
		}
		wasAGamePieceLoadedLastCycle=isAGamePieceLoaded
	}
}
<br>Rather than spamming "GAME PIECE LOADED" 50 times a second for however long a game piece is in the bot, this pattern cleanly captures the changes when a piece is loaded or unloaded.<br>In a more typical <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command based robot</a> , you could put print statements like this in the end() operation of your command, making it even easier and cleaner. <br>The typical interface for reading print statements is the RioLog: You can access this via the Command Pallet (CTRL+Shift+P) by just typing &gt; WPILIB: Start Riolog. You may need to connect to the robot first. <br>These print statements also show up in the DriverStation logs viewer, making it easier to pair your printed events with other driver-station and match events. <br><br>Data in our other telemetry applications uses the NetworkTables interface, with the typical easy access mode being the SmartDashboard api. This uses a "key" or name for the data, along with the value. There's a couple function names for different data types you can interact with<br>// Put information into the table
SmartDashboard.putNumber("key",0); // Any numerical types like int or float
SmartDashboard.putString("key","value"); 
SmartDashboard.putBoolean("key",false);
SmartDashboard.putData("key",field2d); //Many built-in WPILIB classes have special support for publishing
<br>You can also "get" values from the dashboard, which is useful for on-robot networking with devices like <a data-tooltip-position="top" aria-label="Limelight Basics" data-href="Limelight Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight</a>, <a data-tooltip-position="top" aria-label="PhotonVision Basics" data-href="PhotonVision Basics" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-basics.html" class="internal-link" target="_self" rel="noopener nofollow">PhotonVision</a>, or for certain remote interactions and non-volatile storage.<br>
Note, that since it's possible you could request a key that doesn't exist, all these functions require a "default" value; If the value you're looking for is missing, it'll just  give you the provided default.<br>SmartDashboard.getNumber("key",0);
SmartDashboard.getString("key","not found");
SmartDashboard.getBoolean("key",false);
<br>Networktables also supports hierarchies using the "/" seperator: This allows  you to separate things nicely, and the telemetry tools will let you interface with groups of values.<br>SmartDashboard.putNumber("SystemA/angle",0);
SmartDashboard.putNumber("SystemA/height",0);
SmartDashboard.putNumber("SystemA/distance",0);
SmartDashboard.putNumber("SystemB/angle",0);
<br>While not critical, it is also helpful to recognize that within their appropriate heirarchy, keys are displayed in alphabetical order! Naming things can thus be helpful to organizing and grouping data. <br><br>As you can imagine, with multiple people each trying to get robot diagnostics, this can get very cluttered. There's a few good ways to make good use of Glass for rapid diagnostics:<br>
<br>Group your keys using group/key . All items with the same group/ value get put into the same subfolder, and easier to track. Often subsystem names make a great group pairing, but if you're tracking something specific, making a new group can help. 
<br>Label keys with units: a  key called angle is best when written as angle degree ; This ensures you and others don't confuse it with angle rad.  
<br>Once you have your grouping and units, add more values! Especially when you have multiple values that should be the same. One of the most frequent ways for a system to go wrong is when two values differ, but shouldn't.
<br>A good case study is an arm: You would have <br>
<br>An absolute encoder angle
<br>the relative encoder angle
<br>The target angle
<br>motor output<br>
And you would likely have a lot of other systems going on. So, for the arm you would want to organize things something like this
<br>SmartDashboard.putNumber("arm/enc Abs(deg)",absEncoder.getAngle());
SmartDashboard.putNumber("arm/enc Rel(deg)",encoder.getAngle());
SmartDashboard.putNumber("arm/target(deg)",targetAngle);
SmartDashboard.putNumber("arm/output(%)",motor.getAppliedOutput());
<br>A good sanity check is  to think "if someone else were to read this, could they figure it out without digging in the code". If the answer is no, add a bit more info.<br><br>Glass is our preferred telemetry interface as programmers: It offers great flexibility, easy tracking of many potential outputs, and is relatively easy to use. <br><img alt="telemetry-glass.png" src="https://stormbots.github.io/KnowledgeBase/assets/telemetry-glass.png"><br>
Glass does not natively "log" data that it handles though; This makes it great for realtime diagnostics, but is not a great logging solution for tracking data mid-match.<br>This is a great intro to how to get started with Glass:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/index.html</a><br>For the most part, you'll be interacting with the NetworkTables block, and adding visual widgets using Plot and the NetworkTables menu item.<br><br>Elastic is a telemetry interface oriented more for drivers, but can be useful for programming and other diagnostics. Elastic excels at providing a flexible UI with good at-a-glance visuals for various numbers and directions.<br><img alt="telemetry-elastic.png" src="https://stormbots.github.io/KnowledgeBase/assets/telemetry-elastic.png"><br>Detailed docs are available here:<br>
<a rel="noopener nofollow" class="external-link" href="https://frc-elastic.gitbook.io/docs" target="_blank">https://frc-elastic.gitbook.io/docs</a><br>As a driver tool, it's good practice to set up your drivers with a screen according to their preferences, and then make sure to keep it uncluttered. You can go to Edit -&gt; Lock Layout to prevent unexpected changes. <br>For programming utility, open a new tab, and add widgets and items.<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a> Basic Telemetry<br><br><br>
<br>Create a basic Arm or Elevator motion system
<br>Create a Mechanism 2D representation of the control angle
<br>Create additional visual flair on mechanism to help indicate mechanism context
Mechanism2d<br><br>
<br>Create a standard Arm or Elevator
<br>Model the system as a Mechanism2D
<br>Create a Physics model class
<br>Configure the physics model
<br>Tune the model to react in a sensible way. It does not need to match a real world model
<br><br><a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/autonomous-programming/504795/18?u=tekdemo" target="_blank">https://www.chiefdelphi.com/t/autonomous-programming/504795/18?u=tekdemo</a><br><img alt="moment-of-inertia-equations.png" src="https://stormbots.github.io/KnowledgeBase/assets/moment-of-inertia-equations.png">Physics Simulation<br><br>
<br>??? Do we need or want this here? 
<br>Need to find a way to actually use it efficiently in beneficial way
<br><br>
<br>Understand how to set up Advantagekit
<br><a rel="noopener nofollow" class="external-link" href="https://docs.advantagekit.org/getting-started/what-is-advantagekit/" target="_blank">https://docs.advantagekit.org/getting-started/what-is-advantagekit/</a>AdvantageKit<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> <br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>
<br>Create a Widget on a dashboard to show the field
<br>Populate the Field with your robot, and one or more targets
<br>Utilize the Field to help develop a "useful feature" displayed on the Field
<br>As a telemetry task, success is thus open ended, and should just be part of your development process; The actual feature can be anything, but a few examples we've seen before are<br>
<br>showing which of several targets your code has deemed best, and react to it
<br>a path your robot is following, and where the bot is while following it
<br>The current Vision targets and where your bot is when seeing them
<br>A field position used as an adjustable target 
<br>The projected path for a selected auto
<br>Inidcate proximity or zones "zones" for performing a task, such as the acceptable range for a shooting task or intaking process.
<br><br>Odometry is also known as Position Tracking. In FRC, this is generally regarded as knowing the position of your robot in the game field. It is most beneficial when combined with the robot to then have the robot move between positions on the field, and interact with other known positions. <br>Actually obtaining odometry depends on the design of the bot: <a data-tooltip-position="top" aria-label="Level 1/Differential Drive Odometry" data-href="Level 1/Differential Drive Odometry" href="https://stormbots.github.io/KnowledgeBase/Level 1/Differential Drive Odometry" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive Odometry</a> or <a data-href="Swerve Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Odometry</a> , and often involves vision systems via <a data-tooltip-position="top" aria-label="Limelight Odometry" data-href="Limelight Odometry" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">LimeLight Odometry</a> or <a data-href="PhotonVision Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">PhotonVision Odometry</a><br>This document is concerned with the prerequisite: Being able to actually view, compare, and validate positions using robot telemetry.<br><br><img alt="telemetry-elastic.png" src="https://stormbots.github.io/KnowledgeBase/assets/telemetry-elastic.png"><br>Telemetry for Odometry revolves around the Field2D object. Both Glass and Elastic can display the Field2D object as a game field on the dashboard, including associated robot positions and any secondary objects.<br>In general, Glass is the superior option for most programming tasks and development, allowing easier customization to help reduce clutter and provide clarity between objects. <br>The WPILib Docs are excellent at helping demonstrate many of these examples:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>In Robots, a Pose represents a specific location and state of a robot's actuator. Within the context of odometry, a pose represents the robot's location on a 2D plane. In most cases, this means the location on the game field. <br>In order to represent such a state, we need 3 things: The X position, the Y position, and a rotation. <br>In WPILib, this is handled by the <a data-href="Pose2d" href="https://stormbots.github.io/KnowledgeBase/misc/pose2d.html" class="internal-link" target="_self" rel="noopener nofollow">Pose2d</a> object, which can be provided to and returned from many utilities interacting with the robot position, including drivetrain path planning, vision, simulation, and telemetry.<br><br>The Field2D object in WPILib contains a number of utilities for keeping tabs on odometry. It can be added with just a couple lines. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		//We only want to send the actual Field object _once_,
		//so we often do it in the constructor. Changes will be 
		//sent automatically as the Field2d object itself is updated.
				
		//Preferred: Set the NetworkTables name explicitly, 
		//and give it a unique, descriptive name
		SmartDashboard.putData("ChassisField",field);
		
		// This form uses the default name "Field" as the key.
		// Not recommended in most cases
		//SmartDashboard.putData(field);
	}

}
<br>This creates a blank, empty field, with your robot position, probably at (0,0)  in the bottom left corner, on the blue side of the field. <br>Meaningfully updating the robot pose is out of scope, and differs by drivetrain type; However, the basic gist is <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	//Set up an odometry object to track our robot
	DifferentialDrivePoseEstimator odometry=new DifferentialDrivePoseEstimator(
	 /* Complex constructor parameters; not relevant*/
	)
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Read the odometry object and set the pose. //Reference only
		field.setRobotPose(odometry.getPoseMeters());
		
		// Or, we can just set it manually for testing.
		field.setRobotPose(new Pose2d(2.7,3.1, new Rotation2d(Math.PI/2.0) ));	
	}
}
<br>Now, when we open our Field2D widget in Glass, we'll see that our robot is at a new position. If we fully implemented our Pose Estimator object, we'd see that this provides realtime tracking of our position.<br>A .getRobotPose() also exists, but tends to be less useful in practice, as most classes that will interact with the Robot and Field will likely have access to the Odometry object directly. <br>Note, that the Field2d object we create is a unique reference, with it's own unique local data; only the NetworkTables key might have overlap when using default keys. This means if we want to properly share a Field across multiple classes, we either need to fetch the NetworkTables data and copy it over, create a single Field object in RobotContainer and pass it to, or create a DriverField object as a <a data-tooltip-position="top" aria-label="Singletons" data-href="Singletons" href="https://stormbots.github.io/KnowledgeBase/level-2/singletons.html" class="internal-link" target="_self" rel="noopener nofollow">Singleton</a> that can facilitate a single object.<br><br>Where Field2d objects really shine is in adding supplemental information about other field objects. The utility varies by game, but it's great for showing a variety of things such as <br>
<br>Targets/objectives
<br>Nearest/best target
<br>Nearest game piece (detected by vision systems)
<br>These can be done using the getObject(name) method; This grabs the named object from the field, creating it if it doesn't already exist.<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Can provide any number of pose arguments
		field.getObject("GamePieces").setPoses(
			new Pose2d(1,1),
			new Pose2d(1,2),
			new Pose2d(1,3),
		);
		//You can also pass a single List&lt;Pose2d&gt; 
		//if you have a list of poses already
		
		field.getObject("BestGamePiece").setPose(
			new Pose2d(1,2)	
		);
	}

}
<br>Note It's worth considering that for objects that never move, you could set  objects once in the constructor, and they work fine. However, if the user accidentally moves them in the UI, it creates a visual mis-match between what the code is doing and what the user sees. As a result, it's often better to just throw it in a Periodic.<br><br>A niche, but very useful application of field objects is to get precise driver feedback on field location data.  This can be done using the following code setup:<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command aimAtCustomTarget(){
		return run(()-&gt;{
			var target=field.getObject("DriverTarget").getPose();
			//Do math to figure out the angle to target
			//Set your drivetrain to face the target
		};
	}
	
	public void periodic(){
		//No setting DriverTarget pose here!
	};
}
<br>In this case, we take advantage of the "set once" approach in constructors; The drivers or programmers can modify the position, and then we now read it back into the code. <br>This can be very useful for testing to create "moving targets" to test dynamic behavior without having to drive the bot. It can also help you create "simulation" poses for testing math relating to Pose2D objects.<br> is especially true for simulation, as this allows you quickly test pose-related functions and makes sure that things happen how you expect.<br>One practical application is match-specific targets for cooperating with allies. An example is in 2024 Crescendo: a common game tactic was to "pass" rings across the field, by shooting to an open area near where your allies would be. However, since the game pieces can get stuck in/on robots, and different robots have different intakes, and each ally has different sight lines, making the ideal pass target unknown until the actual match is about to start. An adjustable target let the alliance sort it out before a match without having to change the code.<br><br>When doing path-planning for drivetrains, it's often helpful to display the full intended path, rather than a lot of individual poses. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command buildAuto1(){
		var  trajectory=// Get the trajectory object from your path tool
		field.getObject("autoTrajectory").setTrajectory(trajectory);
		return run(()-&gt;{
			//draw the rest of the owl
		};
	}
	

}
<br>In this use case, the work will likely be done inside your Auto class after selecting the appropriate one. Basic Odometry+Telemetry<br><br><br>
<br>Choose a PathPlanning tool
<br>Implement the Java framework for the selected tool
<br>Model the robot's physical parameters for your tool
<br>Drive a robot along a target trajectory using one of these tools
<br>Followup to:<br>
<a data-href="Auto Differential" href="https://stormbots.github.io/KnowledgeBase/level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Swerve Motion" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-motion.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Motion</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html</a><br>
<a rel="noopener nofollow" class="external-link" href="https://choreo.autos/" target="_blank">https://choreo.autos/</a><br>
<a rel="noopener nofollow" class="external-link" href="https://pathplanner.dev/home.html" target="_blank">https://pathplanner.dev/home.html</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html</a><br><br>Do you need path planning to make great autos? Maybe! But not always.<br>PathPlanning can give you extremely fast, optimized autos, allowing you to squeeze every fraction of a second from your auto. However, it can be challenging to set up, and has a long list of requirements to get even moderate performance.<br><br><br>Unlike "path planning" algorithms that attempt to define and predict robot motion, Pure Pursuit simply acts as a reactive path follower, as the name somewhat implies.<br><a rel="noopener nofollow" class="external-link" href="https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html" target="_blank">https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html</a><br><a rel="noopener nofollow" class="external-link" href="https://wiki.purduesigbots.com/software/control-algorithms/basic-pure-pursuit" target="_blank">https://wiki.purduesigbots.com/software/control-algorithms/basic-pure-pursuit</a><br><img alt="pathfinding-pure-pursuit.png" src="https://stormbots.github.io/KnowledgeBase/assets/pathfinding-pure-pursuit.png"><br>This algorithm is fairly simple and conceptually straightforward, but with some notable limitations. However, the concept is very useful for advancing simpler autos<br><br><a rel="noopener nofollow" class="external-link" href="https://therekrab.github.io/autopilot/technical.html" target="_blank">https://therekrab.github.io/autopilot/technical.html</a><br>
<a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/introducing-autopilot-a-novel-solution-to-holonomic-motion-control/504244/21" target="_blank">https://www.chiefdelphi.com/t/introducing-autopilot-a-novel-solution-to-holonomic-motion-control/504244/21</a>PathPlanning Tools<br><br>Part of:<br>
<a data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a><br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br><br>
<br>Write the tuning functions for a system
<br>Get the system ID values
<br>Update the system with the values
<br>


<br><br><a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/hardware-testers-needed-optimal-pid-gain-estimation-in-recalc/503535/4" target="_blank">https://www.chiefdelphi.com/t/hardware-testers-needed-optimal-pid-gain-estimation-in-recalc/503535/4</a>System Identification<br><br>
<br>


<br><br>A pre-computed list of input and output values.<br>Can be used to help model non-trivial conditions where mathematical models are complicated, or don't apply effectively to the problem at hand. <br>Commonly used for modelling <a data-href="Superstructure Shooter" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Shooter</a> Lookup Tables<br><br>
<br>??? Do we need or want this here? 
<br>Need to find a way to actually use it efficiently in beneficial way
<br><br>
<br>Understand how to set up Advantagekit
<br><a rel="noopener nofollow" class="external-link" href="https://docs.advantagekit.org/getting-started/what-is-advantagekit/" target="_blank">https://docs.advantagekit.org/getting-started/what-is-advantagekit/</a>AdvantageKit<br><br>
<br>Create new drive subsystem 
<br>Create and configure a YAGSL drivetain
<br>Tune Yagsl drivetrain and controls for manual driving
<br>Adjust parameters to ensure accurate auto driving and odometry tracking
<br>
Swerve BringupSwerve Odometry<br><br>Interface with swerve for autos and non-trivial teleop interactions<br><br>
<br>Changing point of rotation in real time
<br>Move from Point to Point using a PID
<br>Move from point to point using a motion profile
<br>Create a command that allows translation while aimed at a bearing
<br>Create a command that allows translation while aimed at a Pose2d
Swerve Motion<br><br>
<br>Understand how swerve works
<br>Teleop Interactions for existing swerve
<br>Reading odometry
<br>Reset/Initialize odometry 
<br><br>
<br>Use an existing Swerve configuration
<br>
Swerve Basics<br><br><br>
<br>Configure a motion system with PID and FeedForward
<br>Add a trapezoidal motion profile command (runs indefinitely)
<br>Create a decorated version with exit conditions
<br>Create a small auto sequence to cycle multiple points
<br>Create a set of buttons for different setpoints
<br><img alt="motion-profile-time-plots.png" src="https://stormbots.github.io/KnowledgeBase/assets/motion-profile-time-plots.png">Motion Profiles<br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/inversekinematics" target="_blank">https://robotics-explained.com/inversekinematics</a>Inverse Kinematics<br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/forwardkinematics" target="_blank">https://robotics-explained.com/forwardkinematics</a>Forward Kinematics<br>Requires:<br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a velocity FF for a roller system that enables you to set the output in RPM
<br>Create a gravity FF for a elevator system that holds the system in place without resisting external movement
<br>Create a gravity FF for an arm system that holds the system in place without resisting external movement
<br><br>Feedforwards model an expected motor output for a  system to hit specific target values.<br>
The easiest example is a motor roller. Let's say you want to run at ~3000 RPM. You know your motor has a top speed of ~6000 RPM at 100% output, so you'd correctly expect that driving the motor at 50% would get about 3000 RPM. This simple correlation is the essence of a feed-forward. The details are specific to the system at play. <br><br>The WPILib docs have good fundamentals on feedforwards that is worth reading.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br><br>Feed-forwards are specifically tuned to the system you're trying to operate, but helpfully fall into a few simple terms, and straightforward calculations. In many cases, the addition of one or two terms can be sufficient to improve and simplify control. <br><br>The simplest feedforward you'll encounter is the "static feed-forward". This term represents initial momentum, friction, and certain motor dynamics. <br>You can see this in systems by simply trying to move very slow. You'll often notice that the output doesn't move it until you hit a certain threshhold. That threshhold is approximately equal to kS.<br>The static feed-forward affects output according to the simple equation of  <br><br>a kG value effectively represents the value needed for a system to negate gravity. <br>Elevators are the simpler case: You can generally imagine that since an elevator has a constant weight, it should take a constant amount of force to hold it up. This means the elevator Gravity gain is simply a constant value, affecting the output as  ; You don't need any other considerations regarding the system motion, because gravity is always constant. <br>A more complex kG calculation is needed for pivot or arm system. You can get a good sense of this by grabbing a heavy book, and holding it at your side with your arm down. Then, rotate your arm outward, fully horizontal. Then, rotate your arm all the way upward. You'll probably notice that the book is much harder to hold steady when it's horizontal than up or down.<br>The same is true for these systems, where the force needed to counter gravity changes based on the angle of the system. To be precise, it's maximum at horizontal, zero when directly above or below the pivot. Mathematically, it follows the function  ratio, lending this version of the feed-forward the nickname kCos.<br>This form of the gravity constant affects the output according to<br>
, where  is is the maximum output, at horizontal. <a data-footref="kcos" href="https://stormbots.github.io/KnowledgeBase/about:blank#fn-1-a15014395eb56229" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> <br><br>The velocity feed-forward represents the expected output to maintain a target velocity. This term accounts for physical effects like dynamic friction and air resistance, and a handful of  <br>This is most easily visualized on systems with a velocity goal state. In that case,  is easily known, and contributes to the output as  .<br>In contrast, for positional control systems, knowing the desired system velocity is quite a challenge. In general, you won't know the target velocity unless you're using a <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to to generate the instantaneous velocity target. <br><br>The acceleration feed-forward largely negates a few inertial effects. It simply provides a boost to output to achieve the target velocity quicker.<br>like ,  is typically only known when you're working with <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>. <br><br>Putting this all together, it's helpful to de-mystify the math happening behind the scenes.<br>The short form is just a re-clarification of the terms and their units<br>
: Output to overcome gravity ()<br>
: Output to overcome static friction ()<br>
: Output per unit of target velocity ()<br>
: Output per unit of target acceleration ()<br>A roller system will often simply be<br>
If you don't have a motion profile, kA will simply be zero, and and kS might also be negligible unless you plan to operate at very low RPM.<br>An elevator system will look similar:<br>
Without a motion profile, you cannot properly utilize kV and kA, which simplifies down to<br>
where  is generally derived by  (since you know the current and previous positions).<br>Lastly, elevator systems differ only by the cosine term to scale kG.<br>
Again simplifying for systems with no motion profile, you get<br>
It's helpful to recognize that because the angle is being fed to a  function, you cannot use degrees here! Make sure to convert. <br>Of course, the intent of a feed-forward is to model your mechanics to improve control. As your system increases in complexity, and demands for precision increase, optimal control might require additional complexity! A few common cases: <br>
<br>If you have a pivot arm that extends, your kG won't be constant! 
<br>Moving an empty system and one loaded with heavy objects might require different feed-forward models entirely.
<br>Long arms might be impacted by motion of systems they're mounted on, like elevators or the chassis itself! You can add that in and apply corrective forces right away.
<br><br>Since a feed-forward is prediction about how your system behaves, it works very well for fast, responsive control. However, it's not perfect; If something goes wrong, your feed-forward simply doesn't know about it, because it's not measuring what actually happens. <br>In contrast, feed-back controllers like a  <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> are designed to act on the error between a system's current state and target state, and make corrective actions based on the error. Without first encountering system error, it doesn't do anything.<br>The combination of a feed-forward along with a feed-back system is the power combo that provides robust, predictable motion.<br><br>WPILib has several classes that streamline the underlying math for common systems, although knowing the math still comes in handy! The docs explain them (and associated warnings) well.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br>Integrating in a robot project is as simple as crunching the numbers for your feed-forward and adding it to your motor value that you write every loop.<br>ExampleSystem extends SubsystemBase(){

	SparkMax motor = new SparkMax(...)
	// Declare our FF terms and our object to help us compute things.
	double kS = 0.0;
	double kG = 0.0;
	double kV = 0.0;
	double kA = 0.0;
	ElevatorFeedforward feedforward = new ElevatorFeedforward(kS, kG, kV, kA);
	
	ExampleSubsystem(){}

	Command moveManual(double percentOutput){
		return run(()-&gt;{
			var output ;
			//We don't have a motion profile or other velocity control
			//Therefore, we can only assert that the velocity and accel are zero
			output = percentOutput+feedforward.calculate(0,0);
			// If we check the math, this feedforward.calculate() thus 
			// evaluates as simply kg;
			
			// We can improve this by instead manually calculating a bit
			// since we known the direction we want to move in
			output = percentOutput + Math.signOf(percentOutput) + kG;
			motor.set(output);
		})
	}

	Command movePID(double targetPosition){
		return run(()-&gt;{
			//Same notes as moveManual's calculations 
			var feedforwardOutput = feedforward.calculate(0,0);
			// When using the Spark closed loop control, 
			// we can pass the feed-forward directly to the onboard PID
			motor
			.getClosedLoopController()
			.setReference(
				targetPosition,
				ControlType.kPosition,
				ClosedLoopSlot.kSlot0,
				feedforwardOutput, 
				ArbFFUnits.kPercentOut
			);
			//Note, the ArbFFUnits should match the units you calculated!
		})
	}

	Command moveProfiled(double targetPosition){
		// This is the only instance where we know all parameters to make 
		// full use of a feedforward.
		// Check [[Motion Profiles]] for further reading
	}
	
}
<br>2026 update?
Rev released a new FeedForward config API that might allow advanced feed-forwards to be run directly on controller. Look into it and add examples!<br>
<a rel="noopener nofollow" class="external-link" href="https://codedocs.revrobotics.com/java/com/revrobotics/spark/config/feedforwardconfig" target="_blank">https://codedocs.revrobotics.com/java/com/revrobotics/spark/config/feedforwardconfig</a>
<br><br>High gains
When tuning feed-forwards, it's helpful to recognize that values being too high will result in notable problems, but gains being too low generally result in lower performance.<br>
Just remember that the lowest possible value is 0; Which is equivalent to not using that feed forward in the first place. Can only improve from there. 
<br>FeedForward Units
It's worth clarifying that the "units" of feedForward are usually provided in "volts", rather than "percent output". This allows FeedForwards to operate reliably in spite of changes of supply voltage, which can vary from 13 volts on a fresh battery to ~10 volts at the end of a match.<br>
Percent output on the other hand is just how much of the available voltage to output; This makes it suboptimal for controlled calculations in this case. 
<br><br>These two terms are defined at the boundary between "moving" and "not moving", and thus are closely intertwined. Or, in other words, they interfere with finding the other. So it's best to find them both at once.<br>It's easiest to find these with manual input, with your controller input scaled down to give you the most possible control.<br>Start by positioning your system so you have room to move both up and down. Then, hold the system perfectly steady, and increase output until it just barely moves upward. Record that value.<br>
Hold the system stable again, and then decrease output until it just barely starts moving down. Again, record the value. <br>Thinking back to what each term represents, if a system starts moving up, then the provided input must be equal to ; You've negated both gravity and the friction holding it in place. Similarly, to start moving down, you need to be applying . This insight means you can generate the following two equations  <br><br>Helpfully, for systems where  like roller systems, several terms cancel out and you just get  .<br>For pivot/arm systems, this routine works as described if you can calculate kG at approximately horizontal. It cannot work if the pivot is vertical. If your system cannot be held horizontal, you may need to be creative, or do a bit of trig to account for your recorded  being decreased by <br>Importantly, this routine actually returns a kS that's often slightly too high, resulting in undesired oscillation. That's because we recorded a minimum that causes motion, rather than the maximum value that doesn't cause motion. Simply put, it's easier to find this way. So, we can just compensate by reducing the calculated kS slightly; Usually multiplying it by 0.9 works great. <br><br>Because this type of system system is also relatively linear and simple, finding it is pretty simple. We know that , and expect . <br>We know  is going to be constrained by our motor's maximum RPM, and that maxOutput is defined by our api units (either +/-1.0 for "percentage" or +/-12 for "volt output"). <br>This means we can quickly assert that  should be pretty close to . <br><br>Beyond roller kV, kA and kV values are tricky to identify with simple routines, and require <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to take advantage of. As such, they're somewhat beyond the scope of this article.<br>The optimal option is using <a data-href="System Identification" href="https://stormbots.github.io/KnowledgeBase/level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a> to calculate the system response to inputs over time. This can provide optimal, easily repeatable results. However, it involves a lot of setup, and potentially hazardous to your robot when done without caution.<br>The other option is to tune by hand; This is not especially challenging, and mostly involves a process of moving between goal states, watching graphs, and twiddling numbers. It usually looks like this:<br>
<br>Identify two setpoints, away from hard stops but with sufficient range of motion you can hit target velocities. 
<br>While cycling between setpoints, ihen increase kV until the system generates velocities that match the target velocities. They'll generally lag behind during the accelleration phase. 
<br>Then, increase kA until the accelleration shifts and the system perfectly tracks your profile. 
<br>Increase profile constraints and and repeat until system performance is attained. Starting small and slow prevents damage to the mechanics of your system.
<br>This process benefits from a relatively low P gain, which helps keep the system stable. Once your system is tuned, you'll probably want a relatively high P gain, now that you can assert the feed-forward is keeping your error close to zero. <br><br>
<br>
<br>Note, you might observe that the kCos output,   is reading the current system state, and say "hey!  That's a feed back system, not a feed forward!" and you are technically correct; the best kind of correct. However, kCos is often implemented this way, as it's much more stable than the feed-forward version. In that version, you apply , regardless of what  happens to actually be. Feel free to do a thought experiment on how this might present problems in real-world systems.<a href="https://stormbots.github.io/KnowledgeBase/about:blank#fnref-1-a15014395eb56229" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
FeedForwards<br><br>Superstructure component that holds a large amount of kinetic energy at a high velocity. Typically part of a subsystem oriented at launching game pieces.<br><br>
<br>Create a Flywheel system
<br>Tune with appropriate FeedForwards + PID to hit and maintain target RPMs 
<br>


<br><br>In some senses, none: A "Flywheel" is technically a spinning mass that provides inertial power to linked systems. We often add flywheels to our shooter rollers to add mass and make shots more consistent. <br> In FRC, we often use the term "flywheel subsystem" to help disambiguate the "spinning mass" part of a shooter from the "angular adjustment" part of a shooter. Otherwise, without good nomencalture, both parts get called "shooter", which is relatively unhelpful and can make things a bit confusing.<br>However, there's also physical differences in control and intent. The extra mass requires significantly more energy, resulting in either slower spinup, or much more power draw that can brown out your robot. We're also adding this inertia to stabilize shots, implying a desire for accuracy, precision, and consistency. In other words, this is very deep in the zone of performance tuning.<br><br>When spinning up a high-inertia system, the power draw can be incredible, typically pulling the full allotted power for all motors involved. <br>If we consider a brand new FRC battery, they have a rated capacity of 300A; A single FRC motor will pull 80-100A of that. If we have two motors, we'll pull 160A-200A. Keeping in mind we  have  other motors doing other things, especially 4 motors doing driving, you can easily sag the system voltage, causing loss of power and browning out one or more critical components. <br>Because of this, it's often a strategic choice on how how to handle power. Some teams (1540) advise just removing all power constraints: The reasoning is that by giving unlimited power to your flywheels, you get them up to speed quickly, trusting that the voltage sag is short enough that the various power regulation systems can recover properly.<br>
Other teams implement dynamic voltage constraints; Polling the various robot systems, and allocating power according to current system draw, and subsystem needs. <br>Both methods are worth considering, and both have been done on Stormbots in various seasons.<br><br>When operating with flywheels, the ideal behavior is simply to never have to change velocity. Theoretically, if the velocity doesn't change, you don't use power. <br>In reality, this is impossible ; Air resistance, bearing friction, motor internal resistance, and precession all work to sap flywheel energy and speed.  And of course, every time we change speed, we're using power from our battery. <br>It's also kind of unsafe to keep flywheels spinning at extremely high velocities all the time, and we often need to change velocity for different shots anyway.<br>As such, it's good practice to consider what to do when not shooting. This will change each season and each robot, and might change based on how a game involves. But, good considerations include:<br>
<br>Can we idle to a slower, safer speed instead of stopping? 
<br>Coasting to slow down rather than using brake or active PIDs
<br>When a shot is abandoned, can we maintain shooting speed for a time to prevent a need for significant adjustment a short time later?
<br>Can we give drivers options to boost RPM in advance?
<br>The goal is to maximize safety, minimize lag between driver + action, and minimize total speed adjustments. <br><br>For precision velocity control, the <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> model, <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> tunings, and <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profile</a> are all very important. You mostly need to get and maintain the target RPM extremely quickly, while  minimizing overall settle time. <br>In some cases, you might actually find that minor PID overshoot doesn't cause problems, and can result in quicker time-to-target and overall settling.<br>Sometimes, using SysID can help you; This is a program that runs some test procedures, using the resulting physical measurements to analyze system response, and thus generate PID and FF values. If set up correctly, these values can be fed back into your robot config, helping you quickly account for hardware changes, wheel wear, and other factors that might have impacted your system performance.<br>Instead of painful precision tuning via graphs, implementing SysID into your java code can let you run these similar to an Auto sequence, letting you respond quickly to emergency repairs during competition. <br>Title
See Crescendo's robot code for examples on automated flywheel tuning procedures
<br>Note, that the recommended approach is still to do good feed-forward modelling and motion profiles before PID tuning. With this setup, it's likely that you can use relatively large PI values for getting up to target speeds, and PD terms and flywheel inertia will resolve in good disturbance rejections.<br><br>Drivers need to know when they can utilize an on-target flywheel. When in performance mode, they will be cutting every corner for performance, and their trust in robot feedback is crucial. Unfortunately, RPM is largely invisible to drivers in competitions. <br>In these cases, the robot's best feedback source is a <a data-tooltip-position="top" aria-label="Subsystem Lighting" data-href="Subsystem Lighting" href="https://stormbots.github.io/KnowledgeBase/Subsystem Lighting" class="internal-link" target="_self" rel="noopener nofollow">LED Subsystem</a> ; Simply have the bot  lighting give the all-clear to fire. In practice, this helps the drivers get a "feel" for spinup time, and in competitions gives them certainty that a shot will work as expected. <br>Note, that the feedback itself can be challenging: Remember, the goal is "will our shot make it" more than "Is the shooter at the target RPM". Some notable considerations:<br>
<br>Sometimes far-away shots at higher velocities only succeed with a lower RPM error than closer, nearby ones going at a slower speed. 
<br>Overshoot/undershoot might fall within an permissible, but cause missed shots due to how the acceleration affects the physics.
<br>Flywheel speed is only one aspect; You also have robot ground speed, rotational speed, and (possibly) the angle of your shooter configuration. Drivers must know what is and isn't accounted for.
<br>At the end of the day, your system might simply green-light a good RPM range and be good enough. Or, you might need to create a complex state machine to track and count system stability and settle time, or chain boolean logic for other conditions. <br>Whatever you do, your efforts put toward driver indicators will always be in vain if your drivers don't trust it. These systems require good communication with drivers to establish the trust boundaries for indicators, and to maintain that trust with accurate signals.<br><br>When working with a fixed-angle shooter, your system will always have to account for shot distance by adjusting RPM continuously. If RPM adjustment won't work, you simply can't make make a shot. <br>However, when given an adjustable angle shooter (see 2024 robot), programmers have 2 control axes to resolve shot distance. This allows a great amount of freedom in what a shot looks like. This lets us apply our design criteria, and consider our options:<br>
<br>Fix the angle, and have dynamic RPM adjustment
<br>Fix the RPM, and adjust the angle
<br>Adjust both at once all the time. 
<br>With the last one ruled out, you probably  want to consider which parameter to lock in place to optimize shots for a given area. In most cases, the best approach is to use an interpolating <a data-tooltip-position="top" aria-label="Lookup Tables" data-href="Lookup Tables" href="https://stormbots.github.io/KnowledgeBase/level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Table</a> (LUT). This allows you to convert a given known value (usually distance) into a tested combination of angle and distance. <br>Such a table can be very quickly generated using practice field elements, and provides very robust performance. With good distance spacing, you can quickly fix problem zones, and then nature of a LUT allows you to seamlessly switch between which output is fixed..<br><br>This is an ongoing advanced topic, and in early stages: <a data-href="Flight Trajectory Calculations" href="https://stormbots.github.io/KnowledgeBase/level-2/flight-trajectory-calculations.html" class="internal-link" target="_self" rel="noopener nofollow">Flight Trajectory Calculations</a><br><br><a data-href="System Identification" href="https://stormbots.github.io/KnowledgeBase/level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a><br>
<a data-href="Lookup Tables" href="https://stormbots.github.io/KnowledgeBase/level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>SuperStructure Flywheel<br><br>
<br>


<br>Advanced computation for calculating optimal shot angles and rpmsFlight Trajectory Calculations<br><br>Requires<br>
<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Create a PID system on a test bench
<br>Tune necessary PIDs using encoders
<br>Set a velocity using a PID
<br>Set a angular position using a PID
<br>Set a elevator position using a PID
<br>Plot the system's position, target, and error as you command it.
<br><br>TODO:<br>
Add some graphs<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/DylanHojnoski/obsidian-graphs" target="_blank">https://github.com/DylanHojnoski/obsidian-graphs</a><br>
Write synopsis<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/revlib/spark/closed-loop" target="_blank">https://docs.revrobotics.com/revlib/spark/closed-loop</a><br><br>A PID system is a <a data-href="Closed Loop Controller" href="https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controller</a> designed to reduce system error through a simple, efficient mathematical approach.<br>You may also appreciate Chapter 1 and 2 from <a data-href="controls-engineering-in-frc.pdf" href="https://stormbots.github.io/KnowledgeBase/misc/controls-engineering-in-frc.pdf" class="internal-link" target="_self" rel="noopener nofollow">controls-engineering-in-frc.pdf</a> , which covers PIDs very well. <br><br><br><br>Often in robotics, we care a lot about the final state of a system: The position it's at, the rate it's going, the height of an elevator, etc. <br>However, the process of getting and maintaining this target state might not be trivial. It might require a variety of motor outputs to get there, change over time,  or be unpredictable due to external factors like game piece weight.<br>A closed loop controller is designed to manage exactly this. Instead of simply setting the output directly (a motor speed), we can instead provide a setpoint, representing the target state of our system. This can be a position, rate, temperature, brightness, or any other  measurable quantity. It's sometimes considered the "goal state".<br>A closed loop controller's job is to then manage the measured quantity and adjust the output to maintain that setpoint. In technical terms, we "feed back" the output as an input to this controller, forming a "closed loop" in our process diagram.<br><img alt="open-loop-closed-loop-diagram.png" src="https://stormbots.github.io/KnowledgeBase/assets/open-loop-closed-loop-diagram.png"><br><br>Before getting started, we  need to identify a few things: <br>
<br>A setpoint: This is the goal state of your system. This will have units in that target state, be it height, meters, rotations/second, or whatever you're trying to do. 
<br>An output: This is often a motor actuator, and likely 
<br>A measurement: The current state of your system from a sensor; It should have the same units as your Setpoint.
<br>Controller: The technical name for the logic that is controlling the motor output. In our case, it's a PID controller, although many types of controllers exist.
<br><br>To get an an intuitive understanding about PIDs and feedback loops, it can help to start from scratch, and kind of recreating it from the basic assumptions and simple code.<br>Let's start from the core concept of "I want this system to go to a position and stay there". <br>Initially, you might simply say "OK, if we're below the target position, go up.  If we're above the target position, go down." This is a great starting point, with the following pseudo-code.<br>setpoint= 15  //your target position, in arbitrary units
sensor= 0 //Initial position
if(sensor &lt; setpoint){ output = 1 }
else if(sensor &gt; setpoint){ output = -1 }
motor.set(output)
<br>However, you might see a problem. What happens when setpoint and sensor are equal? <br>If you responded with "It rapidly switches between full forward and full reverse", you would be correct. If you also thought "This sounds like it might damage things", then you'll understand why this controller is named a "Bang-bang" controller, due to the name of the noises it tends to make.<br>Your instinct for this might be to simply not go full power. Which doesn't solve the problem, but reduces it's negative impacts. But it also creates a new problem. Now it's going to oscillate at the setpoint (but less loudly), and it's also going to take longer to get there.<br>So, let's complicate this a bit. Let's take our previous bang-bang, but split the response into two different regions: Far away, and closer. This is easier if we introduce a new term: Error. Error just represents the difference between our setpoint and our sensor, simplifying the code and procedure. "Error" helpfully is a useful term, which we'll use a lot.<br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	error = setpoint-sensor 
	if     (error &gt; 5){ output = -1 }
	else if(error &gt; 0){ output = -0.2 }
	else if(error &lt; 0){ output = 0.2 }
	else if(error &lt; -5){ output = 1 }
	motor.set(output)
})
<br>We've now slightly improved things; Now, we can expect more reasonable responses as we're close, and fast responses far away. But we still have the same problem; Those harsh transitions across each else if. Splitting up into more and more branches doesn't seem like it'll help. To resolve the problem, we'd need an infinite number of tiers, dependent on how far we are from our targets. <br>With a bit of math, we can do that! Our error term tells us how far we are, and the sign tells us what direction we need to go... so let's just scale that by some value. Since this is a constant value, and the resulting output is proportional to this term, let's call it kp: Our proportional constant. <br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	kp = 0.1
	error = setpoint-sensor 
	output = error*kp
	motor.set(output)
)}
<br>Now we have a better behaved algorithm! At a distance of 10, our output is 1. At 5, it's half. When on target, it's zero! It scales just how we want. <br>Try this on a real system, and adjust the kP until your motor reliably gets to your setpoint, where error is approximately zero. <br>In doing so, you might notice that you can still oscillate around your setpoint if your gains are too high. You'll also notice that as you get closer, your output drops to zero. This means, at some point you stop being able to get closer to your target. <br>This is easily seen on an elevator system. You know that gravity pulls the elevator down, requiring the motor to push it back up. For the sake of example, let's say an output of 0.2 holds it up. Using our previous kP of 0.1, a distance of 2 generates that output of 0.2. If the distance is 1, we only generate 0.1... which is not enough to hold it! Our system actually is only stable below where we want. What gives! <br> This general case is referred to as "standing error" ; Every loop through our PID fails to reduce the error to zero, which eventually settles on a constant value. So.... what if.... we just add that error up over time? We can then incorporate that error into our outputs. Let's do it.<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
kp = 0.1
ki = 0.001
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	output = error*kp + errorsum*ki
	motor.set(output)
}
<br>The mathematical operation involved here is called integration, which is what this term is called. That's the "I" in PID.<br>
In many practical FRC applications, this is probably as far as you need to go! P and PI controllers can do a lot of work, to suitable precision. This a a very flexible, powerful controller, and can get "pretty good" control over a lot of mechanisms. <br>This is probably a good time to read across the  <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" target="_blank">WPILib PID Controller</a>  page; This covers several useful features. Using this built-in PID, we can reduce our previous code to a nice formalized version that looks something like this.<br>PIDController pid = new PIDController(kP, kI, kD);
run(()-&gt;{
	sensor = motor.getEncoder.getPosition();
	motor.set(pid.calculate(sensor, setpoint))
})
<br>A critical detail in good PID controllers is the iZone or ErrorZone. We can easily visualize what problem this is solving by just asking "What happens if we get a game piece stuck in our system"?<br>
Well, we cannot get to our setpoint. So, our errorSum gets larger, and larger.... until our system is running full power into this obstacle. That's not great. Most of the time, something will break in this scenario. <br>So, the iZone allows you to constrain the amount of error the controller actually stores. It might be hard to visualize the specific numbers, but you can just work backward from the math. If output = errorsum*kI, then maxIDesiredTermOutput=iZone*kI. So iZone=maxIDesiredTermOutput/kI.<br>Lastly, what's the D in PID?<br>Well, it's less intuitive, but let's try. Have you seen the large spike in output when you change a setpoint? Give the output a plot, if you so desire. For now, let's just reason through a system using the previous example PI values, and a large setpoint change resulting in an error of 20. <br>Your PI controller is now outputting a value of 2.0 ; That's double full power! Your system will go full speed immediately with a sharp jolt, have a ton of momentum at the halfway point, and probably overshoot the final target. So, what we want to do is constrain the speed; We want it fast but not too fast. So, we want to reduce it according to how fast we're going.<br>
Since we're focusing on error as our main term, let's look at the rate the error changes. When the error is changing fast we want to reduce the output. The difference is simply defined as error-previousError, so a similar strategy with gains gives us output+=kP*(error-previousError) .<br>
This indeed gives us what we want: When the rate of change is high, the contribution is negative and large; Acting to reduce the total output, slowing the corrective action.<br>However, this term has another secret power, which disturbance rejection. Let's assume we're at a steady position, and the system is settled, and error=0. Now, let's bonk the system downward, giving us a sudden large, positive error. Suddenly nonzero-0 is positive, and the system generates a upward force. For this interaction, all components of the PID are working in tandem to get things back in place quickly.<br>Adding this back in, gives us the fundamental PID loop:<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
lastSensor=0
kp = 0.1
ki = 0.001
kd = 0.01
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	errordelta = sensor-lastSensor
	lastSensor=sensor
	output = error*kp + errorsum*ki + errordelta*kd
	motor.set(output)
}
<br><br>OK, that's enough nice things. Understanding PIDs requires knowing when they work well, and when they don't, and when they actually cause problems. <br>
<br>PIDs are reactive, not predictive. Note our key term is "error" ; PIDs only act when the system is already not where you want it, and must be far enough away that the generated math can create corrective action.
<br>Large setpoint changes break the math. When you change a setpoint, the P output gets really big, really fast, resulting in an output spike. When the PID is acting to correct it, the errorSum for the I term is building up, and cannot decrease until it's on the other side of the setpoint. This almost always results in overshoot, and is a pain to resolve.  
<br>Oscillation: PIDs inherently generate oscillations unless tuned perfectly. Sometimes big, sometimes small.
<br>D term instability: D terms are notoriously quirky. Large D terms and velocity spikes can result in bouncy, jostly motion towards setpoints, and can result in harsh, very rapid oscillations around the zero, particularly when systems have significant <a data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanical Backlash</a>.
<br>PIDS vs Hard stops: Most systems have one or more <a data-href="Hard Stops" href="https://stormbots.github.io/KnowledgeBase/level-1/hard-stops.html" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a>, which present a problem to the I term output. This requires some consideration on how your encoders are initialized, as well as your setpoints.
<br>Tuning is either simple....or very time consuming.
<br>Only works on "Linear" systems: Meaning, systems where the system's current state does not impact how the system responds to a given output. <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> are an example of a non-linear system, and to a given output very differently when up and horizontally. These cannot be properly controlled by just a PID. 
<br>So, how do you make the best use of PIDs?<br>
<br>Reduce the range of your setpoint changes. There's a few ways to go about it, but the easiest are <a data-href="clamping" href="https://stormbots.github.io/KnowledgeBase/misc/clamping.html" class="internal-link" target="_self" rel="noopener nofollow">clamping</a> changes, <a data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a> and <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> . With such constraints, your error is always small, so you can tune more aggressively for that range. 
<br>Utilize <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> to create the basic action; Feed-forwards create the "expected output" to your motions, reducing the resulting error significantly. This means your PID can be tuned to act sharply on disturbances and unplanned events, which is what they're designed for.
<br>In other words: This is an error correction mechanism. By reducing or controlling the initial error a PID would act on, you can greatly simplify the PID's affect on your system, usually making it easier to get better motions. Using a PID as the "primary action" for a system might work, but tends to generate unexpected challenges.<br><br>Tuning describes the process of dialing in our "gain values"; In our examples, we named these kP, kI, and kD. These values don't change the process of our PID, but it changes how it responds.<br>There's actually several "formal process" for tuning PIDs; However, in practice these often are more complicated and aggressive than we really want. You can read about them if you'd like <a data-tooltip-position="top" aria-label="https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_(Woolf)/09%3A_Proportional-Integral-Derivative_(PID)_Control/9.03%3A_PID_Tuning_via_Classical_Methods" rel="noopener nofollow" class="external-link" href="https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_(Woolf)/09%3A_Proportional-Integral-Derivative_(PID)_Control/9.03%3A_PID_Tuning_via_Classical_Methods" target="_blank">PID Tuning via Classical Methods</a><br>In practice though, the typical PID tuning process is more straightforward, but finicky.<br>
<br>Define a small range you want to work with: This will be a subset of 
<br>Create a plot of your setpoint, current state/measurements, and system output. <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a> is usually good enough here.
<br>Starting at low values, increase the P term until your system starts to oscillate near the goal  state. Reduce the P term until it doesn't. Since you can easily 
<br>Add an I term, and increase the value until your system gets to the goal state with minimal overshoot. Often I terms should start very small; Often around 1%-10% of your P term. Remember, this term is summed every loop; So it can build up very quickly when the error is large. 
<br>If you're tuning a shooter system, get it to target speed, and feed in a game piece; Increase the D term until you maintain the RPM to an effective extent. 
<br>Rev Velocity Filtering
Rev controllers by default implement a velocity filter, making it nearly impossible to detect rapid changes in system velocity. This in turn makes it nearly impossible to tune a D-term.<br>
<a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a> Document how to remove these filters
<br>Hazards of Tuning
Be aware that poorly tuned PIDs might have very unexpected, uncontrolled motions, especially when making big setpoint changes.<br>
They can jolt unexpectedly, breaking chains and gearboxes. They can overshoot, slamming into endstops and breaking frames. They'll often oscillate shaking loose cables, straps, and stressing your robot.<br>
Always err on the side of making initial gains smaller than expected, and focus on safety when tuning. 
<br>Setpoint Jumps + Disabled robots
Remember that for PID systems the setpoint determines motor output;  If the bot  is disabled, and then re-enabled, the bot will actuate to the setpoint!<br>
Make sure that your bot handles re-enabling gracefully; Often the best approach is to re-initialize the setpoint to the bot's current position, and reset the PID controller to clear the I-term's error sum.
<br><br>In seasons past, a majority of our programming time was just fiddling with PID values to get the bot behaviour how we want it. This really sucks. Instead, there's more practical routines to avoid the need for precision PID tuning. <br>
<br>Create a plot of your setpoint, current state/measurements, and system output. <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a> is usually good enough here.
<br>Add a <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> : It doesn't have to be perfect, but having a basic model of your system massively reduces the error, and significantly reduces time spent fixing PID tuning. This is essential for Arms; The FeedForward can easily handle the non-linear aspects that the PID struggles with.
<br>In cases where game pieces contribute significantly to the system load, account for it with your FeedForward: Have two different sets of FeedForward values for the loaded and unloaded states
<br>Use <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>: A Trapezoidal profile is optimal and remarkably straightforward. This prevents many edge cases on PIDs such as sharp transitions and overshoot. It provides very controlled, rapid motion. 

<br>Alternatively, reduce setpoint changes through use of a Ramp Rate or <a data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a>. This winds up being as much or more work than Motion Profiles with worse results, but can be easier to retrofit in existing code.
<br>An even easier and less effective option is simply <a data-tooltip-position="top" aria-label="clamping" data-href="clamping" href="https://stormbots.github.io/KnowledgeBase/misc/clamping.html" class="internal-link" target="_self" rel="noopener nofollow">Clamp</a> clamp the setpoint within a small range around the current state. This provides a max error, but does not eliminate the sharp transitions.


<br>Set a very small ClosedLoopRampRate; Just enough to prevent high-frequency oscillations, which will tend to occur when the setpoint is at rest, especially against <a data-href="Hard Stops" href="https://stormbots.github.io/KnowledgeBase/level-1/hard-stops.html" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a> or if <a data-tooltip-position="top" aria-label="Mechanical Backlash" data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Backlash</a> is involved. This is just a <a data-tooltip-position="top" aria-label="Slew Rate Limiting" data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiter</a> being run on the motor controller against the output.
<br>From here, the actual PID values are likely to barely matter, making tuning extremely straightforward: <br>
<br>Increase the P term until you're on target through motions and not oscillating sharply at rest
<br>Find a sensible output value that fixes static/long term disturbances (change in weight, friction, etc). Calculate the target iZone  to a sensible output just above what's needed to fix those. 
<br>Start with I term of zero; Increase the I term if your system starts lagging during some long motions, or if it sometimes struggles to reach setpoint during
<br>If your system is expected to maintain it's state through predictable disturbances (such as maintaining shooter RPM when launching a game piece), test the system against those disturbances, and increase the D term as needed. You may need to decrease the P term slightly to prevent oscillations when doing this.
<br>Watch your plots. A well tuned system should 

<br>Quickly approach the target goal state
<br>Avoid overshooting the target
<br>Settle on a stable output value
<br>Recover to the target goal state (quickly if needed)


<br><br>
<br>Discontinuity + setpoint wrappping for PIDs + absolutes
<br>
PID<br><br>One of <br>
<br><a data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a>
<br><a data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a>
<br><br>Requires:<br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>Recommends:<br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create a Roller serving as a simple intake
<br>Create Commands for loading, ejecting, and stopping
<br>Create a default command that stops the subsystem
<br>Bind the load and eject operations to a joystick
<br>Optional Bonus criteria: <br>
<br>Configure the Roller to use RPM instead of setPower
<br>Add a FeedForward and basic PID
<br>Confirm the intake roughly maintains the target RPM when intaking/ejecting
<br><br>A Roller system is a simple actuator type: A single motor output mechanically connected to a rotating shaft. Objects contacting the shaft forms the useful motion of a Roller system. This can also extended with additional shafts, belts, or gearing to adjust the contact range.<br>Despite the simplicity, Rollers are very flexible and useful systems in FRC. When paired with clever mechanical design, Rollers can accomplish a wide variety of game tasks, empower other system types, and serve as the foundation of more complex systems.<br><br>On their own, rollers can be designed to serve a few functions <br>
<br>Fixed position <a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intakes</a>, responsible for pulling objects into a robot
<br>Simple scoring mechanisms for ejecting a game piece from the bot
<br>Simple launchers game pieces from the robot at higher speeds
<br>As motion systems to move game pieces through the bot
<br>As a simple feeder system for allowing or blocking game piece motion within the bot.
<br>Rollers of this nature are very common on Kitbot designs, owing to the mechanical simplicity and robustness of these systems. <br>For more complex bots, Roller systems are usually modified with extra mechanical features or actuated. These include<br>
<br>A <a data-tooltip-position="top" aria-label="SuperStructure Flywheel" data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">Flywheel</a> system, which provides more accurate launching of game pieces through precision control and increased momentum
<br>As <a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexers/Feeder/Passthrough</a>, providing precision control of game pieces through a bot.
<br>As actuated <a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intakes</a>, often with rollers attached to <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> or linkages<br>
These documents discuss the special considerations for improving Rollers in those applications.
<br><br><br>In keeping with a Roller being a simple system, they're simple to implement: You've already done this with <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>.<br>To integrate a Roller system into your bot code, there's simply a few additional considerations:<br>
<br>The function of your roller: This determines the role and name of your system. Like all subsystems, you want the name to be reflective of it's task, and unique to help clarify discussion around the system. 
<br>Level of control needed: Rollers often start simple and grow in complexity, which is generally preferred. But, sometimes you can tell that your system will get complicated, and it's worth planning for. 
<br>The base tasks this system performs. 
<br>sometimes a Roller system will serve multiple roles: Usually, it's good to recognize this early to facilitate naming and configuration.
<br>These are effectively what we see in <a data-href="Robot Design Analysis" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-design-analysis.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Design Analysis</a> , but especially pertinent for Roller systems. Since your system will likely have multiple rollers, naming them "Rollers" is probably a bad idea. Assigning good names to the roller system and the actions it performs will make your code easier to follow.<br>Rollers generally will have a few simple actions, mostly setting a power and direction, with appropriate names depending on the intent of the action:<br>
<br>Intake rollers usually have "intake", "eject", and "stop" which apply a fixed motor power. Larger game pieces might also have a "hold", which applies a lower power to keep things from shifting or falling out.
<br>Rollers in a Launcher role will usually have "shoot" and "stop", and rarely need to do much else.  
<br>Rollers serving as a "feeder" will usually alternate between the "launcher" and "intake" roles; So it'll need appropriate actions for both.
<br><br>Appropriately, a useful, minimal roller system is very straightforward, and done previously in <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>. But this time let's clean up names.<br>public Launcher extends SubsystemBase{
	SparkMax motor = new SparkMax(42,kBrushless);

	Launcher(){
		//Normal constructor tasks
		//Configure motor: See Motor Control for example code
		//Set the default command; In this case, just power down the roller
		setDefaultCommand(setPower(0)); //By default, stop
	}
	public Command setPower(double power){
		// Note use of a command that requires the subsystem by default
		// and does not exit
		return run(()-&gt;motor.set(power));
	}
	public Command launchNear(){
		return setPower(0.5);
	}
	public Command launchFar(){
		return setPower(1);
	}
}
<br>For most Roller systems, you'll want to keep a similar style of code structure: By having a setPower(...) command <a data-tooltip-position="top" aria-label="Code Patterns" data-href="Code Patterns" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html" class="internal-link" target="_self" rel="noopener nofollow">Factory</a>, you can quickly build out your other verbs with minimal hassle. This also allows easier testing, in case you have to do something like attach a <a data-tooltip-position="top" aria-label="Joysticks" data-href="Joysticks" href="https://stormbots.github.io/KnowledgeBase/misc/joysticks.html" class="internal-link" target="_self" rel="noopener nofollow">Joystick</a> to figure out the exact right power for a particular task. <br>In general, representing actions using named command factories with no arguments is preferable, and will provide the cleanest code base.  The alternatives such as making programmers remember the right number, or feeding constants into setPower will result in much more syntax and likelyhood of errors.<br>Having dedicated command factories also provides a cleaner step into modifying logic for certain actions. Sometimes later you'll need to convert a simple task into a short sequence, and this convention allows that to be done easily.<br><br>Without straying too far from a "simple" subsystem, there's still a bit we can do to resolve problems, prevent damage, or streamline our code.<br><br>Sometimes with Roller systems, you'll notice that the power needed to move a game piece often provides undesirable effects when initially contacting a game piece. Or, that sometimes a game piece loads wrong, jams, and the normal power setting won't move it.<br>This is a classic case where error correcting methods like <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>s shine! By switching your roller from a "set power" configuration to a "set rotational speed" one, you can have your rollers run at a consistent speed, adjusting the power necessary to keep things moving. <br>Notably though, PIDs for rollers are very annoying to dial in, owing to the fact that they behave very differently when loaded and unloaded, and even more so when they need to actually resolve an error condition like a jam!<br>
The use of a <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> aids this significantly: Feedforward values for rollers are extremely easy to calculate, and can model the roller in an unloaded, normal state. This allows you to operate "unloaded", with nearly zero error. When operating with very low error, your PID will be much easier to deal with, and much more forgiving to larger values.<br>You can then tune the P gain of your PID such that your system behaves as expected when loaded with your game piece. If the FF+P alone won't resolve a jamming issue, but more power will, you can add an I gain until that helps push things through.<br><br>Some Roller actions can be improved through the use of <a data-tooltip-position="top" aria-label="Sensing Basics" data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensors</a>, which generally detect the game piece directly. This helps rollers know when they can stop and end sequences, or select one of two actions to perform. <br>However, it is possible (although sometimes a bit tricky) to read the motor controller's built in sensors: Often the Current draw and encoder velocity. When attempting this, it's recommended to use <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> with a Debounce operation, which provides a much cleaner signal than directly reading these <br>You can also read the controller position too! Sometimes this requires a physical reference (effectively <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> a game piece), which allows you to assert the precise game piece location in the bot.<br>
In other cases you can make assertions solely from relative motion: Such as asserting if the roller rotated 5 times, it's no longer physically possible to still be holding a game piece, so it's successfully ejected.<br><br>Many Roller systems, particularly intakes will wind up with in one of two states: Loaded or Unloaded, with each requiring a separate conditional action.<br>The defaultCommand of a Roller system is a great place to use this, using the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> utility ConditionalCommand (akaeither ). A common case is to apply a "hold" operation when a game piece is loaded, but stop rollers if not.  <br>Implemented this way, you can usually avoid more complex <a data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a>, and streamline a great deal of code within other sequences interacting with your roller.<br><br>Some Roller systems will pull objects in, where the object hits a hard stop. This is most common on intakes. In all cases, you want to constrain the power such that nothing gets damaged when the roller pulls a game piece in and stalls.<br>Beyond that, in some cases you can set the current very low, and replace explicit hold() actions and sensors with just this lower output current. You simply run the intake normally, letting the motor controller apply an appropriate output current.<br>This is not common, but can be useful to streamline some bots, especially with drivers that simply want to hold the intake button to hold a game piece.<br><br>Should jams be possible in your roller system, encoder velocity and output current can be useful references, when combined with the consideration that <br>When a "jam" occurs, you can typicaly note <br>
<br>A high commanded power
<br>A high output current
<br>A low velocity
<br>//Current detection
new Trigger(()-&gt;motor.getAppliedOutput()&gt;=.7 &amp;&amp; motor.getOutputCurrent()&gt;4).debounce(0.2);
//Speed Detection
new Trigger(()-&gt;motor.getAppliedOutput()&gt;=.7 &amp;&amp; motor.getEncoder().getVelocity()&lt;300).debounce(0.2);
<br>However, care should be taken to ensure that these do not also catch the spin up time for motors! When a motor transitions from rest to  high speed, it also generates significant current, a low speed, and high commanded output.<br>Debouncing the trigger not only helps clean up the output signal, but for many simple Roller systems, they spin up quickly enough that the debounce time can simply be set higher than the spin up duration.SuperStructure Rollers<br><br><br>Superstructure component that adds additional control axes between intakes and scoring mechanisms. In practice, indexers often temporarily act as part of those systems at different points in time, as well performing it's own specialized tasks.<br> Common when handling multiple game pieces for storage and alignment, game pieces require re-orientation, adjustment or temporary storage, and for flywheel systems which need to isolate game piece motion from spinup.<br><br>
<br>???
<br><br>Setting up an indexer is often a challenging process. It will naturally inherit several design goals and challenges from the systems it's connected to. This means it will often have a more complex API than most systems, often adopting notation from the connected systems. <br>The Indexer is often sensitive to hardware design quirks and changes from those adjacent systems, which can change their behavior, and thus the interfacing code. <br>Additionally, game piece handoffs can be mechanically complex, and imperfect. Often Indexers absorb special handling and fault detection, or at least bring such issues to light. Nominally, any such quirks are identified and hardware solutions implemented, or additional sensing is provided to facilitate code resolutions.<br><br>Indexers typically require some specific information about the system state, and tend to be a place where some sort of sensor ends up as a core operational component. The exact type and placement can vary by archtype, but often involve <br>
<br>Break beam sensors: These provide a non-contact, robust way to check game piece 
<br>Current/speed sensing: Many game pieces can be felt by the 
<br>Superstructure Indexer<br>A shooter is simply a flywheel and supporting infrastructure for making game pieces fly from a robot<br><br>
<br>


<br>Typically a "shooter" consists of <br>
<br>a <a data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a> to serve as a mechanical means to maintain momentum
<br>A <a data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Indexer</a> to time shots and ensure the shooter is at the indended speed
<br>A targeting system, often using Odometry or Vision
<br>A trajectory evaluation to control target RPM. This can be fixed targets, <a data-href="Lookup Tables" href="https://stormbots.github.io/KnowledgeBase/level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>, or more complex trajectory calculations
Superstructure Shooter<br><br>Requires:<br>
<a data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br>Recommends:<br>
<a data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a><br>Requires as needed:<br>
<a data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
<a data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br><br>
<br>Create an "over the bumper" intake system
<br>Add a controller button to engage the intake process. It must retract when released
<br>The button must automatically stop and retract the intake when a game piece is retracted
<br><br>Intake complexity can range from very simple rollers that capture a game piece, to complex actuated systems intertwined with other scoring mechanisms. <br>A common "over the bumper" intake archetype is a deployed system that<br>
<br>Actuates outward past the frame perimeter
<br>Engages rollers to intake game piece
<br>Retracts with the game piece upon completion of a game piece
<br>The speed of deployment and retraction both impact cycle times, forming a critical competitive aspect of the bot. <br>The automatic detection and retraction provide cycle advantages (streamlining the driver experience), but also prevent fouls and damage due to the collisions on the deployed mechanism.<br>Intakes often are a <a data-tooltip-position="top" aria-label="Compound Subsystem" data-href="Compound Subsystem" href="https://stormbots.github.io/KnowledgeBase/level-1/compound-subsystem.html" class="internal-link" target="_self" rel="noopener nofollow">Compound Subsystem</a> , and come with several quirks for structuring and control<br><br>The major practical difference between intakes and other "subsystems" is their routine interaction with unknowns. Intake arms might extend into walls, intake rollers might get pressed into a loading station, and everything is approaching game pieces in a variety of speeds and states. Every FRC intake is different, but this one aspect is consistent.<br>Good mechanical design goes a long way to handling unknowns, but programming is affected too.  Programming a robust intake demands identifying and resolving ways that these interactions can go wrong, and resolving them in a way that leaves the robot in an operational state (and preferably, with a game piece). Sometimes this is resolved in code, and sometimes requires hardware or design tweaks. Intakes tend to have more physical iterations than many other parts of the robot.<br><br>For most intakes, you want a clear confirmation that the intake process is Done and a game piece is loaded. This typically means reviewing the mechanical design, and identifying what, if any, sensing methods will work reliably to identify successful intake.<br>Common approaches are<br>
<br>Break beams / Range finders like <a data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">LaserCan</a> : Since these sensors are non-contact, they provide a easy to use, and relatively safe way to interact with game pieces with little design overhead. 
<br>A backplate with a switch/button: This requires special mechanical design, but gives a simple boolean state to indicate successful loading. This typically only works with intakes that interact with a back-stop, but can be made to work with other mechanisms that can actuate a switch when objects are in a known position
<br>Current Detection: This is a common option for intakes that pull in directly into a backstop, particularly for rigid game pieces. Like other places where current detection is used, it's either trivial + very effective, or ineffective + extremely challenging, depending on the design and interactions. 
<br>Speed/Stall Detection: Like above but measuring roller speed rather than motor current. 
<br>A good understanding of <a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a> , and familiarity with our other sensors available will go a long way to making a robust intake.<br><br>When intaking objects, many things can go wrong with. Here's a quick list of considerations:<br>
<br>A game piece can be oriented wrong, jamming the intake.
<br>A game piece can be loaded from weird angles or during unexpected motions, jamming the intake
<br>A game piece can be loaded at the edge of the intake, binding against mechanical supports
<br>A game piece load can be interrupted by drivers, leaving the intake in a "default command" state  while half-loaded
<br>A game piece can be damaged, loading in incorrectly or binding
<br>A game piece can be stretched/deformed inside the bot or intake
<br>A game piece can be smaller/larger than originally expected, causing various effects
<br>The game piece can be damaged due to excess force when stalled/jammed
<br>The game piece can be damaged due to initial contact with rollers at a high speed
<br>The intake can be extended past frame perimeter, and then slam into a wall
<br>The intake can be extend past the frame perimeter into a wall. 
<br>The rollers can jam against an intake pressed against a wall
<br>The rollers+game piece can force other systems into unexpected angles due to wall/floor/loading station interactions
<br>Intakes can fling past the robot perimeter during collisions, colliding with other robots (collecting fouls or snagging wires)
<br>Murphy's law applies! If anything can go wrong, it will. When testing, you might be tempted to assume errors are a one-off, but instead record them and try to replicate errors as part of your testing routine. It's easier to fix at home than it is in the middle of a competition. <br>When coding, pay close attention to <br>
<br>Expected mechanism currents: Make sure that your intake is operating with reasonable current limits, and set high enough to work quickly, but low enough to prevent harm when something goes wrong.
<br>Intake Default Commands: Ideally, the code for your intake should ensure the system ends up in a stable, safe resting location.
<br>The expected and actual positions: In some cases, if there's a large mismatch between expected positions and the current one, you might infer there's a wall/object in the way and halt loading, or apply a different routine.
<br>Command conditions: Make sure that your start/stop conditions work reliably under a variety of conditions, and not just the "values when testing". You might need to increase them or add additional states in which sensor values are handled differently or ignored.
<br><br>A good intake doesn't need to perfectly load a game piece in every scenario, but it does need to have a way to recover so you can resume the match. Let's look at a couple approaches<br><br>The optimal result, of course, is successfully resolving the fault and loading the game piece. Several fault conditions can be resolved through a more complex routine. A couple common ones are <br>
<br>Stop + restart the intake (with motor coast mode). This works surprisingly well, as it lets the game piece settle, slip away from obstructions, and then another intake attempt might successfully complete the load operation.
<br>Reverse + restart the intake. A more complex (and finicky) option, but with the same effect. This an help alleviate many types of jamming, stretching, squishing, and errant game piece modes, as well as re-seat intake wheels.
<br>Re-orient + restart: This can come up if there's mechanical quirks, such as known collision or positional errors that can result in binding (like snagging on a bumper). Moving your system a bit might fix this, allowing a successful intake
<br>A good load routine might need support from your mechanical teams to fix some edge cases. Get them involved!<br><br>If we can't fix it, let's not break it: This is a fault mitigation tactic, intended to preserve game piece and robot safety, and allow the robot to continue a match.<br>The most important part of this is to facilitate the drivers: They need an Eject button, that when held tries to clear a game piece from the system, putting it outside the frame perimeter. A good eject button might be a simple "roller goes backwards", but also might have more complex logic (positioning a system a specific way first) or even controlling other subsystems (such as feeders, indexers, or shooters). <br>Historically, a good Eject button solves a huge amount of problems, with drivers quickly identifying various error cases, and resolving with a quick tap. Often drivers can tap eject to implement "load it anyway" solution, helping prove it on the field before it's programmed as a real solution.<br><br>The big oof 💀. When this happens, your robot is basically out of commission on the field, or your drivers are  slamming it against a wall to knock things loose.<br>In this case, you should be aiming to identify, replicate, and resolve the root cause. It's very likely that this requires mechanical teams to assist. <br>If the jam is not able to be mechanically prevented, then Programming's job is to resolve the intake process to make it impossible, or at least convert it to a temporary stall. <br><br>Within the vast possibility space of the intake you'll handle, there's a few good practices<br>
<br>Test early, test often, capture a lot of errors.
<br>Revise the hardware, then revise the software: Fix the software only as needed to keep things working. Don't spend the time keeping junked intake designs limping along, unless needed for further testing.
<br>Closed loop: Several fault conditions can be avoided by using a velocity PID and feed-forwards to generate a slower, more consistent initial interaction with game pieces, and automatically apply more power in fault condition.
<br>Operate at the edge cases: Do not baby the intake, and do your best to generate repeatable fault conditions to inform the design. 
<br>Operate in motion: Feeding the intake on a stationary chassis tends to feed differently than a mobile chassis and stationary game piece, or a mobile chassis + Mobile Game Piece. 
<br><br><br>Generally,  intakes are not one "system", but often actuated to deploy it beyond the frame perimeter, or line it up with intake positions. These are often done using <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> or <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a>. In some cases, it's a deployable linkage using motors or <a data-tooltip-position="top" aria-label="Level 1/Pnuematics" data-href="Level 1/Pnuematics" href="https://stormbots.github.io/KnowledgeBase/Level 1/Pnuematics" class="internal-link" target="_self" rel="noopener nofollow">Pnuematic Solenoids</a> .<br>Intakes often also interact with gamepiece management systems, usually an <a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexer/Passthrough</a> that helps move the game piece through a scoring mechanism. In some systems, the intake is the scoring mechanism.<br><br>Regardless of the system setup, good <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> design remains, and the "Intake" name tends to be given to the end effector (usually <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a>) contacting the game piece, with intake actuators being named appropriately (like IntakeArm or IntakeElevator)<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a>SuperStructure Intake]]></description><link>https://stormbots.github.io/KnowledgeBase/stormbots-tree.html</link><guid isPermaLink="false">Stormbots Tree.canvas</guid><pubDate>Tue, 30 Sep 2025 05:30:59 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/assets/git-graph-commit-history.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/assets/git-graph-commit-history.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[General Details]]></title><description><![CDATA[ 
 <br><br>
<br>Add Learning Objective to some/all items
<br><br><a data-href="System Tuning" href="https://stormbots.github.io/KnowledgeBase/System Tuning" class="internal-link" target="_self" rel="noopener nofollow">System Tuning</a> -&gt; Cover real world tuning, pull from PID<br><a data-href="Subsystem Lighting" href="https://stormbots.github.io/KnowledgeBase/Subsystem Lighting" class="internal-link" target="_self" rel="noopener nofollow">Subsystem Lighting</a><br>
triggers as state passing, strong and loose coupling.<br>
Motors: Current, free, stall<br>
<a data-href="Mechanism2d" href="https://stormbots.github.io/KnowledgeBase/level-2/mechanism2d.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanism2d</a><br>
<a data-href="Driver Station" href="https://stormbots.github.io/KnowledgeBase/misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a> + Controllers<br>
<a data-href="Lambdas" href="https://stormbots.github.io/KnowledgeBase/misc/lambdas.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas</a>  + Suppliers<br>
Climber systems<br>
<br>Training:

<br>Deploying code


<br>public/private fields and methods
<br>Code planning/bringup stubs, and interfaces.
<br>PID: Position control vs velocity control
<br>Joystick and Input Basics
<br>Solenoids + Pnuematics
<br>Rev Hardware Client
<br>PWM Output
<br>DigitalInput channels and switches
<br>LEDs
<br>SPI, I2C, other communication busses
<br>Custom controllers
<br>Code structuring (Stormbreakers)
<br>How to read documentation
<br>Conventions: Use of Units
<br>Sensor Pairing? Advanced: Information/state transfer (break beam -&gt; indexer position) <a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a>? -&gt; State Transfer
<br><br>
<br>Threading
<br>Old docs
<br><br><a data-href="Encoder Basics#Soft Limits" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html#Soft_Limits" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics &gt; Soft Limits</a> - Dependency jank due to need of motor control<br>
<a data-href="clamping" href="https://stormbots.github.io/KnowledgeBase/misc/clamping.html" class="internal-link" target="_self" rel="noopener nofollow">clamping</a><br>
<a data-href="Units" href="https://stormbots.github.io/KnowledgeBase/misc/units.html" class="internal-link" target="_self" rel="noopener nofollow">Units</a><br>
<a data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanical Backlash</a><br>
<a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a> -&gt; Does this need a mech design page?<br>
<a data-href="Pnuematics" href="https://stormbots.github.io/KnowledgeBase/Pnuematics" class="internal-link" target="_self" rel="noopener nofollow">Pnuematics</a> and solenoids<br>
<a data-href="Scheduler" href="https://stormbots.github.io/KnowledgeBase/Scheduler" class="internal-link" target="_self" rel="noopener nofollow">Scheduler</a> &lt;-- ? <br>Data Structures: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=KwBuV7YZido" target="_blank">https://www.youtube.com/watch?v=KwBuV7YZido</a><br><br>
<br>Rev Hardware Client
<br>Pathplanner/choreo
<br>GrappleHook
<br><a data-href="Driver Station" href="https://stormbots.github.io/KnowledgeBase/misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a>
<br>YAGSL Mechanisms Library <a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/beta-frc-mechanisms-library-elevators-arms-turrets-w-sim-telemetry-built-in/503589" target="_blank">https://www.chiefdelphi.com/t/beta-frc-mechanisms-library-elevators-arms-turrets-w-sim-telemetry-built-in/503589</a>
<br>another mechanism lib <a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/introducing-excalib-a-mechanism-motor-wrappers-and-utilities-wpilibj-command-library/503814" target="_blank">https://www.chiefdelphi.com/t/introducing-excalib-a-mechanism-motor-wrappers-and-utilities-wpilibj-command-library/503814</a>
<br><br>#stub<br>#todo<br><br><a rel="noopener nofollow" class="external-link" href="https://github.com/HighlanderRobotics/Highlanders-Training" target="_blank">https://github.com/HighlanderRobotics/Highlanders-Training</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/todo.html</link><guid isPermaLink="false">TODO.md</guid><pubDate>Wed, 01 Oct 2025 01:27:23 GMT</pubDate></item><item><title><![CDATA[Basic Odometry+Telemetry]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:stub" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stub</a> 
 <br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> <br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>
<br>Create a Widget on a dashboard to show the field
<br>Populate the Field with your robot, and one or more targets
<br>Utilize the Field to help develop a "useful feature" displayed on the Field
<br>As a telemetry task, success is thus open ended, and should just be part of your development process; The actual feature can be anything, but a few examples we've seen before are<br>
<br>showing which of several targets your code has deemed best, and react to it
<br>a path your robot is following, and where the bot is while following it
<br>The current Vision targets and where your bot is when seeing them
<br>A field position used as an adjustable target 
<br>The projected path for a selected auto
<br>Inidcate proximity or zones "zones" for performing a task, such as the acceptable range for a shooting task or intaking process.
<br><br>Odometry is also known as Position Tracking. In FRC, this is generally regarded as knowing the position of your robot in the game field. It is most beneficial when combined with the robot to then have the robot move between positions on the field, and interact with other known positions. <br>Actually obtaining odometry depends on the design of the bot: <a data-tooltip-position="top" aria-label="Level 1/Differential Drive Odometry" data-href="Level 1/Differential Drive Odometry" href="https://stormbots.github.io/KnowledgeBase/Level 1/Differential Drive Odometry" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive Odometry</a> or <a data-href="Swerve Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Odometry</a> , and often involves vision systems via <a data-tooltip-position="top" aria-label="Limelight Odometry" data-href="Limelight Odometry" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">LimeLight Odometry</a> or <a data-href="PhotonVision Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">PhotonVision Odometry</a><br>This document is concerned with the prerequisite: Being able to actually view, compare, and validate positions using robot telemetry.<br><br><img alt="telemetry-elastic.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/telemetry-elastic.png"><br>Telemetry for Odometry revolves around the Field2D object. Both Glass and Elastic can display the Field2D object as a game field on the dashboard, including associated robot positions and any secondary objects.<br>In general, Glass is the superior option for most programming tasks and development, allowing easier customization to help reduce clutter and provide clarity between objects. <br>The WPILib Docs are excellent at helping demonstrate many of these examples:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>In Robots, a Pose represents a specific location and state of a robot's actuator. Within the context of odometry, a pose represents the robot's location on a 2D plane. In most cases, this means the location on the game field. <br>In order to represent such a state, we need 3 things: The X position, the Y position, and a rotation. <br>In WPILib, this is handled by the <a data-href="Pose2d" href="https://stormbots.github.io/KnowledgeBase/misc/pose2d.html" class="internal-link" target="_self" rel="noopener nofollow">Pose2d</a> object, which can be provided to and returned from many utilities interacting with the robot position, including drivetrain path planning, vision, simulation, and telemetry.<br><br>The Field2D object in WPILib contains a number of utilities for keeping tabs on odometry. It can be added with just a couple lines. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		//We only want to send the actual Field object _once_,
		//so we often do it in the constructor. Changes will be 
		//sent automatically as the Field2d object itself is updated.
				
		//Preferred: Set the NetworkTables name explicitly, 
		//and give it a unique, descriptive name
		SmartDashboard.putData("ChassisField",field);
		
		// This form uses the default name "Field" as the key.
		// Not recommended in most cases
		//SmartDashboard.putData(field);
	}

}
<br>This creates a blank, empty field, with your robot position, probably at (0,0)  in the bottom left corner, on the blue side of the field. <br>Meaningfully updating the robot pose is out of scope, and differs by drivetrain type; However, the basic gist is <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	//Set up an odometry object to track our robot
	DifferentialDrivePoseEstimator odometry=new DifferentialDrivePoseEstimator(
	 /* Complex constructor parameters; not relevant*/
	)
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Read the odometry object and set the pose. //Reference only
		field.setRobotPose(odometry.getPoseMeters());
		
		// Or, we can just set it manually for testing.
		field.setRobotPose(new Pose2d(2.7,3.1, new Rotation2d(Math.PI/2.0) ));	
	}
}
<br>Now, when we open our Field2D widget in Glass, we'll see that our robot is at a new position. If we fully implemented our Pose Estimator object, we'd see that this provides realtime tracking of our position.<br>A .getRobotPose() also exists, but tends to be less useful in practice, as most classes that will interact with the Robot and Field will likely have access to the Odometry object directly. <br>Note, that the Field2d object we create is a unique reference, with it's own unique local data; only the NetworkTables key might have overlap when using default keys. This means if we want to properly share a Field across multiple classes, we either need to fetch the NetworkTables data and copy it over, create a single Field object in RobotContainer and pass it to, or create a DriverField object as a <a data-tooltip-position="top" aria-label="Singletons" data-href="Singletons" href="https://stormbots.github.io/KnowledgeBase/level-2/singletons.html" class="internal-link" target="_self" rel="noopener nofollow">Singleton</a> that can facilitate a single object.<br><br>Where Field2d objects really shine is in adding supplemental information about other field objects. The utility varies by game, but it's great for showing a variety of things such as <br>
<br>Targets/objectives
<br>Nearest/best target
<br>Nearest game piece (detected by vision systems)
<br>These can be done using the getObject(name) method; This grabs the named object from the field, creating it if it doesn't already exist.<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Can provide any number of pose arguments
		field.getObject("GamePieces").setPoses(
			new Pose2d(1,1),
			new Pose2d(1,2),
			new Pose2d(1,3),
		);
		//You can also pass a single List&lt;Pose2d&gt; 
		//if you have a list of poses already
		
		field.getObject("BestGamePiece").setPose(
			new Pose2d(1,2)	
		);
	}

}
<br>Note It's worth considering that for objects that never move, you could set  objects once in the constructor, and they work fine. However, if the user accidentally moves them in the UI, it creates a visual mis-match between what the code is doing and what the user sees. As a result, it's often better to just throw it in a Periodic.<br><br>A niche, but very useful application of field objects is to get precise driver feedback on field location data.  This can be done using the following code setup:<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command aimAtCustomTarget(){
		return run(()-&gt;{
			var target=field.getObject("DriverTarget").getPose();
			//Do math to figure out the angle to target
			//Set your drivetrain to face the target
		};
	}
	
	public void periodic(){
		//No setting DriverTarget pose here!
	};
}
<br>In this case, we take advantage of the "set once" approach in constructors; The drivers or programmers can modify the position, and then we now read it back into the code. <br>This can be very useful for testing to create "moving targets" to test dynamic behavior without having to drive the bot. It can also help you create "simulation" poses for testing math relating to Pose2D objects.<br> is especially true for simulation, as this allows you quickly test pose-related functions and makes sure that things happen how you expect.<br>One practical application is match-specific targets for cooperating with allies. An example is in 2024 Crescendo: a common game tactic was to "pass" rings across the field, by shooting to an open area near where your allies would be. However, since the game pieces can get stuck in/on robots, and different robots have different intakes, and each ally has different sight lines, making the ideal pass target unknown until the actual match is about to start. An adjustable target let the alliance sort it out before a match without having to change the code.<br><br>When doing path-planning for drivetrains, it's often helpful to display the full intended path, rather than a lot of individual poses. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command buildAuto1(){
		var  trajectory=// Get the trajectory object from your path tool
		field.getObject("autoTrajectory").setTrajectory(trajectory);
		return run(()-&gt;{
			//draw the rest of the owl
		};
	}
	

}
<br>In this use case, the work will likely be done inside your Auto class after selecting the appropriate one. ]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/basic-odometry+telemetry.html</link><guid isPermaLink="false">Level 1/Basic Odometry+Telemetry.md</guid><pubDate>Fri, 26 Sep 2025 02:29:39 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/telemetry-elastic.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/telemetry-elastic.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FeedForwards]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a velocity FF for a roller system that enables you to set the output in RPM
<br>Create a gravity FF for a elevator system that holds the system in place without resisting external movement
<br>Create a gravity FF for an arm system that holds the system in place without resisting external movement
<br><br>Feedforwards model an expected motor output for a  system to hit specific target values.<br>
The easiest example is a motor roller. Let's say you want to run at ~3000 RPM. You know your motor has a top speed of ~6000 RPM at 100% output, so you'd correctly expect that driving the motor at 50% would get about 3000 RPM. This simple correlation is the essence of a feed-forward. The details are specific to the system at play. <br><br>The WPILib docs have good fundamentals on feedforwards that is worth reading.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br><br>Feed-forwards are specifically tuned to the system you're trying to operate, but helpfully fall into a few simple terms, and straightforward calculations. In many cases, the addition of one or two terms can be sufficient to improve and simplify control. <br><br>The simplest feedforward you'll encounter is the "static feed-forward". This term represents initial momentum, friction, and certain motor dynamics. <br>You can see this in systems by simply trying to move very slow. You'll often notice that the output doesn't move it until you hit a certain threshhold. That threshhold is approximately equal to kS.<br>The static feed-forward affects output according to the simple equation of  <br><br>a kG value effectively represents the value needed for a system to negate gravity. <br>Elevators are the simpler case: You can generally imagine that since an elevator has a constant weight, it should take a constant amount of force to hold it up. This means the elevator Gravity gain is simply a constant value, affecting the output as  ; You don't need any other considerations regarding the system motion, because gravity is always constant. <br>A more complex kG calculation is needed for pivot or arm system. You can get a good sense of this by grabbing a heavy book, and holding it at your side with your arm down. Then, rotate your arm outward, fully horizontal. Then, rotate your arm all the way upward. You'll probably notice that the book is much harder to hold steady when it's horizontal than up or down.<br>The same is true for these systems, where the force needed to counter gravity changes based on the angle of the system. To be precise, it's maximum at horizontal, zero when directly above or below the pivot. Mathematically, it follows the function  ratio, lending this version of the feed-forward the nickname kCos.<br>This form of the gravity constant affects the output according to<br>
, where  is is the maximum output, at horizontal. <a data-footref="kcos" href="https://stormbots.github.io/KnowledgeBase/about:blank#fn-1-eccb17358eb5b44f" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> <br><br>The velocity feed-forward represents the expected output to maintain a target velocity. This term accounts for physical effects like dynamic friction and air resistance, and a handful of  <br>This is most easily visualized on systems with a velocity goal state. In that case,  is easily known, and contributes to the output as  .<br>In contrast, for positional control systems, knowing the desired system velocity is quite a challenge. In general, you won't know the target velocity unless you're using a <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to to generate the instantaneous velocity target. <br><br>The acceleration feed-forward largely negates a few inertial effects. It simply provides a boost to output to achieve the target velocity quicker.<br>like ,  is typically only known when you're working with <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>. <br><br>Putting this all together, it's helpful to de-mystify the math happening behind the scenes.<br>The short form is just a re-clarification of the terms and their units<br>
: Output to overcome gravity ()<br>
: Output to overcome static friction ()<br>
: Output per unit of target velocity ()<br>
: Output per unit of target acceleration ()<br>A roller system will often simply be<br>
If you don't have a motion profile, kA will simply be zero, and and kS might also be negligible unless you plan to operate at very low RPM.<br>An elevator system will look similar:<br>
Without a motion profile, you cannot properly utilize kV and kA, which simplifies down to<br>
where  is generally derived by  (since you know the current and previous positions).<br>Lastly, elevator systems differ only by the cosine term to scale kG.<br>
Again simplifying for systems with no motion profile, you get<br>
It's helpful to recognize that because the angle is being fed to a  function, you cannot use degrees here! Make sure to convert. <br>Of course, the intent of a feed-forward is to model your mechanics to improve control. As your system increases in complexity, and demands for precision increase, optimal control might require additional complexity! A few common cases: <br>
<br>If you have a pivot arm that extends, your kG won't be constant! 
<br>Moving an empty system and one loaded with heavy objects might require different feed-forward models entirely.
<br>Long arms might be impacted by motion of systems they're mounted on, like elevators or the chassis itself! You can add that in and apply corrective forces right away.
<br><br>Since a feed-forward is prediction about how your system behaves, it works very well for fast, responsive control. However, it's not perfect; If something goes wrong, your feed-forward simply doesn't know about it, because it's not measuring what actually happens. <br>In contrast, feed-back controllers like a  <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> are designed to act on the error between a system's current state and target state, and make corrective actions based on the error. Without first encountering system error, it doesn't do anything.<br>The combination of a feed-forward along with a feed-back system is the power combo that provides robust, predictable motion.<br><br>WPILib has several classes that streamline the underlying math for common systems, although knowing the math still comes in handy! The docs explain them (and associated warnings) well.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br>Integrating in a robot project is as simple as crunching the numbers for your feed-forward and adding it to your motor value that you write every loop.<br>ExampleSystem extends SubsystemBase(){

	SparkMax motor = new SparkMax(...)
	// Declare our FF terms and our object to help us compute things.
	double kS = 0.0;
	double kG = 0.0;
	double kV = 0.0;
	double kA = 0.0;
	ElevatorFeedforward feedforward = new ElevatorFeedforward(kS, kG, kV, kA);
	
	ExampleSubsystem(){}

	Command moveManual(double percentOutput){
		return run(()-&gt;{
			var output ;
			//We don't have a motion profile or other velocity control
			//Therefore, we can only assert that the velocity and accel are zero
			output = percentOutput+feedforward.calculate(0,0);
			// If we check the math, this feedforward.calculate() thus 
			// evaluates as simply kg;
			
			// We can improve this by instead manually calculating a bit
			// since we known the direction we want to move in
			output = percentOutput + Math.signOf(percentOutput) + kG;
			motor.set(output);
		})
	}

	Command movePID(double targetPosition){
		return run(()-&gt;{
			//Same notes as moveManual's calculations 
			var feedforwardOutput = feedforward.calculate(0,0);
			// When using the Spark closed loop control, 
			// we can pass the feed-forward directly to the onboard PID
			motor
			.getClosedLoopController()
			.setReference(
				targetPosition,
				ControlType.kPosition,
				ClosedLoopSlot.kSlot0,
				feedforwardOutput, 
				ArbFFUnits.kPercentOut
			);
			//Note, the ArbFFUnits should match the units you calculated!
		})
	}

	Command moveProfiled(double targetPosition){
		// This is the only instance where we know all parameters to make 
		// full use of a feedforward.
		// Check [[Motion Profiles]] for further reading
	}
	
}
<br>2026 update?
Rev released a new FeedForward config API that might allow advanced feed-forwards to be run directly on controller. Look into it and add examples!<br>
<a rel="noopener nofollow" class="external-link" href="https://codedocs.revrobotics.com/java/com/revrobotics/spark/config/feedforwardconfig" target="_blank">https://codedocs.revrobotics.com/java/com/revrobotics/spark/config/feedforwardconfig</a>
<br><br>High gains
When tuning feed-forwards, it's helpful to recognize that values being too high will result in notable problems, but gains being too low generally result in lower performance.<br>
Just remember that the lowest possible value is 0; Which is equivalent to not using that feed forward in the first place. Can only improve from there. 
<br>FeedForward Units
It's worth clarifying that the "units" of feedForward are usually provided in "volts", rather than "percent output". This allows FeedForwards to operate reliably in spite of changes of supply voltage, which can vary from 13 volts on a fresh battery to ~10 volts at the end of a match.<br>
Percent output on the other hand is just how much of the available voltage to output; This makes it suboptimal for controlled calculations in this case. 
<br><br>These two terms are defined at the boundary between "moving" and "not moving", and thus are closely intertwined. Or, in other words, they interfere with finding the other. So it's best to find them both at once.<br>It's easiest to find these with manual input, with your controller input scaled down to give you the most possible control.<br>Start by positioning your system so you have room to move both up and down. Then, hold the system perfectly steady, and increase output until it just barely moves upward. Record that value.<br>
Hold the system stable again, and then decrease output until it just barely starts moving down. Again, record the value. <br>Thinking back to what each term represents, if a system starts moving up, then the provided input must be equal to ; You've negated both gravity and the friction holding it in place. Similarly, to start moving down, you need to be applying . This insight means you can generate the following two equations  <br><br>Helpfully, for systems where  like roller systems, several terms cancel out and you just get  .<br>For pivot/arm systems, this routine works as described if you can calculate kG at approximately horizontal. It cannot work if the pivot is vertical. If your system cannot be held horizontal, you may need to be creative, or do a bit of trig to account for your recorded  being decreased by <br>Importantly, this routine actually returns a kS that's often slightly too high, resulting in undesired oscillation. That's because we recorded a minimum that causes motion, rather than the maximum value that doesn't cause motion. Simply put, it's easier to find this way. So, we can just compensate by reducing the calculated kS slightly; Usually multiplying it by 0.9 works great. <br><br>Because this type of system system is also relatively linear and simple, finding it is pretty simple. We know that , and expect . <br>We know  is going to be constrained by our motor's maximum RPM, and that maxOutput is defined by our api units (either +/-1.0 for "percentage" or +/-12 for "volt output"). <br>This means we can quickly assert that  should be pretty close to . <br><br>Beyond roller kV, kA and kV values are tricky to identify with simple routines, and require <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to take advantage of. As such, they're somewhat beyond the scope of this article.<br>The optimal option is using <a data-href="System Identification" href="https://stormbots.github.io/KnowledgeBase/level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a> to calculate the system response to inputs over time. This can provide optimal, easily repeatable results. However, it involves a lot of setup, and potentially hazardous to your robot when done without caution.<br>The other option is to tune by hand; This is not especially challenging, and mostly involves a process of moving between goal states, watching graphs, and twiddling numbers. It usually looks like this:<br>
<br>Identify two setpoints, away from hard stops but with sufficient range of motion you can hit target velocities. 
<br>While cycling between setpoints, ihen increase kV until the system generates velocities that match the target velocities. They'll generally lag behind during the accelleration phase. 
<br>Then, increase kA until the accelleration shifts and the system perfectly tracks your profile. 
<br>Increase profile constraints and and repeat until system performance is attained. Starting small and slow prevents damage to the mechanics of your system.
<br>This process benefits from a relatively low P gain, which helps keep the system stable. Once your system is tuned, you'll probably want a relatively high P gain, now that you can assert the feed-forward is keeping your error close to zero. <br><br>
<br>
<br>Note, you might observe that the kCos output,   is reading the current system state, and say "hey!  That's a feed back system, not a feed forward!" and you are technically correct; the best kind of correct. However, kCos is often implemented this way, as it's much more stable than the feed-forward version. In that version, you apply , regardless of what  happens to actually be. Feel free to do a thought experiment on how this might present problems in real-world systems.<a href="https://stormbots.github.io/KnowledgeBase/about:blank#fnref-1-eccb17358eb5b44f" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html</link><guid isPermaLink="false">Level 1/FeedForwards.md</guid><pubDate>Sat, 27 Sep 2025 21:15:38 GMT</pubDate></item><item><title><![CDATA[Motor Control]]></title><description><![CDATA[ 
 <br>Requires:<a data-href="Robot Code Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br>
Recommends:<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br><br>
<br>Spin a motor
<br>Configure a motor with max current
<br>Control on/off via joystick button
<br>Control speed via joystick
<br><br>Learning order
This curriculum does not require or assume solid knowledge of <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> structure; It's just about spinning motors. All code here uses existing Example structure that's default on Command Based Robot projects.<br>
However, it's recommended to learn Motor Control alongside or after <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, as we'll use them for everything afterwards anyway.
<br>Rev Lib
This documentation assumes you have the third party Rev Library installed. You can find instructions here.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html</a>
<br>Wiring and Electrical
This document also assumes correct wiring and powering of a motor controller. This should be the case if you're using a testbench. 
<br>Identifying the right motor
Most of our motors will have sticky notes with the correct ID number; However, if something doesn't seem to work, you can check it using this process using the<br>
<a data-href="Rev Hardware Client" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a><br>
<br><br><br>
<br>Plug in your computer into any available Spark controller. The one you're interested is easier.
<br>If you don't see anything useful, click "Scan For Devices" down in the bottom left
<br>You should see one (or more!) devices in the left side.
<br>Select the device that looks like your motor
<br>Click the "Blink" button, and look at your physical hardware. The light should be flickering
<br>If not, repeat this process until you find it.
<br>You can see the Device ID in the device settings, and put that in your code. 

<br><br><br>Conceptually, running a motor is really easy, with just a few lines of code! You can, in fact, run a motor with this.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	/// Other code+functions; Ignore for now.
	int motorID = 0; //This will depend on the motor you need to run
	SparkMax motor = new SparkMax(motorID,MotorType.kBrushless);

	public ExampleSubsystem(){}

	public void periodic(){
		// Will run once every robot loop
		// Motors will only run when it's enabled...
		// but will *always* run when enabled!
		motor.set(0.1);
		//Motor range is [-1 .. 1], but we want to run slow for this
	}
}
<br>The hard part is always in making it do what you want, when you want. <br><br>Most useful robots need a bit more basic setup for the configuration. This example code walks through some of the most common configurations used when making a simple motor system.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	/// Other code+functions; Ignore for now.
	int motorID = 0; //This will depend on the motor you need to run
	SparkMax motor = new SparkMax(motorID,MotorType.kBrushless);
	
	public ExampleSubsystem(){
		//First we create a configuration structure
		var config = new SparkMaxConfig();
		//This is the "passive" mode for the motor.
		// Brake has high resistance to turning
		// Coast will spin freely. 
		// Both modes have useful applications
	    config.idleMode(IdleMode.kBrake);
	    // This changes the direction a motor spins when you give
	    // it a positive "set" value. Typically, you want to make 
	    // "positive inputs" correlate to "positive outputs",
	    // such as "positive forward" or "positive upward"
	    config.inverted(false);
		// Reduce the maximum power output of the motor controller. 
		// Default is 80A, which is *A LOT* of power!.
		// 10 is often a good starting point, and you can go up from there
	    config.smartCurrentLimit(10);
	    // This controls the maximum rate the output can change. 
	    // This is in "time between 0 and full output". A low value
	    // makes a more responsive system. 
	    // However, zero puts a *lot* of mechanical and electrical 
	    // strain on your system when there's turning things on/off.
	    // Having 0.05 is generally an optimal value for starting.
	    // Check the [[Slew Rate Limiting]] article for more info!
	    config.openLoopRampRate(0.05);

		//Lastly, we apply the parameters
	    motor.configure(
	      config, 
	      ResetMode.kResetSafeParameters, 
	      PersistMode.kNoPersistParameters
	    );
	}

	public void periodic(){ }
}
<br><br><br><br><br>The next goal is to make a motor spin when you press a button, and stop when you release it.<br>Commands
The following examples utilize the Command structure, but do not require understanding it. You can just follow along, or read <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> to figure that out. 
The minimum bit of knowledge is that 

<br>Commands are an easy way to get the robot to start/stop bits of code
<br>Commands are an easy way to attach bits of code to a controller 
<br>The syntax looks a bit weird, that's normal.

Trying to avoid the Command structure entirely is simply a lot of work, or involves a lot of really bad habits and starting points to unlearn later.
<br>We're going to work with some Example code that exists in any new project. The relevant part looks like this.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	/// Other code+functions be here
	
	public Command exampleMethodCommand() {
		return runOnce(
			() -&gt; {
			  /* one-time action goes here */
			});
	}

	
	public void periodic(){ }
}
<br>Let's fill in our subsystem with everything we need to get this moving. <br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	int motorID = 0; //This will depend on the motor you need to run
	SparkMax motor = new SparkMax(motorID,MotorType.kBrushless);
	
	public ExampleSubsystem(){
		var config = new SparkMaxConfig();
		// ! Copy all the motor config from the Practical Example above! 
		// ... omitted here for readability ... 
		motor.configure(
			config,
			ResetMode.kResetSafeParameters, 
			PersistMode.kNoPersistParameters
	    );
	}
	
	public Command exampleMethodCommand() {
		return runOnce(
			() -&gt; {
			  motor.set(0.1) // Run at 10% power
			});
	}

	public void periodic(){ }
}
<br>Without any further ado, if you deploy this code, enable the robot, and hit "B", your motor will spin! <br>CAUTION Note it will not stop spinning! Even when you disable and re-enable the robot, it will continue to spin. We never told it how to stop.<br>An important detail about smart motor controllers is that they remember the last value they were told to output, and will keep outputting it. As a general rule, we want our code to always provide a suitable output. <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> give us a good tool set to handle this, but for now let's just do things manually.<br><br>Next let's make two changes: One, we copy the existing exampleMethodCommand. We'll name the new copy stop, and have it provide an output of 0.<br>Then, we'll just rename exampleMethodCommand to spin. We should now have two commands that look like this. <br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructor stuff 
	
	public Command spin() {
		return runOnce(
			() -&gt; {
			  motor.set(0.1) // Run at 10% power
			});
	}

	public Command stop() {
		return runOnce(
			() -&gt; {
			  motor.set(0) // Run at 10% power
			});
	}

}
<br>We'll also notice that changing the function name of  exampleMethodCommand has caused a compiler error in RobotContainer! Let's take a look<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		//The line with a an error
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.exampleMethodCommand());
	}
}

<br>Here we see how our joystick is actually starting our  "spin" operation. Since we changed the name in our subsystem, let's change it here too. <br>We also need to actually run stop at some point; Controllers have a number of ways to interact with buttons, based on the <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> class. <br>We already know it runs spin when pressed (true), we just need to add something for when it's released. So, let's do that. The final code should look like<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.spin())
		.onFalse(m_exampleSubsystem.stop())
		;
	}
}
<br>If you deploy this, you should see the desired behavior: It starts when you press the button, and stops when you release it.<br>Real code flow
Just a heads up: Once we're experienced with  <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> we'll have better options for handling stopping motors and handling "default states". This works for simple stuff, but on complex robots you'll run into problems.
<br><br>So far, we have a start/stop, but only one specific speed. Let's go back to our subsystem, copy our existing function, and introduce some parameters so we can provide arbitrary outputs via a joystick. <br>Just like any normal function, we can add parameters. In this  case, we're shortcutting some technical topics and just passing a whole joystick.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructors and other functions 
	
	public Command spinJoystick(CommandXboxController joystick) {
		return run(() -&gt; { // Note this now says run, not runOnce.
			motor.set(joystick.getLeftY());
		});
	}
}
<br>Then hop back to RobotContainer. Let's make another button sequence, but this time on A<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		//Stuff for the B button
		
		//our new button
		m_driverController.a()
		.whileTrue(m_exampleSubsystem.spinJoystick(m_driverController))
		.onFalse(m_exampleSubsystem.stop())
		;
	}
}
<br>Give this a go! Now, while you're holding A, you can control the motor speed with the left Y axis.<br>Real code: Don't pass joysticks
Long term, we'll avoid passing joysticks; This makes it very hard to keep tabs on how buttons and joysticks are assigned. However, at this stage we're bypassing <a data-tooltip-position="top" aria-label="Lambdas" data-href="Lambdas" href="https://stormbots.github.io/KnowledgeBase/misc/lambdas.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas</a> which are the technical topic needed to do this right.<br>
If you can do this with your <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> knowledge, go ahead and fix it after going through this!
<br><br><br>We've dodged a lot of "the right way" to get things moving. If you're coming back here after learning <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, we can adjust things to better represent a real robot with more solid foundations. <br><br>Knowing how commands work, you know there's a couple wrong parts here. <br>
<br>The runOnce is suboptimal; This sets the motor, exits, and makes it hard to detect when you cancel it. 
<br>We don't command the robot at all times during motion; Most of the time it's running it's left as the prior state
<br>We don't need to add an explicit stop command on our joystick; We have the end state of our commands that can help. 
<br>Putting those into place, we get<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructor stuff 
	
	public Command spin() {
		return run(() -&gt; {
			  motor.set(0.1) // Run at 10% power
			})
			.finallyDo(()-&gt;motor.set(0))
			;
	}
}
<br>This lets us simplify our button a bit, since we now know spin() always stops the motor when we're done.<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.spin())
	}
}
<br>As before, our button now starts and stops.<br><br>Previously, we just passed the whole joystick to avoid DoubleSuppliers and Lambdas. Let's now add this properly. <br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructors and other functions 
	
	public Command spinJoystick(DoubleSupplier speed) {
		return run(() -&gt; {
			motor.set(speed.get());
		})
		.finallyDo(()-&gt;motor.set(0))
		;
	}
}
<br>Then hop back to RobotContainer, and instead of a joystick, pass the supplier function.<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		//Stuff for the B button
		
		//our new button
		m_driverController.a()
		.whileTrue(m_exampleSubsystem.spinJoystick(m_driverController::getLeftX))

		;
	}
}
<br>There we go! We've now corrected some of our shortcuts, and have a code structure more suited for building off of.]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html</link><guid isPermaLink="false">Level 1/Motor Control.md</guid><pubDate>Sat, 27 Sep 2025 07:53:15 GMT</pubDate></item><item><title><![CDATA[SuperStructure Rollers]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>Recommends:<br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create a Roller serving as a simple intake
<br>Create Commands for loading, ejecting, and stopping
<br>Create a default command that stops the subsystem
<br>Bind the load and eject operations to a joystick
<br>Optional Bonus criteria: <br>
<br>Configure the Roller to use RPM instead of setPower
<br>Add a FeedForward and basic PID
<br>Confirm the intake roughly maintains the target RPM when intaking/ejecting
<br><br>A Roller system is a simple actuator type: A single motor output mechanically connected to a rotating shaft. Objects contacting the shaft forms the useful motion of a Roller system. This can also extended with additional shafts, belts, or gearing to adjust the contact range.<br>Despite the simplicity, Rollers are very flexible and useful systems in FRC. When paired with clever mechanical design, Rollers can accomplish a wide variety of game tasks, empower other system types, and serve as the foundation of more complex systems.<br><br>On their own, rollers can be designed to serve a few functions <br>
<br>Fixed position <a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intakes</a>, responsible for pulling objects into a robot
<br>Simple scoring mechanisms for ejecting a game piece from the bot
<br>Simple launchers game pieces from the robot at higher speeds
<br>As motion systems to move game pieces through the bot
<br>As a simple feeder system for allowing or blocking game piece motion within the bot.
<br>Rollers of this nature are very common on Kitbot designs, owing to the mechanical simplicity and robustness of these systems. <br>For more complex bots, Roller systems are usually modified with extra mechanical features or actuated. These include<br>
<br>A <a data-tooltip-position="top" aria-label="SuperStructure Flywheel" data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">Flywheel</a> system, which provides more accurate launching of game pieces through precision control and increased momentum
<br>As <a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexers/Feeder/Passthrough</a>, providing precision control of game pieces through a bot.
<br>As actuated <a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intakes</a>, often with rollers attached to <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> or linkages<br>
These documents discuss the special considerations for improving Rollers in those applications.
<br><br><br>In keeping with a Roller being a simple system, they're simple to implement: You've already done this with <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>.<br>To integrate a Roller system into your bot code, there's simply a few additional considerations:<br>
<br>The function of your roller: This determines the role and name of your system. Like all subsystems, you want the name to be reflective of it's task, and unique to help clarify discussion around the system. 
<br>Level of control needed: Rollers often start simple and grow in complexity, which is generally preferred. But, sometimes you can tell that your system will get complicated, and it's worth planning for. 
<br>The base tasks this system performs. 
<br>sometimes a Roller system will serve multiple roles: Usually, it's good to recognize this early to facilitate naming and configuration.
<br>These are effectively what we see in <a data-href="Robot Design Analysis" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-design-analysis.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Design Analysis</a> , but especially pertinent for Roller systems. Since your system will likely have multiple rollers, naming them "Rollers" is probably a bad idea. Assigning good names to the roller system and the actions it performs will make your code easier to follow.<br>Rollers generally will have a few simple actions, mostly setting a power and direction, with appropriate names depending on the intent of the action:<br>
<br>Intake rollers usually have "intake", "eject", and "stop" which apply a fixed motor power. Larger game pieces might also have a "hold", which applies a lower power to keep things from shifting or falling out.
<br>Rollers in a Launcher role will usually have "shoot" and "stop", and rarely need to do much else.  
<br>Rollers serving as a "feeder" will usually alternate between the "launcher" and "intake" roles; So it'll need appropriate actions for both.
<br><br>Appropriately, a useful, minimal roller system is very straightforward, and done previously in <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>. But this time let's clean up names.<br>public Launcher extends SubsystemBase{
	SparkMax motor = new SparkMax(42,kBrushless);

	Launcher(){
		//Normal constructor tasks
		//Configure motor: See Motor Control for example code
		//Set the default command; In this case, just power down the roller
		setDefaultCommand(setPower(0)); //By default, stop
	}
	public Command setPower(double power){
		// Note use of a command that requires the subsystem by default
		// and does not exit
		return run(()-&gt;motor.set(power));
	}
	public Command launchNear(){
		return setPower(0.5);
	}
	public Command launchFar(){
		return setPower(1);
	}
}
<br>For most Roller systems, you'll want to keep a similar style of code structure: By having a setPower(...) command <a data-tooltip-position="top" aria-label="Code Patterns" data-href="Code Patterns" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html" class="internal-link" target="_self" rel="noopener nofollow">Factory</a>, you can quickly build out your other verbs with minimal hassle. This also allows easier testing, in case you have to do something like attach a <a data-tooltip-position="top" aria-label="Joysticks" data-href="Joysticks" href="https://stormbots.github.io/KnowledgeBase/misc/joysticks.html" class="internal-link" target="_self" rel="noopener nofollow">Joystick</a> to figure out the exact right power for a particular task. <br>In general, representing actions using named command factories with no arguments is preferable, and will provide the cleanest code base.  The alternatives such as making programmers remember the right number, or feeding constants into setPower will result in much more syntax and likelyhood of errors.<br>Having dedicated command factories also provides a cleaner step into modifying logic for certain actions. Sometimes later you'll need to convert a simple task into a short sequence, and this convention allows that to be done easily.<br><br>Without straying too far from a "simple" subsystem, there's still a bit we can do to resolve problems, prevent damage, or streamline our code.<br><br>Sometimes with Roller systems, you'll notice that the power needed to move a game piece often provides undesirable effects when initially contacting a game piece. Or, that sometimes a game piece loads wrong, jams, and the normal power setting won't move it.<br>This is a classic case where error correcting methods like <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>s shine! By switching your roller from a "set power" configuration to a "set rotational speed" one, you can have your rollers run at a consistent speed, adjusting the power necessary to keep things moving. <br>Notably though, PIDs for rollers are very annoying to dial in, owing to the fact that they behave very differently when loaded and unloaded, and even more so when they need to actually resolve an error condition like a jam!<br>
The use of a <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> aids this significantly: Feedforward values for rollers are extremely easy to calculate, and can model the roller in an unloaded, normal state. This allows you to operate "unloaded", with nearly zero error. When operating with very low error, your PID will be much easier to deal with, and much more forgiving to larger values.<br>You can then tune the P gain of your PID such that your system behaves as expected when loaded with your game piece. If the FF+P alone won't resolve a jamming issue, but more power will, you can add an I gain until that helps push things through.<br><br>Some Roller actions can be improved through the use of <a data-tooltip-position="top" aria-label="Sensing Basics" data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensors</a>, which generally detect the game piece directly. This helps rollers know when they can stop and end sequences, or select one of two actions to perform. <br>However, it is possible (although sometimes a bit tricky) to read the motor controller's built in sensors: Often the Current draw and encoder velocity. When attempting this, it's recommended to use <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> with a Debounce operation, which provides a much cleaner signal than directly reading these <br>You can also read the controller position too! Sometimes this requires a physical reference (effectively <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> a game piece), which allows you to assert the precise game piece location in the bot.<br>
In other cases you can make assertions solely from relative motion: Such as asserting if the roller rotated 5 times, it's no longer physically possible to still be holding a game piece, so it's successfully ejected.<br><br>Many Roller systems, particularly intakes will wind up with in one of two states: Loaded or Unloaded, with each requiring a separate conditional action.<br>The defaultCommand of a Roller system is a great place to use this, using the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> utility ConditionalCommand (akaeither ). A common case is to apply a "hold" operation when a game piece is loaded, but stop rollers if not.  <br>Implemented this way, you can usually avoid more complex <a data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a>, and streamline a great deal of code within other sequences interacting with your roller.<br><br>Some Roller systems will pull objects in, where the object hits a hard stop. This is most common on intakes. In all cases, you want to constrain the power such that nothing gets damaged when the roller pulls a game piece in and stalls.<br>Beyond that, in some cases you can set the current very low, and replace explicit hold() actions and sensors with just this lower output current. You simply run the intake normally, letting the motor controller apply an appropriate output current.<br>This is not common, but can be useful to streamline some bots, especially with drivers that simply want to hold the intake button to hold a game piece.<br><br>Should jams be possible in your roller system, encoder velocity and output current can be useful references, when combined with the consideration that <br>When a "jam" occurs, you can typicaly note <br>
<br>A high commanded power
<br>A high output current
<br>A low velocity
<br>//Current detection
new Trigger(()-&gt;motor.getAppliedOutput()&gt;=.7 &amp;&amp; motor.getOutputCurrent()&gt;4).debounce(0.2);
//Speed Detection
new Trigger(()-&gt;motor.getAppliedOutput()&gt;=.7 &amp;&amp; motor.getEncoder().getVelocity()&lt;300).debounce(0.2);
<br>However, care should be taken to ensure that these do not also catch the spin up time for motors! When a motor transitions from rest to  high speed, it also generates significant current, a low speed, and high commanded output.<br>Debouncing the trigger not only helps clean up the output signal, but for many simple Roller systems, they spin up quickly enough that the debounce time can simply be set higher than the spin up duration.]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html</link><guid isPermaLink="false">Level 1/SuperStructure Rollers.md</guid><pubDate>Sat, 27 Sep 2025 18:51:44 GMT</pubDate></item><item><title><![CDATA[Triggers]]></title><description><![CDATA[ 
 <br><br>Triggers are a simple boolean condition that robot code can use to interact with commands, including starting and stopping them.<br><br>
<br>Start a command when the robot is enabled, and ends automatically
<br>Create a Trigger with multiple required conditions before running a command
<br>Read a sensor input in a Trigger, and run a command when the sensor enters a true state.
<br><br>
<br>Support command+trigger subsystem interfaces
<br>Model system state into binary regions
<br>loose coupling of subsystems
<br>Tolerances on sensors
<br>Joystick buttons = trigger ; Hidden common use case
<br>Starting commands with triggers
<br>ending commands with triggers
<br>sequencing component
<br><br>The first, easiest introduction to Triggers is the CommandXboxController class, used to interact with the driver's joystick! <br>Each button is a trigger, and a great learning reference. Each new project has some triggers for you, set up and ready to go!<br>public class RobotContainer{
	private final CommandXboxController m_driverController =
	new CommandXboxController(OperatorConstants.kDriverControllerPort);
	//That constant equals 0  btw
	
	private void configureBindings() {
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.exampleMethodCommand());
}
<br>In this case, m_driverController.b() generates a new Trigger interacting with the B button on the controller.<br>
Here, we see that the Trigger uses .whileTrue(command) . This Trigger option 1) Starts the command when the button is pressed, and 2) Cancels the command when it's released. <br>whileTrue tends to be a very good option for Drivers and controller inputs : it enables good muscle memory, and predictable human-&gt;robot interactions. Similarly, with no buttons being pressed, no commands are running: This means your robot is predictably running only defaultCommands and becomes easy to reason about as a programmer.<br><br>Triggers are a great way to wrap sensor and subsystem "state", and expose it to be integrated with Commands. <br>While it's less common to launch commands based on these types of Triggers, Triggers provide several functions that prove useful, and help clean up your subsystem and command code. <br>Common triggers include<br>
<br>Confirming you're at an arbitrary commanded position, usually written isOnTarget / isAtGoal / isAtSetpoint(), or something similar. 
<br>Confirming that you're at a relevant named position, such as atScoringPosition, atLevel2, atLevel3, atPickupAngle
<br>Confirming the state of a game piece: Usually isGamepieceLoaded, replacing Gamepiece with the name of the current year's item.
<br>isWithinRange() ; Common for rangefinders like <a data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">LaserCan</a>
<br>Usually, these are further customized to provide very clear, yes/no queries with true/false responses.<br><br>For a full reference of available options, see here:<br>
<a rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/button/Trigger.html" target="_blank">https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/button/Trigger.html</a><br>The most helpful ones will tend to be  <br>whileTrue: Extremely useful for driver interactions<br>
onTrue : Very good for automated sensor interactions, such as automatically starting intake processes.<br>and and or : Allow joining two existing Triggers. This can clean up some code, most notably writing command.until(...) conditions. <br>and is also helpful for attaching multiple conditions to existing triggers, to further filter conditions.<br>getAsBoolean can be useful, as it simply returns the true/false value of the checked condition. This allows Triggers to be used as simple Boolean functions, or as boolean variables.<br>debounce(time) prevents the trigger from changing output until the condition is in the new state for time seconds. A small debounce can improve reliability and prevent misfires by handling sensor quirks or environmental errors that can trigger the condition without really being in the intended state.<br>
<br>This is especially useful for measuring time-sensitive readings like velocity and current, as they provide extremely noisy signals otherwise.
<br>Helpful for Position-based measures, ensuring that the system is "stable" and not bouncing around the target position
<br>Helpful when anding multiple sensor reading, to ensure that the system has settled on the desired state properly.
<br><br>Triggers are a bit strange; When they're created, they're included in the robot's Command Scheduler, and it's not needed to make sure they stay in scope to continue working. <br>However, you do need to keep them in an accessible scope if you want other parts of the system to continue working. This leads to a few variants on where they go in your codebase.<br>The important detail is that a Trigger should only be created once, and not created in execute blocks or using Factory methods.<br><br>This style is useful for "interface" functions; Ones that will be used inside or outside of your subsystem to tell you something about it.<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
	}
	public Trigger isEncoderAround20 = new Trigger(
		()-&gt;encoder.get()&gt;15 &amp;&amp; encoder.get &lt; 25
	)
}
<br><br>If a command is just running automated actions, but won't be referenced, you can simply put it in a constructor.  This will schedule the command, and work invisibly in the background.<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
		new Trigger(DriverStation::isEnabled)
		.and(()-&gt;isHomed==false)
		.onTrue(goHome())
	}
<br>(see also <a data-href="#Automatically launching commands at startup" href="https://stormbots.github.io/KnowledgeBase/about:blank#Automatically_launching_commands_at_startup" class="internal-link" target="_self" rel="noopener nofollow">Automatically launching commands at startup</a> for more info about this use case)<br><br>Less common, but some Trigger checks interfacing with multiple subsystems may need to be created in RobotContainer.  Generally, we want to minimize these for single-subsystem interactions. <br>Usually, the constructor is fine, but for complex robots, you might want to create a configureTriggers() utility function, just as the constructor has a configureBindings for joystick buttons.<br>public class RobotContainer{
	public RobotContainer(){ //constructor
		new Trigger(DriverStation::isEnabled)
		.and(()-&gt;elevator.isHomed==false)
		.onTrue(elevator.goHome())
	}
<br>This one even has an example in the code!<br>public class RobotContainer{
	private void configureBindings() {
		// Schedule `ExampleCommand` when `exampleCondition` changes to `true`
		new Trigger(m_exampleSubsystem::exampleCondition)
		.onTrue(new ExampleCommand(m_exampleSubsystem));
	}
}
<br><br>This is an unusual edge case; Sometimes, your Trigger will rely on something in your class that is not yet initialized. Because of this, you can't put it as a class member, since that would need to evaluate immediately. But you can't put it in the constructor, because that'd hide the scope, and you can't access it!<br>The solution is do both; We reserve the location in memory, allowing Java to process the class, and then come back and evaluate our Trigger when we construct the class. <br>public class ExampleSubsystem{
	public Trigger isEncoderAround20; //uninitialized!
	
	public ExampleSubsystem(){
		// We now initialize it 
		isEncoderAround20 = new Trigger(
			()-&gt;encoder.get()&gt;15 &amp;&amp; encoder.get &lt; 25
		);
	}
	
}
<br>In general we try to avoid this pattern; It often leads to forgotten initialization steps, and produces more noise and redundancy. However, it does resolve this particular problem.<br><br><br>On initially reviewing this example code, you might expect it to work as written when the robot starts up<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
		new Trigger(()-&gt;isHomed)==false).onTrue(goHome());
	}
	public Command goHome(){
		return run(()-&gt;/*Do a homing process*/);
	}
}
<br>However, it fails for a very surprising reason, relating to the robot's boot process,and the fact that commands don't run when in Disabled Mode. The timeline of events is as indicated:<br>
<br>The robot boots
<br>The ExampleSubsystem is created, and the trigger is registered with the <a data-href="Scheduler" href="https://stormbots.github.io/KnowledgeBase/Scheduler" class="internal-link" target="_self" rel="noopener nofollow">Scheduler</a>
<br>Eventually, initialization is complete
<br>The robot enters Disabled mode
<br>isHomed is  checked and false. 
<br>goHome is started, and immediately stopped.
<br>Eventually, the driver enables the robot
<br>The robot enters Enabled mode.
<br>isHomed is still false, rather than becoming false so nothing happens. 
<br>What the heck!<br>The issue is that the command state is not considered for onTrue; Only the condition is. In some cases "homing" might deserve .onTrue; But other triggers (like automatic gamepiece alignment or adjustment) might interfere with other robot processes!<br>The trick is to explicitly check for the robot to be enabled first, and then your other condition afterward.<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
		new Trigger(DriverStation::isEnabled)
		.and(()-&gt;isHomed==false)
		.onTrue(goHome());
	}
	public Command goHome(){
		return run(()-&gt;/*Do a homing process*/);
	}
}
<br>In this case, DriverStation::isEnabled will always fail until the robot is in a state where it could run a command. Only then will it check  the isHomed status, see the condition is true, and attempt to schedule the command. Success!<br><br>Scheduling some actions based on sensors might wind up interfering with other ongoing robot tasks. Remember, they're exactly like a driver hitting a button!<br>For example, if you automatically "grab" a loaded game piece, like this: <br>public class IntakeSubsystem extends SubsystemBase{
	public IntakeSubsystem(){
		new Trigger(isGamePieceLoaded).onTrue(holdGamePiece());
	}
	public Command holdGamePiece(){
		return run(()-&gt;motor.set(0.1));
	}
	
}
<br>and then try to run a sequence like this:<br>public class RobotContainer(){
	public Command fancyGrabGamepiece(){
		return new SequentialCommand(){
			elevator.goToBottom(),
			intake.intake(), //&lt;-- This causes your trigger to run! 
			//Command will get cancelled here
			elevator.goToScoringPosition() //won't run
		}
	}
}
<br>You will be annoyed by the unexpected behavior. Worse, if there's a sensor glitch, you might cancel scoring operations too! Instead of getting points, you just suck the game piece back in. <br>In cases where such conflicts might come up, you can detect if a Command requires the subystem, by adding some conditions to the trigger, preventing unexpected launches during other actions. <br>	//Check to see if *any* command is scheduled.
	new Trigger(isGamePieceLoaded)
	.and(this.getCurrentCommand()==null) //Null returned if no command running
	.onTrue(holdGamePiece());

	//Check to see if the current command is "default"
	// We probably don't mind interrupting the default.
	new Trigger(isGamePieceLoaded)
	.and(this.getCurrentCommand()==this.getDefaultCommand())
	.onTrue(holdGamePiece());
	//Note, if you have no defaultCommand getDefaultCommand() will 
	//return null!
<br>These methods allow your trigger to intentionally set its own priority below other commands that might be interacting with the system. <br>However, in some cases you might simply be better off using an intelligent DefaultCommand for such automated actions, but this is a useful tool to be aware of!<br>Test this behavior
While these specific Trigger techniques been used successfully in the past, these examples are not written from older, validated code and may contain errors.<br>
Trigger/command behavior might also be changing in 2025, rendering these obsolete or working differently.
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/triggers.html</link><guid isPermaLink="false">Level 1/Triggers.md</guid><pubDate>Sat, 27 Sep 2025 18:57:55 GMT</pubDate></item><item><title><![CDATA[Joysticks]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/basic-programming/joystick.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/basic-programming/joystick.html</a> <br><br>Through experience, we've found that we often have multiple joysticks, a lot of different projects, and a lot of computers. <br>Not surprisingly, if you wind up trying to read the wrong inputs from the wrong joysticks, you can end up with a lot of surprises, sometimes dangerously so. <br>As a result, we found the best resolution is to simply define <br>
<br>Joystick 0 is always the "main" joystick, typically for the driver. 
<br>Joystick 1 is always the "operator" joystick for auxiliary controls. 
<br>In code, we'd represent this as <br>Joystick driverInput = new Joystick(0);
Joystick operatorInput = new Joystick(1);
<br>Then, in the <a data-href="Driver Station" href="https://stormbots.github.io/KnowledgeBase/misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a> , make sure that it picks up the corresponding controllers in the same order: 0 for main/driver, and 1 for operator. <br>]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/joysticks.html</link><guid isPermaLink="false">Misc/Joysticks.md</guid><pubDate>Sat, 27 Sep 2025 07:43:36 GMT</pubDate></item><item><title><![CDATA[Pose2d]]></title><description><![CDATA[ 
 <br><br>These have lots of documentation, which is helpful to go through before doing non-trivial work with Poses.<br>
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/geometry/pose.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/geometry/pose.html" target="_blank">WPILIB Rotation + Translation</a>
<br><a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/geometry/Pose2d.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/geometry/Pose2d.html" target="_blank">Pose2D class reference</a>
<br><a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/geometry/Translation2d.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/geometry/Translation2d.html" target="_blank">Translation2D class reference</a>
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/geometry/transformations.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/geometry/transformations.html" target="_blank">Transformations</a>
<br><br><br>A "Pose" in robotics represents the state of a controlled actuator. Most commonly  in FRC, we use this to reference the robot's position on the field for <a data-tooltip-position="top" aria-label="Basic Odometry+Telemetry" data-href="Basic Odometry+Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-odometry+telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Field Odometry</a> , as the robot itself is the most critical actuator in most cases. <br>However, be mindful that "pose" can still reference other actuators (like arms, elevators, etc), and many of these tools and techniques can be useful for actuators operating within a single plane (which tends to be a lot of them).<br><br>A Pose2d and a Translation2d differ in that a Pose has a rotation component. A Translation does not. <br>While these are conceptually very similar, the methods contained by these classes differ greatly. Pose2d is missing several classes you might expect to be present, when working with XY data, such as the distance between two Poses. <br>When working with Poses, watch for cases where .getTranslation2d()  method to drop the rotation component and open up methods that facilitate your math.<br><br>A Transformation (using Transform2d and Twist2d) represent a change to a Pose. These are most commonly used internally by WPILib odometry classes. <br><br><br>pose1.getTranslation2d().getDistance(pose2.getTranslation2d)
<br><br>ArrayList&lt;Pose2d&gt; targets = Arraylist.of(new Pose2d() /*targets here*/)
bot.getTranslation2d().nearest(targets)
<br><br>Pose2D and Translation2d can both be useful for generating simple linear paths or intermediate points using the interpolate method <br>startpose.interpolate(endpose,t);
<br>This method returns a pose between startpose and endpose, with t being effectively a percentage completion: At 0, it returns startpose, at 1, it returns endpose, and returns a pose along a linear path otherwise. <br>This can be useful for inverse kinematics, allowing you to generate straight line motion, even when the system motion is non-linear (such as a combination Arm+Elevator or Arm+Extension system).<br>For Drivetrains, it can be helpful for generating the final segment of paths to scoring objectives. Since these are often against a wall, re-setting from a bad lineup often means drivers backing up, since automated routines might be unable to deal with wall collisions. Using an initial pose slightly away from the wall, with a final pose at the target allows automated resets to apply a backoff automatically, resolving these issues.]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/pose2d.html</link><guid isPermaLink="false">Misc/Pose2d.md</guid><pubDate>Fri, 26 Sep 2025 03:53:20 GMT</pubDate></item><item><title><![CDATA[Subsystems]]></title><description><![CDATA[ 
 <br><br>
<br>None? Part of <a data-href="Robot Code Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a> and reference
<br><br>A "Subsystem" class generally accomplishes 4 distinct things in a robot project<br>
<br>Serve as a "resource" to constrain hardware for <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> requirement
<br>Hold tuning, configuration and code 
<br>House useful <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>
<br>House useful <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a>
<br>Any time you're performing multiple tasks in a single code class, careful consideration of your structure is important. <br><br>The first consideration of your robot should always be "What qualifies as a 'subsystem'" . Through experience or wisdom, you'll generally land on "A subsystem is a single actuator".<br>For more complex bots, you may be forced to consider a single subsystem as one or more <a data-tooltip-position="top" aria-label="Forward Kinematics" data-href="Forward Kinematics" href="https://stormbots.github.io/KnowledgeBase/level-2/forward-kinematics.html" class="internal-link" target="_self" rel="noopener nofollow">|kinematically linked</a> sets of mechanisms.<br>Chassis are something of an exception: Despite having multiple actuators/motors, they act as a single cohesive system, and have helper classes to manage some complexity.<br>This decision will create more subsystems than you think are necessary. However, it has a few advantages<br>
<br>The subsystems are smaller, simpler, and more manageable
<br>More subsystems --&gt; easier splitting of tasks and workloads 
<br>A couple simple <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> can easily link two subsystems that might seem useless when operated independently
<br>As a season progresses, unexpected developments might bring to light reasons to split a "double actuator subsystem". Having this already be done saves a lot of time and effort.
<br><br>When breaking down a robot, it's a good idea to model your subsystem's state using <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a>. This might be directly measured state such as isGamepieceLoaded or isAtPosition.<br>
Triggers can also model other implicit states such as isHomed or complex conditions like isJammed .<br>Encapsulating your system state as a Trigger makes it simple to pass into Commands, sequences, or even directly launch conditions based on them.<br>There are of course states that cannot be represented this way, such as the current arm angle or elevator height. However, it is often useful to represent a meaningful angle/height as a function, such as isAtGoal2Height, atScoringPosition, or isAtIdlePosition<br>Modelling your system this way promotes loose coupling between subsystems: A given command can check for required conditions across a variety of subsystems without having to strictly control the system. This makes for flexible, easy to write autos and sequences, and makes for easy to read code.<br><br>Pseudocode warning
This code will not compile or work out of the box, and just serves as a reference. 
<br><br>This is a functional, but barebones system. This is often suitable for testing, and many simple <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Roller</a> mechanisms on some bots. <br>public SimpleRollerSystem extends SubsystemBase(){
	SparkMax motor = new SparkMax(42,kBrushless);

	ExampleSubsystem(){
		//Normal constructor tasks
		//Configure motor
		//Set the default command; In this case, just power down the roller
		setDefaultCommand(setPower(0))
	}	

	public Command setPower(double power){
		return run(()-&gt;motor.set(power)); 
	}
}
<br><br>This is representative of a much more feature complete subsystem, including positional control. This is in line with the expectation of a Stormbot's subsystem suitable for competition.<br>This integrates <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a>, <a data-tooltip-position="top" aria-label="PID" data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PIDs</a>, and a <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profile</a>. <br>ExampleElevatorSubsystem extends SubsystemBase{
	SparkMax motor = new SparkMax(42,kBrushless);

	//See [[FeedForwards]] for additional information
	ElevatorFeedForward ff = new ElevatorFeedForward(...);

	//This is a relatively stramlined way to combine [[PID]] 
	// and [[Motion Profiles]]
	TrapezoidProfile.Constraints constraints = 
		new TrapezoidProfile.Constraints(maxv,maxa);
	ProfiledPIDController pid = 
		new ProfiledPIDController(kp,ki,kd,constraints);
	
	ExampleElevatorSubsystem(){
		//Normal constructor tasks, setup, and configuration
		//Configure motor
		
		//DefaultCommands help avoid leaving a system in an uncontrolled
		//state. Often, this simply means intentionally applying no motion.
		//No motion does *not* always mean a power of 0, as seen here!
		setDefaultCommand(setPower(ff.getKg()));
	}	

	//Triggers form the optimal way to transfer subsystem states/conditions
	//to external subsystems.
	public Trigger isAtPosition = new Trigger(pid::atGoal);
	
	//A manual command option is essential for tuning and calibration
	//Including the feed-forward here  
	public Command setPower(double power){
		return run(()-&gt;motor.set(power)); 
	}
	
	//Once tuned, a profiled PID is the gold standard for most control actions
	//The primary version _should not_ exit, as it complicates composition.
	public Command setPosition(double position){
		return startRun(()-&gt;{
			//Do initial reset for PID/profile
		},
		()-&gt;{}
			//Run the profiledPID
		});
	}
	
	//This version simply adds the exit condition to the setPosition
	//This helps clean up autos and sequences.
	public Command setPositionExit(double position){
		return setPosition(position).until(isAtPosition);
	}
}
<br><br>Sensor subsystems can help manage access of a single sensor across multiple subsystems. <br>ExampleSensorSubsystem extends SubsystemBase(){
	//Create a sensor object, whatever that looks like
	Sensor sensor = new Sensor(....);
	
	ExampleSensorSubsystem(){
		//Normal constructor tasks
		//Configure sensor
		//There's likely no need for a defaultCommand
	}

	//Set Triggers if there's obvious reasons to do so
	public Trigger isThingInRange = new Trigger(()-&gt;
		if(sensor.read &lt; 10) return true;
		return false;
	}
	
	// Repeat triggers as needed to have all useful states

	// Sometimes you just need analog data.
	public double getDistanceToThing(){
		return 0;//read sensor and return a sane value
	}
}
<br>In most cases, sensors can simply be integrated with the subsystem they're a part of. However, some subsystems are unclear, or serve multiple roles, and being a dedicated system helps prevent quirky <a data-tooltip-position="top" aria-label="Code Patterns" data-href="Code Patterns" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html" class="internal-link" target="_self" rel="noopener nofollow">Dependency Injection</a> of one subsystem into another.<br>Generally, sensor subsystems should be designed to avoid needing to require the subsystem, facilitating shared access. However, sometimes special cases are needed for very modal sensors. The most notable and common example is Vision systems where pipeline changes are necessary for different game pieces, zoom, or detection methods.<br>Sensor Systems are one of the places where it might be sensible to wrap the system as a <a data-tooltip-position="top" aria-label="Singletons" data-href="Singletons" href="https://stormbots.github.io/KnowledgeBase/level-2/singletons.html" class="internal-link" target="_self" rel="noopener nofollow">Singleton</a> , enabling easy shared access to read-only data without the scope management of dependency injection.<br><br>Whenever possible, it is recommended to minimize actuators within a single subsystem: Ideally, you want 1 actuator per subsystem. <br>The exception is for systems that are kinematic-ally linked: EG, moving one requires controlling the other part, and moving them independently is impossible, unsafe, or impractical. <br>The most common case of "too many actuators" applies to simple <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Roller</a> scoring systems added to height/position mechanisms, and the problem arises in a predictable way. Let's call it ElevatorScorer, consisting of an Elevator and a Roller:<br>
<br>The driver loads a game piece, and wants to score
<br>The driver presses PositionElevator, requiring ElevatorScorer
<br>The driver gets into position,  and presses Score button (also requiring ElevatorScorer)<br>
From a <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> perspective, this is no issue: The first command is cancelled, and the second one runs. 
<br>However, let's consider the two actuators: The first one is controlling the height, selecting one of several scoring positions. The second is controlling the rollers. These two actions are independent! <br>When running the "Score" routine, you're having to remember the last target height, or you have to have many additional functions to set target height and the scoring option. Your driver also cancelled the original go to height one; If they brushed it accidentally too early, they have to re-hit the PositionElevator button to set the height.<br>The real problem though, is if you're following good Command practice, you probably have commands that look like this:<br>public class ElevatorScorer extends SubsystemBase{
	public Command setHeight(double height){
		return run(()-&gt;/*Set the height*/)
	}	
	public Command setRollers(double height){
		return run(()-&gt;/*Set the roller speed*/)
	}
	public Command scoreWhenAtHeight(){
		return parallel(
			setHeight(30),
			setRollers(0)
		).until(isAtTargetHeight()
		.andThen(setRollers(-1))
		;
	}
}
<br>This will actually fail! The parallel command group cannot run both setHeight and setRollers at the same time, since they both require the same subsystem (elevatorScorer). It's clearly nonsensical to be unable to run both halves of the same subsystem at the same time, but by structuring things incorrectly, we've backed ourselves into a mess. <br>Our solutions now are <br>
<br>Use some gross, poorly documented secret command wrappers to ignore the requirements (.runAsProxy())
<br>Remove the requirements from the Rollers, violating the goal of Commands
<br>Duplicate a bunch of work to have "combo" commands to run both with a single requires.
<br><a data-tooltip-position="top" aria-label="Refactoring" data-href="Refactoring" href="https://stormbots.github.io/KnowledgeBase/misc/refactoring.html" class="internal-link" target="_self" rel="noopener nofollow">Refactor</a> our code into two subsystems
<br>While there's some cases to use the first few, the best solution long term is to refactor the code, making the systems properly independent. <br>The easy way to catch this design early is ask "Am I having to provide two inputs for one action". If so, they should probably be two seperate subsystems. Currently, WPILib has no way to properly "nest" subsystems, but a simple wrapper class can be used to house commands interacting with two strongly coupled, but independent subsystems (such as an Arm attached to an Elevator).]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/subsystems.html</link><guid isPermaLink="false">Misc/Subsystems.md</guid><pubDate>Sat, 27 Sep 2025 20:02:48 GMT</pubDate></item><item><title><![CDATA[Units]]></title><description><![CDATA[ 
 <br>Proper documentation:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/basic-programming/java-units.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/basic-programming/java-units.html</a><br>The Units library offers a robust, consistent way to maintain real world measurements across your code base. This has several useful applications. <br><br>Here's some problems with passing things around as Doubles<br>//Old and terrible
	double angleForTopGoal=17.4; //Degrees ; Unit documented in comment
	double angleForTopGoalDegrees=17.4; // unit documented in var name
	//elsewhere
	math.sin(MathUtils.deg2Rad(angleforTopGoal)); //Conversions are kinda unclean
	// This functionality also does not exist for inch-&gt;meters or velocities!
	
	//Declaring functions gets cluttered too
	// It's documented but not enforced... 
	void setPosition(double angleRad){....};
	//So it's easy to later call it with the wrong unit type
	exampleSubsystem.setPosition(angleForTopGoal); // Forgot to convert :bug: 
	
<br>But, with the Units library...<br>//New Hotness
	Angle topGoal=Degrees.of(17.4); //Unit declared directly as a type
	math.sin(topGoal); // Compiler error! math.sin takes a double.
	math.sin(topGoal.in(Radians)); // Easily fixed with conversion api

	//Our api is also very clearly defined
	void setPosition(Angle angleRad){....};
	//No bugs! any Angle type works, regardless of how it was created.
	exampleSubsystem.setPosition(angleForTopGoal);
<br>We can also utilize them just for consistent unit conversions.<br>Degrees.of(180).in(Radians);
Inches.of(124).in(Meters)
RPM.of(5700).in(Rotations.per(Second))
<br><br><br>This almost always streamlines the code, by ensuring that your various definitions can be easily converted within your class. <br>private const Distance lowestHeight=Inches.of(7);
private const Distance maxHeight=Inches.of(42);
<br>We'll generally fetch these units using a tape measure, which will give us inches. However, physics simulations and many other interactions will give us Metric units, so these can appear in unexpected locations!<br>This is doubly true with Angular units. Measuring and reasoning through them with Pi tends to be difficult, so we use Degrees instead. But math operations universally use Radians. This means we end up doing a fair amount of conversions for these unit types.<br><br>Having exposed public interfaces use Units streamlines streamlines subsystem and command interactions. Like a good API, this helps improve separation of concerns about what units are being used where. <br>class ExampleSubsystem(){
	public Command setPosition(Distance setpoint){...}
	public Angle setAngle(Angle setpoint){...}
	public Distance getPosition(){...}
	public Angle getAngle(){...}
}
<br><br>In some cases, we just have to use atypical units that don't match everything else in the file. When this comes up, the Units library helps ensure that the actual base number stays consistent with other measured values and our available measurement tools.<br>Inches.of(100).in(Meters);
Degrees.of(99).in(Rad)

Degrees.of(encoder.get()).in(Radians)
<br>This likely will come up fairly rarely if we're following good API conventions and using Units across the board, but there's a few cases such as encoder readings that often fall into this. <br><br><br>Generally, if you have a lot of math to do, you'll want to drop to a double to make things easier to type.<br>
There are some built in math functions for math involving other Unit types, which might make sense for certain tasks, however.  <br>public Command setPosition(Distance setpoint){
	return run(()-&gt;{
		double inches=setpoint.in(Inches);
		/* maths go here */
		motor.setReference(inches);
	})
}
<br><br>There's also a few cases where the data type is strictly controlled, and locked to a double or integer type for other APIs.<br>The most frequent occurrence of this is using APIs for hardware systems. If these systems are being used internally for lots of operatations, it might make sense to fully track them internally using a double or integer type, and then only convert them to Unit types at public interfaces.]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/units.html</link><guid isPermaLink="false">Misc/Units.md</guid><pubDate>Sat, 27 Sep 2025 19:08:56 GMT</pubDate></item><item><title><![CDATA[StormBreakers Tree]]></title><description><![CDATA[ 
 Introductory TopicsStandard TopicsCapstone TopicsSpecial Courses<br><br>Understand the typical Git operations most helpful for day-to-day programming<br><br>This module is intended to be completed alongside other tasks: Learning Git is best done by doing, and doing requires having code to commit.<br>
<br>Read through the <a data-href="#Git Fundamentals" href="https://stormbots.github.io/KnowledgeBase/about:blank#Git_Fundamentals" class="internal-link" target="_self" rel="noopener nofollow">Git Fundamentals</a> section
<br>Initialize a git repository in your project
<br>Create an initial commit
<br>Create several commits representing simple milestones in your project
<br>When moving to a new skill card, create a new branch to represent it. Create as many commits on the new branch as necessary to track your work for this card. 
<br>When working on a skill card that does not rely on the previous branch, switch to your main branch, and create a new branch to  represent that card.
<br>On completion of that card (or card sequence), merge the results of both branches back into Main.
<br>Upon resolving the merge, ensure both features work as intended.
<br><br>
<br>Understanding git
<br>workspace, staging, remotes
<br>fetching
<br>Branches + commits
<br>Pushing and pulling
<br>Switching branches
<br>Merging
<br>Merge conflicts and resolution
<br>Terminals vs integrated UI tools
<br><br>Git is a "source control" tool intended to help you manage source code and other text data.<br>Git has a lot of utility, but the core concept is that git allows you to easily capture your files at a specific point in time. This allows you to see how your code changes over time, do some time travel to see how it used to look, or just see what stuff you've added since your last snapshot.<br>Git does this by specifically managing the changes to your code, known as "commits". These build on each other, forming a chain from the start of project to the current code. <br>At the simplest, your project's history something like the following<br><br>Git is very powerful and flexible, but don't be intimidated! The most valuable parts of git are hidden behind just a few simple commands, and the complicated parts you'll rarely run into. Bug understanding how it works in concept lets you leverage it's value better.<br><br>Fundamental to Git is the concept of a "difference", or a diff for short. Rather than just duplicating your entire project each time you want to make a commit snapshot, Git actually just keeps track of only what you've changed.<br>In a simplified view, updating this simple subsystem<br>/**Example class that does a thing*/
class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
	ExampleSubsystem(){}
	public void runMotor(){
		motor.run(1);
	}
	public void stop(){/*bat country*/}
	public void go(){/*fish*/}
	public void reverse(){/*shows uno card*/}
}
<br>to this<br>/**Example class that does a thing*/
class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
	private Encoder encoder = new Encoder();
	ExampleSubsystem(){}
	public void runMotor(double power){
		motor.run(power);
	}
	public void stop(){/*bat country*/}
	public void go(){/*fish*/}
	public void reverse(){/*shows uno card*/}
}
<br>would be stored in Git as <br>class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
+	private Encoder encoder = new Encoder();
	ExampleSubsystem(){}
-	public void runMotor(1){
-		motor.run(1);
+	public void runMotor(double power){
+		motor.run(power);
	}
	public void stop(){/*bat country*/}
<br>With this difference, the changes we made are a bit more obvious. We can see precisely what we changed, and where we changed it.<br>
We also see that some stuff is missing in our diff: the first comment is gone, and we don't see go(), reverse() or our closing brace. Those didn't change, so we don't need them in the commit. <br>However, there are some unchanged lines, near the changed lines. Git refers to these as "context". These help Git figure out what to do in some complex operations later. It's also helpful for us humans just taking a casual peek at things. As the name implies, it helps you figure out the context of that change.<br>We also see something interesting: When we "change" a line, Git actually <br>
<br>Marks it as deleted
<br>adds a new line that's almost the same<br>
Simply put, just removing a line and then adding the new one is just easier most of the time. However, some tools detect this, and will bold or highlight the specific bits of the line that changed.
<br>When dealing with whole files, it's basically the same! The "change" is the addition of the file contents, or a line-by-line deletion of them!<br><br>Now that we have some changes in place, we want to "Commit" that change to Git, adding it to our project's history. <br>A commit in git is a just a collection of smaller changes, along with some extra data for keeping track. The most relevant is  <br>
<br>A commit "hash", which is a unique key representing that specific change set
<br>The "parent" commit, which these changes are based on
<br>The actual changes + files they belong to.
<br>Date, time, and author information
<br>A short human readable "description" of the commit. 
<br>These commits form a sequence, building on top from the earliest state of the project. We generally assign a name to these sequences, called "branches". <br>A typical project starts on the "main" branch, after a few commits, you'll end up with a nice, simple history like this. <br><br>It's worth noting that a branch really is just a name that points to a commit, and is mostly a helpful book-keeping feature. The commits and commit chain do all the heavy lifting. Basically anything you can do with a branch can be done with a commit's hash instead if you need to! <br><br>We're now starting to get into Git's superpowers. You're not limited to just one branch. You can create new branches, switch to them, and then commit, to create commit chains that look like this:<br><br>Here we can see that mess for qual 4  and mess for qual 8  are built off the main branch, but kept as part of the competition branch. This means our main branch is untouched. We can now switch back and forth using  git switch main  and git switch competition to access the different states of our codebase. <br>We can, in fact, even continue working on main adding commits like normal. <br><br>Being able to have multiple branches like this is a foundational part of how Git's utility, and a key detail of it's collaborative model. This is more traditionally referred to as a "git tree", since we can see it starts from a single trunk and then branches out into all these other branches.<br>However, you might notice the problem: We currently can access the changes in competition or main, but not both at once.  <br><br>Merging is what allows us to do that. It's helpful to think of merging the commits+changes from another branch into your current branch.<br>If we merge competition into main, we get this. Both changes ready to go! Now main can access the competition branch's changes. <br><br>However, we can equally do main into competition, granting competition access to the changes from main. <br><br>Now that merging is a tool, we have unlocked the true power of git. Any set of changes is built on top of each other, and we can grab changes without interrupting our existing code and any other changes we've been making! <br>This feature powers git's collaborative nature: You can pull in changes made by other people just as easily as you can your own. They just have to have the same parent somewhere up the chain so git can figure out how to step through the sequence of changes.<br><br>When managing changes, there's a couple places where they actually live. <br>The most apparent one is your actual code visible on your computer, forming the "Workspace". As far as you're concerned, this is just the files in the directory, or as seen by VSCode. However, Git sees them as the end result of all changes committed in the current branch, plus any additional, uncommitted changes.<br>The next one is "staging": This is just the next commit, but in an incomplete state. When setting up a commit, staging is where things are held in the meantime. Once you complete a commit, the staging area is cleared, and the changes are moved to a proper commit in your git tree.<br>
Staging is not quite a commit, as the changes represented here can be easily over-written by staging new changes from your Workspace. But, it's not quite the workspace either, and doesn't automatically follow modifications to your code.<br>
Because of this, Staging is extremely useful for code review! Staging a specific change is a great way to assert that that part is working and tested, even if you're not ready to make a commit yet.<br>In terms of our usual git tree, Staging and Workspace fit in right at the end, like so.<br><br>Lastly, is the actual commits that form your history. We generally won't deal with them individually, and instead just bundle them up in "branch". A branch is is just a helpful shorthand that names a specific commit, but in practice is used to refer to all prior changes leading up to that current commit.<br><br>Git is a distributed system, and intentionally designed so that code can be split up and live in a lot of different places at once, but interact with each other in sensible ways for managing the code.<br>The most obvious place it lives is your computer. You have a full copy of the git tree, plus your own staging and workspace. This is often called the "local" repository.<br>Next is a "remote" repository, representing a remote git server. Often this is Github, using the default remote name of "origin".<br>The important consideration is that your computer operates totally independently of the remote unless you intend to interact with it! This means you can do almost any Git task offline, and don't even need a remote to make use of Git. <br>Of course, being set up this way means that if you're not paying attention, you might not catch differences between Remote and Local git states. It's rarely an actual problem, but can be confusing and result in extra work. It's good practice to be aware of where your code is relative to origin, and make sure you push your code up to it  when appropriate.<br>When the origin is indicated specifically, you'll see it shown before the branch name: Main would go from main -&gt; origin/main, like you see here in <a data-tooltip-position="top" aria-label="Git from VSCode" data-href="#Git from VSCode" href="https://stormbots.github.io/KnowledgeBase/about:blank#Git_from_VSCode" class="internal-link" target="_self" rel="noopener nofollow">Git Graph</a>, showing that we have 1 commit locally that doesn't exist on the origin. Or, we're ahead by one commit.<br><img alt="git-graph-commit-history.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-graph-commit-history.png"><br><br>Often when doing merges, you'll run into a "merge conflict", and some parts of your code get replaced with massive compiler errors and weird syntax. Don't panic! <br>Merge conflicts happen when two branches change the same code. Git can't figure out what the "right answer" is, and so it needs a helping hand. To facilitate this, it has some special syntax so that you can see all information at a glance, but it's not always obvious that it's just being helpful! <br>Let's look at the simplest possible merge conflict: Being in main, and merging dessert<br><br>From an original file containing <br>Best food is pizza
<br>The commit in main has the following change<br>-Best food is pizza
+Best food is salad
<br>with dessert having this change<br>-Best food is pizza
+Best food is cheesecake
<br>The merge is then making Git decide what's the optimal food. Git is not equipped for this debate, so it's up to us humans. Git prepares the file in question using "merge markers" around the issue, which provide some useful info to resolve it<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  
Best food is salad  
=======  
Best food is cheesecake  
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dessert
<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD -&gt; indicates the start of a merge conflict. HEAD just means "last commit on current branch". Since we're on main, that means this code is just the result of following the code along the Main branch. VSCode will add additional information above this to help clarify.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dessert -&gt; is the end of merge conflict. dessert is the branch you're merging from; In other words, it's the result of following the proposed changes along the cheesecake branch. Again, VSCode will add additional info  to help. <br>======= -&gt; is the separator between the two branches'  code.<br>It's helpful to remember the goal of a merge: To put the two codebases together in a way that makes sense and is correct! So a merge conflict is resolved by making code that works, meaning there's several different ways to fix it!<br>One option is just accepting the change in your current branch, yielding<br>Best food is salad
<br>This just means you've ignored the proposed change from the other branch (dessert in this case)<br>The other option is accept the incoming change, and ignore what your branch had.<br>Best food is cheesecake  
<br>In some cases it's both! Maybe you're just fine with two best foods. <br>Best food is salad
Best food is cheesecake  
<br>Of course, you're after correctness. It's possible that after the update neither branch is quite right, and you have to adjust both.<br>Best side dish is salad
Best dessert is cheesecake  
<br>Or, it could be neither! Maybe the right solution has become something else entirely. <br>Best food is breakfast burritos
<br>Most of the time, a merge conflict should be very easy to deal with if you know the parts of the code you're working with.<br>
Just move the code around until it works like both branches expected, then delete the merge marker, separator, and any unnecessary code, and you're good to go!<br>And, don't worry if you missed one! Git will spot these conflict markers if you try to commit one without sorting it out. <br>If you get lost, ask for help! When dealing with code someone else wrote, you simply might not know what the best option is when coming out of it. That's fine! No tool can replace good communication.<br><br>Merge conflicts aside, just because a merge didn't have a conflict, doesn't mean the code works. A sometimes surprising result stems from the fact that Git doesn't understand code, it just understands changes! <br>The most likely reason you'll see this is someone changing a function name in one branch, while the other branch adds a new occurrence of it. Let's consider adding this code in our current branch<br>@@ MainBranch: RobotContainer.java @@
   //filecontext
+  exampleSubsystem.callSomeFunction();
   //filecontext
<br>and merging in this change from another branch.<br>@@ CleanupBranch: ExampleSubsystem.java @@
   //filecontext
-  public void callSomeFunction(){
+  public void betterNamedFunction(){
   //filecontext
<br>In this case, main doesn't know about the name change, and CleanupBranch doesn't know that you added a new call to it. This means callSomeFunction() no longer exists, leading to an error.<br>As with merge conflicts, it's up to you to figure out what's correct. In cases like this, you just want to adjust your new code to use the new name. But it sometimes happens that the other branch did something that needs to be changed back, such as deleting a function no one was using... until now you're using it.<br>Again, the purpose of the merge is to make it work! You're not done with a merge until everything works together as intended.<br><br>A lot of Git's power boils down to just using the simple usage of a few basic commands. <br>Git via command line vs Graphical tools 
While using the command line is optional, most good Git tools retain the name of these operations in graphical interfaces. After all, they're using the same operations behind the scenes.<br>
Because of this, a bit of command line knowledge can help clarify what the more user-friendly tools are trying to do, and show you exactly why they're helpful. 
<br><br>git init will creates a new git repository for your current project. It sets the "project root" as the current folder, so you'll want to double-check to make sure you're in the right spot! <br>VSCode's built in terminal will default to the right folder, so generally if your code compiles, you should be in the right spot. Once the repository is created, git commands will work just fine from anywhere inside your project.<br><br>Knowing what your code is up to is step 1 of git. These commands<br>git status just prints out the current repo status, highlighting what files are staged, and what have unstaged changes, and where you are relative to your remote. If you've used other git commands, the effects will show up in git status. Run it all the time!<br>git log will open a small terminal dialogue walking you through changes in your branch (hit q to exit). However, it's often unhelpful; It contains a lot of data you don't care about, and is missing clarity on ones you do.<br>git log --oneline tends to be more helpful ; This just prints a one-line version of relevant commits, making it much more useful. <br><br>git add &lt;files&gt; is all that's needed in most cases: This will add all changes present in a specific file. <br>git add &lt;directories&gt; works too! This adds all changes below the specified folder path. Be mindful to not add stuff you don't want to commit though! Depending on the project and setup, you may or may not want to add all files this way.<br>git add .  is a special case you'll often see in git documentation; . is just a shorthand for "the current folder" . Most documentation uses this to indicate "Stage the entire project", and is mostly helpful for your very first commit. Afterwards, we'd recommend a more careful workflow.<br>git reset &lt;staged file/dir&gt; will will remove a file's changes from Staging and put them back in the Workspace ; Meaning, the change itself is preserved, but it won't be changed.  In practice, you probably won't  do this much, as it's easier to use a GUI for this. <br><br>git commit -m "describe changes here" tends to be the beginner friendly approach. This makes a new commit with any staged changes.<br>git commit will usually open a small terminal editor called Vim with commit information and let you type a commit message. However, this editor is famous for it's "modal" interface, which is often surprising to work with at first. We'll generally avoid using it in favor of VSCode's commit tooling.<br>Quick Vim tutorial
If you get caught using the Vim editor for a commit, this is a quick rundown of the critical interaction.<br>
escape key-&gt; undo whatever command you're doing, and and exit any modes. Mash if you're panicking.<br>
i -&gt; When not in any mode, enter Insert mode (INSERT will be shown at the bottom). You can then type normally. Hit escape to go back to "command mode"<br>
: -&gt; start a command string; Letters following it are part of an editor command.<br>
:w -&gt; Run a write command (this saves your document)<br>
:q -&gt; Run a quit command (exit the file). This will throw an error if you have unsaved changes.<br>
:q! -&gt; The ! will tell Vim to just ignore warnings and leave. This is also the "panic quit" option.<br>
:wq -&gt; Runs "save" and then "quit" using a single command<br>
This means the typical interaction is i (to enter insert mode), type the message, escape, then :wq to save and quit.<br>
You can also abandon a commit by escape + :q!, since an empty commit message is not allowed by default. 
<br><br>git branch NameOfNewBranch: This just makes a new branch with the current name. Note, it does not switch to it! You'd want to do that before trying to do any commits!<br>Note, the parent node is the last commit of your current branch; This is not usually surprising if you're working solo, but for group projects you probably want to make sure your local branch is up to date with the remote!<br><br>git switch NameOfBranch: This one's pretty simple! It switches to the target branch. <br>git switch --detach &lt;commithash&gt; : This lets you see the code at a particular point in time. Sometimes this can be useful for diagnosing issues, or if you want to change where you're starting a new branch (maybe right before a merge or something). --detach just means you're not at the most recent commit of a branch. <br>You might see git checkout NameOfBranch in some documentation; This is a common convention to "check out" a branch. However, the git checkout command can do a lot of other stuff too. For what we need, git switch tends to be less error prone.<br>Switching + uncommitted changes
Note, Git will sometimes block you from changing branches! This happens if you have uncommitted changes that will conflict with the changes in the new branch. It's a special kind of merge conflict.<br>
Git has a number of tools to work around this, but generally, there's a few simpler options, depending on the code in question

<br>Delete/undo the changes: This is a good option if the changes are inconsequential such as accidental whitespace changes, temporarily commented out code for testing, or "junk" changes. Just tidy up and get rid of stuff that shouldn't be there. 
<br>Clean up and commit the changes: This is ideal if the changes belong to the current branch, and you just forgot them previously
<br>"Work in progress" commit: If you can't delete something, and it's not ready for a proper commit, just create a commit with message beginning with  "WIP"; This way, it's clear to you and others that the work wasn't done, and to not use this code. 
<br>use "git stash" the changes: This is git's "proper" resolution for this, but the workflow can be complicated, easy to mess up, and it's out of scope for this document. We won't use it often.

<br><br>git merge otherBranchName : This grabs the commits from another branch, and starts applying them to your current branch. Think of it as merging those changes into yours. If successful, it creates a merge commit for you.<br>git merge otherBranchName --no-commit : This does the merge, but doesn't automatically make a commit even when successful! This is often preferable, and makes checking and cleanup a bit easier. Once you've ran it, you can finish the commit in the usual way with git commit<br>git merge --abort is a useful tool too! If your merge is going wrong for whatever reason, this puts you  back to where you were before running it! <br>git merge (note no branch name) merges in new commits on the same branch; This is useful for  collaborate projects, where someone else might update a branch. <br><br>git fetch connects to your remote (Github), and makes a local copy of everything the remote system has! This is one of the few commands that actually needs internet to function. <br>Note, this does not change anything on your system. It does as the name implies, and just fetches it. Your local copies of branches remain at the commit you left them, so git fetch is always safe to run, and some tools run it automatically.<br><br>git pull will contact the remote system, and apply changes from the remote branch to your local branch.<br>Behind the scenes, this is just running git fetch and then git merge. So, if you run git fetch and then try to work without internet, you can still get things done! Just use git merge with no branch name.<br><br>git push does this. By default it uses the same name, making this a short and simple one. <br>Success not guaranteed
 git push will fail if the push would cause a merge conflict on the remote system. This can happen if the remote branch has been modified since you branched off of it.<br>
If this happens, you'll need to update your repository with git fetch or  git pull , resolve the conflict, and try again
<br><br>Handling Git operations from VS Code is normally a very streamlined operation, and it has good interfaces to do otherwise tricky operations. <br><br>This plugin provides some notable visualization tools that further improves Git handling in VS Code. We'll assume this is installed for the remainder of the tutorial here.<br>
<a rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" target="_blank">https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph</a><br>Install that first!<br><br>The  icon on left side will open the git sidebar, which is the starting point for many git operations. <br>Opening it will provide some at a glance stuff to review.<br><img alt="git-window+sidbar.png.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-window+sidbar.png.png"><br>We can see a lot of useful things:<br>At the top we can see any uncommitted changes, and the file they belong to. We'll deal with this when reviewing changes and making new commits.<br>
<img alt="git-commit-interface.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-commit-interface.png"><br>At the bottom (which might be folded down and labelled &gt; Outline or &gt; Graph), we can see our commit history for the current branch. The @main represents the current branch state, and  icon represents the Origin (Github). If we're ahead or behind the origin, we can see it at a glance here.  <br><img alt="git-sidebar-commit-log.png.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-commit-log.png.png"><br>Note, we also see main at the very bottom; That's always there, giving us our current branch at a glance. <br><br>The easiest way to review changes is through the Git Sidebar: Just click the file,and you'll see a split view. <br>Changes will be shown in one of two ways. "Additions" are shown as a green highlight on the right side. On the left, you can see a ///////////////// placeholder; This helps align the code so that you can easily keep track of where stuff gets inserted!<br><img alt="git-diffview-addition.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-diffview-addition.png"><br>Deletions look similar, but reversed. Left gets a red, right gets a placeholder.<br>
<img alt="git-diffview-deletion.png.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-diffview-deletion.png.png"><br>Changes to part of a line are either an addition and removal, or a small highlighted change of the particular bits. <br>Note, you can actually type here! The right hand side is editable, allowing you to revise things if you see a change that's concerning. That side just represents the current state of the file in the workspace.<br>
The left side is locked; This represents the prior state of the file, which can only be changed by adding more commits. <br>You can approve/confirm changes in a couple ways. The easiest is to simply use the "Stage Changes" button by the filename in the sidebar; This stages all changes in a particular file.<br>
<img alt="git-sidebar-state-changes.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-state-changes.png"><br>In many cases, it's helpful to handle them one by one: If you right click on a change (or selected text that includes one or more changes), you'll see some options besides the normal text editing ones<br>
<img alt="git-diffview-rightclick-stage.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-diffview-rightclick-stage.png"><br>As the name implies, you can Stage changes if you want them, Unstage them (if you want to remove it from the commit you're putting together).<br>
Note, you can also Revert it. In this case, reverting means that the change is gone! Added lines vanish, changed numbers go back to what they were, and reverting a deletion puts all the lines back! Be very careful here to not undo your work!<br>Note, that there's also a Revert/Discard Changes button too! Fortunately, this one checks with you. We'll rarely use it, but make sure to not hit it accidentally!<br>
<img alt="git-sidebar-discard-changes.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-discard-changes.png"><br>Once we've staged some changes, we'll any staged changes separate from any unstaged changes<br><img alt="git-sidebar-staging-field.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-sidebar-staging-field.png"><br>
You can commit with un-staged changes just fine, just be mindful! We'll touch on best practices later. <br>Once you've added all changes you want to include in the commit, just enter the message and click "Commit". Done! <br><br>VS Code has some useful built in operations to push or pull branches! These will typically pop up automatically, with the helpful options being <br>
<br>Push -&gt; Does a standard push
<br>Pull -&gt; Does a standard pull
<br>Publish Branch -&gt; This is a normal Push, but applies to newly created local branches. This normally requires a couple other small steps, which this handles automatically
<br>Sync -&gt; Don't use this one!
<br>The "Sync" button
Be careful about the "Sync" button! Unlike other VSCode options, "Sync" will try to push and pull at the same time; However, in case of a merge conflict, it might try to resolve it using esoteric git operations behind the scenes. While this sometimes works, when something goes wrong fixing it properly is extremely challenging!<br>
In almost all cases, using a git pull , verifying the merge, and then a git push is a better workflow!
<br><br>We're now looking at the <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" target="_blank">Git Graph</a> specific stuff, so make sure that's installed!<br>There's two ways to launch it. One is using VS Code's Command Palette, activated by CTRL+Shift+P then typing "View Git Graph" or "git log" to pull up this particular one.<br>
<img alt="git-gitgraph-command-palette.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-command-palette.png"><br>The other is by clicking "Git Graph" along the bottom toolbar.<br>
<img alt="git-gitgraph-bottom-bar.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-bottom-bar.png"><br>Both of these will take you to a good review interface, where you can see the status of many branches, the commit log, and how things merged and diverted! This is from our 2025 season code.<br><img alt="git-gitgraph-interface.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-interface.png"><br>Just this interface provides a lot of value: You can easily see the commit history, how branches have diverged and been merged, and check to see what branches are ahead or behind of the  origin. <br>If you click a commit, you get a more detailed status, but most notably what files were altered.<br>
<img alt="git-gitgraph-diff-detail.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-diff-detail.png"><br>
And, if you click the file in the commit details, it'll show you what that commit changed!<br>
<img alt="git-gitgraph-diffview.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-gitgraph-diffview.png"><br>
This is a very fast and effective way to look through your project and catch up on what's happening. <br>There's a lot of other value here if you click around, including being able to right click and checkout or switch to various branches!<br><br>VS Code's terminal often pops up during many other operations, but if you don't see it, you can access it through the menu.<br>
<img alt="git-terminal-new.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-terminal-new.png"><br>Since we usually work on Windows, this will often open up a Powershell, which is usually sub-optimal for what we want to use a terminal for. Git Bash is usually nicer. You can change this with the Command Pallete (CTRL+Shift+P), and selecting Terminal: Select Default Profile. <br><img alt="git-terminal-change-default.png" src="https://stormbots.github.io/KnowledgeBase/assets/git-terminal-change-default.png"><br>If Bash is available, click it! Any new terminals will use the Git bash, which will have color, some at-a-glance git info, and generally more helpful all around. <br><br>There's a lot of tools that interact with your Git repository, but it's worth being mindful about which ones you pick! A lot of tools wind up changing normal git operations into renamed or altered versions that do a lot of things at once. This can make learning it harder, and if something goes wrong, fixing the results can be extremely difficult. Stick to the basics until you know what's happening and you can properly judge if a new tool is worth using.<br><br><br>Creating the initial project setup:<br>
<br>git init to set up our new project.
<br>git add .   to stage all the files in their blank, default state
<br>Commit the code, using VSCode's interface or with the terminal git commit -m "initial commit" 
<br>Doing the code work:<br>
<br>git branch featurebeingadded to set up a new branch for your task
<br>git switch featurebeingadded to select your new branch
<br>Add the code
<br>Review the new code using VSCode, staging parts that are confirmed to work
<br>Commit the code (via Code or terminal)
<br>Repeat commits until done
<br>Handling review and merging. Be mindful of local and remote branch states for this!<br>
<br>Test and review your  code! Make sure it works in the final state.
<br>git fetch to ensure your git repo is aware of any changes.
<br>git merge origin/main --no-commit -&gt; Bring in all new changes
<br>Fix, test, review your code with all the new base project code.
<br>git commit to finalize the merge.
<br>git push to push your branch with the merge completed.
<br>Work with your maintainer (a mentor or veteran) to pull your new, validated changes back into main! 
<br><br>Branches are best when they're small, focused, and well defined. <br>A great workflow is using so called "topic branches" or "feature branches": In this workflow, a branch represents a feature you're adding, or a bug you're fixing. Once the feature is added and working, the branch is Done. You merge your branch back into the Main branch, and you can move onto another feature in a new branch!<br>By doing this, you keep each branch simple, easy to test, and easy to merge. It also helps prevent the issue of long-running branches; Where your code is isolated from a long time, and drifts apart from everyone else's code in main. That ends up with you not working on quite the same code base as other people, and you'll miss out on features, fixes that everyone else has, and they'll miss out on yours. <br>A good feature branch name also helps keep you as a programmer constrained to the task at hand.<br><br>To facilitate "feature branch" convention, name your branches after feature itself, rather than the part of code it's affecting. Make sure that the branch name implies an "end state" at which point you can consider it Done and stop working on it. <br>As an example, some good initial branch names are add-far-shots, add-climb-routine, or fix-intake-stalling-issue. Since we're usually adding or fixing things, we can often omit that in the actual name leaving us with far-shots, climb-routine, intake-stall-issue), but it's helpful to always pretend it's there unless a clearer verb exists (like remove or adjust. <br>Early on, you might be tempted to name your branches after robot systems, like intake, shooter, or the like. But don't do this! The intake will always exist on the robot, so your branch has no clear end state!<br>
Instead, name it something like  intake-bringup. This provides an end-condition: Once the intake is brought up, functioning, and tested, the branch is done, and you can merge it back into main. <br>In some cases, it's helpful to indicate which part of the robot you're working on though: The optimal method is using subsystemname/feature. This is especially true of features relevant to various subsystems like bringup, which just yields intake/bringup, elevator/bringup, etc. <br><br>Merging is more useful than just sending your changes back to Main. You can use merging to keep up with other features that interact with the code you're working with.<br>As an example, let's say you're trying to bring up an Indexer system, which interacts with a Intake and a Shooter. During early development, you might see some branches like this<br><br>Intake and Shooter aren't done enough to merge back into main, but the indexer can't really be tested because you need to move it through the intake and shooter. But, you also don't want to actually do all that work yourself. <br>So, just merge the intake/bringup and shooter/bringup branches! <br><br>There you go! Now you can continue your work, using the preliminary work from the other branches. As they adjust and fix things, you can merge their code, and they could also merge yours into their branches before finally verifying 2 or 3 of these subsystems work properly.<br>There's a catch here: The branches in question might not be fully ready for you to pull them! It's always a good idea to talk to whoever's working on that code to make sure that it's in a state that's good to go. Sometimes they'll just need to adjust up one or two things, fix a variable/method name, or other times they might suggest you wait for some bigger cleanup or process fixes.<br><br>Similar in concept to the above in some ways! By our process definitions, Main should always be in a good state, meaning you can pull it at any time. So, before declaring your branch Done and getting it in Main, go ahead and pull Main and test things first!<br><br>Now you can test the indexer in the full codebase without any risk of accidentally putting a bug in main, and any adjustments are part of the indexer/bringup branch like shown here<br><br>At long last, with everything fully integrated, we can finally get our changes back into main, knowing with confidence it works as expected.<br>Git Basics<br><br>
<br>Examine a robot design
<br>Generate a design plan indicating the breakdown
<br>Recommended: <br>
<br><a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>
<br><a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>
<br><a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a>
<br>Cursory check of the available subsystem types
<br><br>This guide runs through how to examine a robot design, analyze the mechanics, game piece path, and form a plan to generate a code structure to control the system.<br><br>For an FRC bot, "move the game piece" is the fundamental design objective, and serves as a great way to step through the bot from a design process. <br>If you start at "need to obtain a game piece" and then proceed through game play cycles, you'll naturally follow a good analysis process, and observe the various handoffs and subsystem interactions. <br>The game piece flow often gives an intuitive sense for "forward" direction in many systems where it might be ambiguous. "intake -&gt; score" as positive often provides a streamlined notation to make testing and bringup of systems a bit more consistent.<br><br>Being able to identify basic mechanisms is key to being able to model a robot in code. This non-exhaustive list should help provide some vocabulary for the analysis on typical bots.<br><a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a> The simplest mechanical system: A motor and a shaft that spins.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Flywheel" data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">Flywheel</a> A specialized Roller system with extra weight, intended to maintain a speed when launching objects.<br>
<a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexer</a> A mechanism to precisely align, prepare, or track game pieces internally in the robot. Often a Roller, but can be very complex.<br>
<a data-tooltip-position="top" aria-label="Superstructure Shooter" data-href="Superstructure Shooter" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Shooter</a> A compound system, usually consisting of at least a Flywheel and an Indexer, and sometimes an Arm or other aiming structure.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intake</a> A specialized compound system intended for getting new game pieces into the robot. Generally consists of a Roller, often with another positioning mechanism like an Arm.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> A system that rotates around a pivot point. Usually positions another subsystem.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> A system that travels along a linear track of some sort. Typically up/down, hence the name.<br>
<a data-tooltip-position="top" aria-label="Swerve Basics" data-href="Swerve Basics" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Drive</a> or <a data-href="Differential Drive" href="https://stormbots.github.io/KnowledgeBase/level-1/differential-drive.html" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive</a>: Makes robot go whee along the ground.<br>The systems in your robot will often take these basic archetypes and rename them to something else, and in some cases combine them into compound mechanisms.<br>Step 1 is break down the robot into component mechanisms, and follow up how they link to eachother. <br><br>As you're breaking down your system, it's necessary to define what values correlate to a "positive" motion. This is not as trivial as it sounds for some bots, but is necessary to ensure the team can refer to the motions and directions with the same language.<br>
<br>Elevator style systems go up, so up -&gt; Positive
<br>Arms should follow math convention of anti-clockwise-&gt; Positive. It's easiest to pair 0 and "horizontal" 
<br>Drivetrains seem obvious: Positive means forwards. However, this assumes you know "what side is the front": If you have intakes and scoring on different sides, this usually requires discussing it with the designers to get everyone in agreement. 
<br>Intake,  Indexer, and scoring mechanisms can be trickier. Often, the simplest route is to consider "intaking direction positive", which often defines all systems at once. 
<br>By doing all this, it becomes much easier for hop between subsystem bringups and diagnose motor and encoder configurations later.<br><br>As you track game piece flow, you will see natural states where the robot has inventory change (acquiring/losing game pieces), or changes posture (extending/retracting intakes, raising/lowering elevators, etc).<br>As the robot moves between states (such as unloaded, loading, loaded, preparing to score, scoring), keep an eye on both the states and the transitions to ensure that things go smoothly.<br><br>In a few places, you'll probably see certain state transitions that are a bit less clear, or rely on information the robot may not have. <br>The classic example is the intake: If your robot transitions from unloaded-&gt;loaded , you may need to shut off the intake right away to prevent intaking excess game pieces, getting fouls and jams. However, if there's no good detection method, you may not be able to quickly trigger a shutoff.  This often requires a supplemental sensor, and additional handling logic.<br>Watch your state transitions for places where a sensor provides significant benefits in robustness, efficiency, or aiding driver control. If so, consider adding sensors, and working with mechanical teams to facilitate placement.<br><br>Most FRC mechanisms have physical limits that must be coded. These are often trivial to document, but notable.<br>While often avoided in bot designs,in some cases multiple systems will attempt to occupy the same physical space. This is clearly a problem, and one that needs careful consideration. In some cases these can be trivial handled, but in other cases the entire robot code base must plan around it.<br>A simple collision fix is a lockout: Say a grabber is mounted on the elevator, and when extended, it collides with the intake. Therefore, we define 2 lockouts: If elevator is below X, the grabber cannot extend. If the grabber is extended, then it cannot go below X. The two systems are intertwined, but have a lockout system that helps manage their motions.<br>For more complex cases, simple lockouts don't work, and systems must follow a more complex series of state transitions, forming a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machine</a>. We often avoid programming our robots with explicit super-structure state machines, but it's a common <a data-tooltip-position="top" aria-label="Code Patterns" data-href="Code Patterns" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html" class="internal-link" target="_self" rel="noopener nofollow">pattern</a> in FRC for designs with significant collision potential or complex motion patterns.<br>Identifying these issues early helps you plan your overall code structure.<br><br>Based on the above, you can identify certain code features that the robot must have to accomplish game tasks, do self-management, and otherwise hit your goals. These are general things like "Aim at the goal", "shoot a game piece", "extend up to scoring position", etc. High level overviews of the primary things you're doing.<br>For an example of this stage, see the case study below.<br>There's also few standard house-keeping tasks due to system constraints or evergreen rules:<br>
<br>The robot must have suitable methods to home or acquire correct internal system states
<br>Robots typically have an initial starting in-frame configuration, which may require special handling
<br>Manage the disable/re-enable transition (which may or may not be trivial depending on bot) 
<br><br>With the mechanics, code, and game piece flow understood, it's worth considering what the driver interface will resemble. Once again iterate through the full game piece flow from floor to score, as well as any endgame or alignment tasks.<br>As you do this, look for button sequences that seem problematic: Notably button sequences that always have to go in a fixed sequence, buttons that might misbehave when loaded/unloaded or in certain bot states, or "combo" multi-button presses that put undue stress on the driver. Your goal is to have each input be unambiguous and safe.<br>In practice, each button will likely control a small sequence of robot actions and safety checks; This particular analysis step is intended to facilitate identifying any missing features, sensors, or processes that would make robust control challenging. <br>In some cases, we also need to consider the amount of available buttons: It may need to be the cases that buttons are "modal", and do two different things depending on what "mode" the robot is in. Common modal states are "which game piece is loaded", or "if X is deployed we're doing Y now". Be careful here: Any mode switches need to be very obvious to drivers, and we want to facilitate muscle memory as much as possible.<br>Remember to leave buttons for "error correction actions"! You'll always need at least one button to "reset" the robot, clear jams, or eject badly loaded game pieces. <br>The gold standard of inputs is a "win button"; The driver starts the match, hits a button, then wins. While this is not attainable in practice, we can split a complex game into smaller tasks that can be accomplished and managed by a single button; This lets the drivers focus on the higher level match strategy rather than manage the robot's interactions.<br>Note that your initial input analysis will not be final! Drivers will have their own preferences, and later considerations will pop up. This step is a sanity check.<br><br>Next is to work toward a relatively complex auto. This is typically one that at scores one game piece, and acquires+scores a second. <br>Unlike a Tier 1 "get the robot on the field" auto which is "score a piece and stop", a Tier 2 auto requires consideration for re-alignment, odometry, and re-acquisition.  Even if we never build this auto, putting these details in our roadmap early on can help guide our code toward a solution that will work. If we do not do this, it's easy to lock ourselves into a Tier 1 auto that we cannot extend easily. When given a choice on how to code our autos, we want to ensure that a useful auto can be the foundation for a more complex one.<br>Note that implementing the auto indicated here is not a requirement: Considering how we can make it happen and what supporting infrastructure is needed is the valuable part at this stage.<br><br>We're now good to code! At this time you can <br>
<br>Plan out your subsystems, knowing how they interact and should be split.
<br>Plan out your subsystem APIs and interfaces
<br>Plan any lockout management
<br>rough out what your button sequences should be
<br>Get a rudimentary auto to serve as a starting point for more complex ones
<br>The final step of analysis and prep is to "stub" your subsystems: EG, writing all the functions and signatures (parameters+return values) , but not actually putting in the code that makes them work. <br>The goal of this step is to ensure that higher level work (like buttons and autos) can be scripted out in advance. This means  code like intake.intake() might not work, but it can still be put into code and left in place until it does.<br><br><br><a data-tooltip-position="top" aria-label="https://github.com/stormbots/Crescendo/" rel="noopener nofollow" class="external-link" href="https://github.com/stormbots/Crescendo/" target="_blank">Crescendo Bot Code</a><br>
Note The actual code for this bot may differ from this breakdown; This is based on the initial design provided, not the final version after testing. <br>Game info
The game piece for this game is an 2" tall, 14" diameter orange donut called a "note", and will be  referenced throughout this breakdown.<br>
There are two note scoring objectives: Shooting into an open "speaker" slot about 8' high, or placing into an "amp", which is a 2" wide slot about 24" off the ground.<br>
Lastly, climbing  is an end game challenge, with an additional challenge of the "trap", which is effectively score an amp while performing a climb. 
<br><br>For this, we'll start with the game piece (note) path, and just take note of what control opportunities we have along this path. <br>The note starts on the floor, and hits the under-bumper intake. This is a winding set of linked rollers driven by a single motor. This system has rigid control of the note, ensuring a "touch it own it" control path.<br>Indexer: The  game piece is then handed off to an indexer (or "passthrough"). This system is two rollers + motors above and below the note path, and have a light hold on the note; Just enough to move it, but not enough to fight other systems for physical control.<br>Flywheel: The next in line is a Flywheel system responsible for shooting. This consists of two motors (above and below the note's travel path), and the rollers that make physical contact. When shooting, this is the end of game piece path. This has a firm grip to impart significant momentum quickly.<br>Dunkarm + DunkarmRollers: When amp scoring/placing notes, we instead hand off to the rollers in front of the shooter. These rollers are mounted on an arm, which move the rollers out of the way of the shooter, or can move it upward. <br>Shooter: The Indexer and Shooter are mounted on a pivoting arm, which we denote as the shooter. This allows us to set the note angle.<br>Climber: The final mechanism is the climber. There's two climber arms, each with their own motor.<br><br>The indexer has a single <a data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">LaserCan</a> rangefinder, located a just before the shooter. This will allow detection of a game piece being loaded or not, and with some math, the precise positioning of the game piece.<br><br>Again let's follow the standard game piece and flow path. <br>
<br>Intake+Indexer interaction: A note can be held by both Intake and Indexer simultaneously. In this case, the intake exerts control.
<br>Intake + Shooter : If the shooter angle is too high, note transfer to the indexer will fail. 
<br>Indexer + Flywheel: A note can be held by both intake and indexer simultaneously. Again, the shooter wins, but fighting the indexer would impact accuracy/momentum.
<br>Flywheel + Dunkarms: A note getting passed into the dunkarm rollers is held more strongly by the shooter than the dunkarm rollers. This can only be done at a fixed angle combination.
<br>Climber + Dunkarms. When climbing without trap scoring, the chain will come down on the dunkarms. The climber will win with catastrophic damage. 
<br>Climber + Shooter: When trap scoring, the dunk arms are out  of the way, but the chains will come down on the shooter.
<br>Dunkarm and shooter: The rollers can potentially be in the way of the shot path. This can occur at low shot angles, or if the dunkarm is moving down after other scoring.
<br>This seems to be about it for conflicts between control systems<br>We should  also do a quick check of the hard stops; These serve as reference points and physical constraints.<br>
<br>Dunkarms have a lower hard stop. It has no upper hard stop, but eventually rotates too far and breaks wiring.
<br>Shooter has a bottom hard stop. It has a upper end of travel, but no physical stop.
<br>Climber has a bottom hard stop, and a upper end of travel. In both cases, high torque movement will cause damage when ran into.
<br>All other systems are rollers, with no hard or soft stops. 
<br><br>Before getting into how the code is structured, let's decide what the code should be doing during normal gameplay cycles<br>
<br>Intake note: This will be running the intake, feeding the note into the indexer. Since running too far will feed it into the shooter, we can use our indexer sensor to end the process. 
<br>Shot preparation: Before shooting a note, we need to make sure the note is not pushed into the flywheels. Once that's done, we need to get to the target angle and speed. 
<br>Shooting: The indexer needs to feed the note into the flywheel.
<br>Score amp: This takes a note held in the dunk arm rollers, rotate up, and then rotate the rollers to score it. 
<br>Load dunkarm rollers: This requires the dunkarm + shooter to be in the desired lineup, then the indexer feeds the note into the shooter, which in turn feeds it into the dunk arm rollers. The rollers must be capable of stopping/managing the note to prevent it from falling out during this process.
<br>Climbing,  no trap: Climber goes up, climber comes down, and doesn't crush the dunkarms.
<br>Scoring Trap: This requires maneuvering around the chain to get the dunkarms in position. From there, it's just climbing, then amp scoring. 
<br><br>We can now start looking at how to structure the code to make this robot happen. Having a good understanding of <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> flow helps here, but is not required.<br>We'll start with subsystems breakdowns. Based on the prior work, we know there's lots of loose coupling: Several subsystems are needed for multiple different actions, but nothing is strongly linked.  The easy ones are:<br>
<br>Intake (1 motor)
<br>Indexer (2 motors, the top and bottom)
<br>Shooter (the pivot motor)
<br>Flywheels (the two motors, top and bottom)
<br>Climber (two motors, left and right)<br>
This allows commands to  pair/link actions, or allow independent responses. 
<br>The Dunkarm + Dunkarm rollers is less clear. From an automation perspective, we could probably combine these. But the humans will want to have separate buttons for "put arm in position" and "score the note". To avoid command sequence conflicts, we'd want these separate.<br>
<br>Dunkarm (1 motor, the pivot)
<br>Dunkarm Rollers (1 motor for the roller pair)
<br>Next we define what the external Command API for each subsystem should look like so we can manipulate them.<br>
<br>Intake:

<br>Intake command to pull in a note. 
<br>Eject: In case we have to get rid of a note


<br>Flywheel:

<br>Shoot note. Would need the appropriate RPM, which may be constant, or vary based on vision/sensor data. 
<br>Pass to dunk arm. This is likely just running at a target RPM, but may use other logic/control routines.
<br>Retract note: In case something goes wrong, perhaps we want to pull the note in and clear the shooter for a reset.
<br>isAtTargetRPM check, which is critical for sequencing


<br>Shooter Pivot

<br>SetAngle 
<br>isAtTargetPosition for sequencing


<br>Dunkarm:

<br>Set Angle. Would just need an angle reference.
<br>isAtTargetAngle check for sequencing
<br>Manual positioning: The human may  control this directly for trap score line up


<br>Dunkarm Rollers:

<br>Load, which is likely just a speed/power suitable for controlled intaking from the robot
<br>Score Amp, another speed/power appropriate for this task
<br>Score Trap, Another speed/power for the task
<br>drop/eject, just get rid of a note if something went wrong.
<br>getPosition, since certain tasks might require specific positions


<br>Climber: 

<br>set height: Basically the only job of this system is go up/go down
<br>Is At Target Height check. Maybe useful for sequencing


<br>Indexer

<br>load/intake: For working with the intake to load notes
<br>hasNote check; This is required for "end of intake"
<br>feedShooter: Feed a held note into the flywheels as part of the shooting process


<br>With this, we now have the structures in place to start asserting how we'd define more complex actions and sequencing.<br><br>Before we really dive into writing all our robot code it's now, it's helpful to walk through a basic game piece structure, and make a couple "high level code" sequences to verify that you can in fact do the things you want to do. Often you'll catch missing details this way. <br> This will use the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> and <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> syntax, but it should be fairly readable without specific knowledge.<br>We know from prior analysis what our intake process looks like: Run the intake, feed it into the indexer, then stop when it hits the indexer's sensor. This should look something like this:<br>Commands.parallel(
	intake.intake(),
	indexer.intake()
).until(indexer.hasNote());
<br>Once we have a note, we then have to score it. For now, we'll simply assume a fixed position on the field (which is what we did at this bot's first competition!)<br>Commands.sequence(
	Commands.parallel(
		flywheel.setRPM(3000),
		pivot.setAngle(60)
	).until(pivot.isAtTarget().and(flywheel.isAtTargetRPM())),
	
	Commands.parallel(
		flywheel.setRPM(3000),
		pivot.setAngle(60),
		indexer.feedShooter(),
	).withTimeout(500)
)
<br>And, now we can actually score. This code isn't ideal (we have duplicated sections and magic numbers), but that comes later. We're in proof of concept stage.<br>If we followed through with this exercise for the other <a data-href="#Critical code tasks" href="https://stormbots.github.io/KnowledgeBase/about:blank#Critical_code_tasks" class="internal-link" target="_self" rel="noopener nofollow">Critical code tasks</a> noted above, we could fully validate all parts of our system to make sure we've covered all necessary command and trigger interfaces.<br><br>With this, we've somewhat defined have confirmed our game plan for the bot code breakdown works, and provides us with the work Subsystem program<br>Be aware that "simple" routines like this might sometimes have surprising interactions mechanically. Indexers (or Passthroughs) are full of these. In this bot, the actual code's shoot sequence actually uses the intake too, since the note would often snag there, causing shot failures.<br>
Similarly, intaking initially required running the flywheels; We had to stop them or the note would catch, going from an intake process to an intake-and-immediately-shoot process!Robot Design Analysis<br>See Official Documentation
The official radio documentation is complete and detailed, and should serve as your primary resource.<br>
<a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/" target="_blank">https://frc-radio.vivid-hosting.net/</a>
However, It's not always obvious what you need to look up to get moving. Consider this document just a simple guide and jumping-off point to find the right documentation elsewhere
<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/quick-start-guide" target="_blank">https://frc-radio.vivid-hosting.net/overview/quick-start-guide</a><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html" target="_blank">https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html</a><br><br>You don't! The Field Technicians at competitions will program the radio  for competitions. <br>When configured for competition play, you cannot connect to the radio via wifi. Instead, use an ethernet cable, or <br><br>The home radio configuration is a common pain point<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview" target="_blank">https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview</a><br><br>This option is the simplest: Just connect the robot via an ethernet or USB, and do whatever you need to do. For quick checks, this makes sense, but obviously is suboptimal for things like driving around. <br><br>The radio does have a 2.4ghz wifi hotspot, albeit with some limitations. This mode is suitable for many practices, and is generally the recommended approach for most every-day practices due to ease of use.<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions" target="_blank">https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions</a><br>Note, this option requires access to the tiny DIP switches on the back of the radio! You'll want to make sure that your hardware teams don't mount the radio in a way that makes this impossible to access. <br><br>This option uses a second radio to connect your laptop to the robot. This is the most cumbersome and limited way to connect to a robot, and makes swapping who's using the bot a bit more tricky. <br>However, this is also the most performant and reliable connection method. This is recommended when doing extended driving sessions, final performance tuning, and  other scenarios where you're trying to simulate competition-ready environments. <br>This option has a normal robot on one end, and your driver-station setup will look the following image.  See <a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/practicing-at-home" target="_blank">https://frc-radio.vivid-hosting.net/overview/practicing-at-home</a> for full setup directions<br>
<img alt="vidid-radio-wifi-bridge.png.png" src="https://stormbots.github.io/KnowledgeBase/assets/vidid-radio-wifi-bridge.png.png"><br><br><br>Port forwarding allows you to bridge networks across different interfaces. <br>The practical application in FRC is being able to access network devices via the USB interface! This is mostly useful for quickly interfacing with Vision hardware like the <a data-tooltip-position="top" aria-label="Limelight Basics" data-href="Limelight Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight</a> or <a data-tooltip-position="top" aria-label="PhotonVision Basics" data-href="PhotonVision Basics" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Photonvision</a> at competitions.<br>//Add in the constructor in Robot.java or RobotContainer.java

// If you're using a Limelight
PortForwarder.add(5800, "limelight.local", 5800);
// If you're using PhotonVision
PortForwarder.add(5800, "photonvision.local", 5800);
<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html" target="_blank">https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html</a><br><br>The radio has some scriptable interfaces, allowing programmatic access to quickly change or read settings. <br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced" target="_blank">https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced</a>Robot Radio<br><br>Understand how to efficiently communicate to and from a robot for diagnostics and control <br><br>
<br>Print a notable event using the RioLog
<br>Find your logged event using DriverStation
<br>Plot some sensor data (such as an encoder reading), and view it on Glass/Elastic
<br>Create a subfolder containing several subsystem data points.
<br>As a telemetry task, success is thus open ended, and should just be part of your development process; The actual feature can be anything, but a few examples we've seen before are<br><br>By definition, a program runs exactly as you the code was written to run. Most notably, this does not strictly mean the code runs as it was intended to. <br>When looking at a robot, there's a bunch of factors that can have be set in ways that were not anticipated, resulting in unexpected behavior.<br>Telemetry helps you see the bot as the bot sees itself, making it much easier to bridge the gap between what it's doing and what it should  be doing. <br><br>Simply printing information to a terminal is often the easiest form of telemetry to write, but rarely the easiest one to use. Because all print operations go through the same output interface, the more information you print, the harder it is to manage.<br>This approach is best used for low-frequency information, especially if you care about quickly accessing the record over time. It's best used for marking notable changes in the system: Completion of tasks, critical events, or errors that pop up. Because of this, it's highly associated with "logging".<br>The methods to print  are attached to the particular print channels<br>//System.out is the normal output channel
System.out.println("string here"); //Print a string
System.out.println(764.3); //you can print numbers, variables, and many other objects

//There's also other methods to handle complex formatting.... 
//But we aren't too interested in these in general.
System.out.printf("Value of thing: %n \n", 12);
<br>A typical way this would be used would be something like this:<br>public ExampleSubsystem{
	boolean isAGamePieceLoaded=false;
	boolean wasAGamePieceLoadedLastCycle=false;
	
	public Command load(){
		//Some operation to load a game piece and run set the loaded state
		return runOnce(()-&gt;isAGamePieceLoaded=true);
	}
	
	public void periodic(){
		if(isAGamePieceLoaded==true &amp;&amp; wasAGamePieceLoadedLastCycle==false){
			System.out.print("Game piece now loaded!");
		}
		if(isAGamePieceLoaded==false &amp;&amp; wasAGamePieceLoadedLastCycle==true){
			System.out.print("Game piece no longer loaded");
		}
		wasAGamePieceLoadedLastCycle=isAGamePieceLoaded
	}
}
<br>Rather than spamming "GAME PIECE LOADED" 50 times a second for however long a game piece is in the bot, this pattern cleanly captures the changes when a piece is loaded or unloaded.<br>In a more typical <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command based robot</a> , you could put print statements like this in the end() operation of your command, making it even easier and cleaner. <br>The typical interface for reading print statements is the RioLog: You can access this via the Command Pallet (CTRL+Shift+P) by just typing &gt; WPILIB: Start Riolog. You may need to connect to the robot first. <br>These print statements also show up in the DriverStation logs viewer, making it easier to pair your printed events with other driver-station and match events. <br><br>Data in our other telemetry applications uses the NetworkTables interface, with the typical easy access mode being the SmartDashboard api. This uses a "key" or name for the data, along with the value. There's a couple function names for different data types you can interact with<br>// Put information into the table
SmartDashboard.putNumber("key",0); // Any numerical types like int or float
SmartDashboard.putString("key","value"); 
SmartDashboard.putBoolean("key",false);
SmartDashboard.putData("key",field2d); //Many built-in WPILIB classes have special support for publishing
<br>You can also "get" values from the dashboard, which is useful for on-robot networking with devices like <a data-tooltip-position="top" aria-label="Limelight Basics" data-href="Limelight Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight</a>, <a data-tooltip-position="top" aria-label="PhotonVision Basics" data-href="PhotonVision Basics" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-basics.html" class="internal-link" target="_self" rel="noopener nofollow">PhotonVision</a>, or for certain remote interactions and non-volatile storage.<br>
Note, that since it's possible you could request a key that doesn't exist, all these functions require a "default" value; If the value you're looking for is missing, it'll just  give you the provided default.<br>SmartDashboard.getNumber("key",0);
SmartDashboard.getString("key","not found");
SmartDashboard.getBoolean("key",false);
<br>Networktables also supports hierarchies using the "/" seperator: This allows  you to separate things nicely, and the telemetry tools will let you interface with groups of values.<br>SmartDashboard.putNumber("SystemA/angle",0);
SmartDashboard.putNumber("SystemA/height",0);
SmartDashboard.putNumber("SystemA/distance",0);
SmartDashboard.putNumber("SystemB/angle",0);
<br>While not critical, it is also helpful to recognize that within their appropriate heirarchy, keys are displayed in alphabetical order! Naming things can thus be helpful to organizing and grouping data. <br><br>As you can imagine, with multiple people each trying to get robot diagnostics, this can get very cluttered. There's a few good ways to make good use of Glass for rapid diagnostics:<br>
<br>Group your keys using group/key . All items with the same group/ value get put into the same subfolder, and easier to track. Often subsystem names make a great group pairing, but if you're tracking something specific, making a new group can help. 
<br>Label keys with units: a  key called angle is best when written as angle degree ; This ensures you and others don't confuse it with angle rad.  
<br>Once you have your grouping and units, add more values! Especially when you have multiple values that should be the same. One of the most frequent ways for a system to go wrong is when two values differ, but shouldn't.
<br>A good case study is an arm: You would have <br>
<br>An absolute encoder angle
<br>the relative encoder angle
<br>The target angle
<br>motor output<br>
And you would likely have a lot of other systems going on. So, for the arm you would want to organize things something like this
<br>SmartDashboard.putNumber("arm/enc Abs(deg)",absEncoder.getAngle());
SmartDashboard.putNumber("arm/enc Rel(deg)",encoder.getAngle());
SmartDashboard.putNumber("arm/target(deg)",targetAngle);
SmartDashboard.putNumber("arm/output(%)",motor.getAppliedOutput());
<br>A good sanity check is  to think "if someone else were to read this, could they figure it out without digging in the code". If the answer is no, add a bit more info.<br><br>Glass is our preferred telemetry interface as programmers: It offers great flexibility, easy tracking of many potential outputs, and is relatively easy to use. <br><img alt="telemetry-glass.png" src="https://stormbots.github.io/KnowledgeBase/assets/telemetry-glass.png"><br>
Glass does not natively "log" data that it handles though; This makes it great for realtime diagnostics, but is not a great logging solution for tracking data mid-match.<br>This is a great intro to how to get started with Glass:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/index.html</a><br>For the most part, you'll be interacting with the NetworkTables block, and adding visual widgets using Plot and the NetworkTables menu item.<br><br>Elastic is a telemetry interface oriented more for drivers, but can be useful for programming and other diagnostics. Elastic excels at providing a flexible UI with good at-a-glance visuals for various numbers and directions.<br><img alt="telemetry-elastic.png" src="https://stormbots.github.io/KnowledgeBase/assets/telemetry-elastic.png"><br>Detailed docs are available here:<br>
<a rel="noopener nofollow" class="external-link" href="https://frc-elastic.gitbook.io/docs" target="_blank">https://frc-elastic.gitbook.io/docs</a><br>As a driver tool, it's good practice to set up your drivers with a screen according to their preferences, and then make sure to keep it uncluttered. You can go to Edit -&gt; Lock Layout to prevent unexpected changes. <br>For programming utility, open a new tab, and add widgets and items.<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a> Basic Telemetry<br><br>Requires:<br>
<a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>
<a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a><br><br>
<br>Configure a Limelight to 
<br>Identify an April Tag
<br>Create a trigger that returns true if a target is in view
<br>When a target is in view, print the offset between forward and the target
<br>Estimate the distance to the target
<br>Configure the LL to identify a game piece of your choice.
<br>Indicate angle between forward and game piece.
Limelight Basics<br><br>Homing is the process of recovering physical system positions, typically using relative encoders.<br><br><a data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br>
<a data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
And will generally be done after most requirements for those systems<br><br>
<br>Home a subsystem using a Command-oriented method
<br>Home a subsystem using a state-based method
<br>Make a non-homed system refuse non-homing command operations
<br>Document the "expected startup configuration" of your robot, and how the homing sequence resolves potential issues.
<br><br>
<br>Configure encoders and other system configurations
<br>Construct a Command that homes the system
<br>Create a Trigger to represent if the system is homed or not
<br>Determine the best way to integrate the homing operation. This can be 

<br>Initial one-off sequence on enable
<br>As a blocking operation when attempting to command the system
<br>As a default command with a Conditional Command
<br>Idle re-homing (eg, correcting for slipped belts when system is not in use)
<br>


<br><br>
<br>Home an elevator system using system current
<br>home an arm system using system current
<br>Home a system 
<br><br>When a system is booted using <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a>, the encoder boots with a value of 0, like you'd expect. However, the real physical system can be anywhere in it's normal range of travel, and the bot has no way to know the difference.<br>Homing is the process of reconciling this difference, this allowing your code to assert a known physical position, regardless of what position it was in when the system booted. <br><br>Homing is not a hard requirement of <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> or <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> systems. As long as you boot your systems in known, consistent states, you operate without issue.<br>However, homing is generally recommended, as it provides benefits and safeguards<br>
<br>You don't need strict power-on procedures. This is helpful at practices when the bot will be power cycled and get new uploaded code regularly. 
<br>Power loss protection: If the bot loses power during a match, you just lose time when re-homing; You don't lose full control of the bot, or worse, cause serious damage.
<br>Improved precision: Homing the system via code ensures that the system is always set to the same starting position. 
<br><br>Hard stops
When looking at homing, the concept of a "Hard Stop" will come up a lot. A hard stop is simply a physical constraint at the end of a system's travel, that you can reliably anticipate the robot hitting without causing system damage.<br>
In some bot designs, hard stops are free. In other designs, hard stops require some specific engineering design.
<br>Safety first!
Any un-homed system has potential to perform in unexpected ways, potentially causing damage to itself or it's surroundings.<br>
We'll gloss over this for now, but make sure to set safe motor current constraints by default, and only enable full power when homing is complete.
<br><br>With this method, the consistency comes from the physical reset of the robot when first powering on the robot. Humans must physically set all non-homing mechanisms, then power the robot. <br>From here, you can do anything  you would normally do, and the robot knows where it is. <br>This method is often "good enough", especially for testing or initial bringup. For some robots, gravity makes it difficult to boot the robot outside of the expected condition.<br>Watch your resets!
With this method, make sure your code does not reset encoder positions when initializing.<br>
If you do, code resets or power loss will cause a de-sync between the booted position and the operational one. You have to trust the motor controller + encoder to retain positional accuracy. 
<br><br>Current detection is a very common, and reliable method within FRC. With this method, you drive the system toward a hard stop, and monitor the system current.<br>When the system hits the hard stop, the load on your system increases, requiring more power. This can be detected by polling for the motor current. When your system exceeds a specific current for a long enough time, you can assert that your system is homed! A <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> is a great tool for helping monitor this condition.<br><br>Speed Detection works by watching the encoder's velocity. You expect that when you hit the hard stop, the velocity should be zero, and go from there. However, there's some surprises that make this more challenging than current detection. <br>Velocity measurements can be very noisy, so using a <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/index.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/index.html" target="_blank">filter</a> is generally required, although debounced <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> can sometimes work.<br>This method also suffers from the simple fact that the system velocity will be zero when homing starts. And zero is also the speed you're looking for as an end condition. You also cannot guarantee that the system speed ever increases above zero, as it can start against the hard stop.<br>
As such, you can't do a simple check, but need to monitor the speed for long enough to assert that the system should have moved if it was able to. <br><br>Limit switches are a tried and true method in many systems. You simply place a physical switch at the end of travel; When the bot hits the end of travel, you know where it is.<br>Mechanical Robustness Required
Limit switches require notable care on the design and wiring to ensure that the system reliably contacts the switch in the manner needed.
<br>The apparent simplicity of a limit switch hides several design and mounting considerations. In an FRC environment, some of these are surprisingly tricky.<br>
<br>A limit switch must not act as an end stop. Simply put, they're not robust enough to sustain impacts and will fail, leaving your system in an uncontrolled, downward driving stage. 
<br>A limit switch must be triggered at the end of travel; Otherwise, it's possible to start below the switch. 
<br>A switch must have a consistent "throw" ; It should trip at the same location every time. Certain triggering mechanisms and arms can cause problems.
<br>If the hard stop moves or is adjusted, the switch will be exposed for damage, and/or result in other issues
<br>Because of these challenges, limit switches in FRC tend to be used in niche applications, where use of hard stops is restricted. One such case is screw-driven <a data-href="Linear Actuators" href="https://stormbots.github.io/KnowledgeBase/Linear Actuators" class="internal-link" target="_self" rel="noopener nofollow">Linear Actuators</a>, which generate enormous amounts of force at very low currents, but are very slow and easy to mount things to.<br>Switches also come in multiple types, which can impact the ease of design. In many cases, a magnetic hall effect sensor is optimal, as it's non-contact, and easy to mount alongside a hard stop to prevent overshoot.<br>Most 3D printers use limit switches, allowing for very good demonstrations of the routines needed to make these work with high precision.<br>For designs where hard stops are not possible, consider a Roller Arm Limit Switch and run it against a CAM. This configuration allows the switch to be mounted out of the line of motion, but with an extended throw. <br><img alt="limit-switch-cam.svg" src="https://stormbots.github.io/KnowledgeBase/assets/limit-switch-cam.svg"><br><br>Index switches work similarly to Limit Switches, but the expectation is that they're in the middle of the travel, rather than at the end of travel. This makes them unsuitable as a solo homing method, but useful as an auxiliary one. <br>Index switches are best used in situations where other homing routines would simply take too long, but you have sufficient knowledge to know that it should hit the switch in most cases.<br>
This can often come up in <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> systems where the robot starting configuration puts the carriage far away from the nearest limit. <br>In this configuration, use of a non-contact switch is generally preferred, although a roller-arm switch and a cam can work well.<br><br>In some cases we can use absolute sensors such as <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a>, <a data-tooltip-position="top" aria-label="Gyro Sensing" data-href="Gyro Sensing" href="https://stormbots.github.io/KnowledgeBase/level-1/gyro-sensing.html" class="internal-link" target="_self" rel="noopener nofollow">Gyros</a>, or <a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">Range Finders</a> to directly detect information about the robot state, and feed that information into our other sensors. <br>This method works very effectively on <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> based systems; <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a> on an output shaft provide a 1:1 system state for almost all mechanical designs. <br>Elevator systems can also use these routines using <a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">|Range Finders</a> , detecting the distance between the carriage and end of travel. <br>Clever designers can also use <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a> for elevators in a few ways <br>
<br>You can simply assert a position within a narrow range of travel
<br>You can gear the encoder to have a lower resolution across the full range of travel. Many encoders have enough precision that this is perfectly fine.
<br>You can use multiple absolute encoders to combine the above global + local states
<br>For a typical system using Spark motors and Through Bore Encoders, it looks like this:<br>public class ExampleSubsystem{
	SparkMax motor = new Sparkmax(/*......*/);
	ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		//Configure the motor's encoders to use the same real-world unit
		armMotor.configure(config,/***/);
		
		//We can now compare the values directly, and initialize the 
		//Relative encoder state from the absolute sensor.
		var angle = motor.getAbsoluteEncoder.getPosition();
		motor.getEncoder.setPosition(angle);
	}
}
<br><br>A relatively simple routine, but just running your system with a known minimum power for a set length of time can ensure the system gets into a known position. After the time, you can reset the encoder. <br>This method is very situational. It should only be used in situations where you have a solid understanding of the system mechanics, and know that the system will not encounter damage when ran for a set length of time. This is usually paired with a lower current constraint during the homing operation.<br><br>In some cases you might be able to find the system home state (using gravity or another method), but find <a data-tooltip-position="top" aria-label="Mechanical Backlash" data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">backlash</a> is preventing you from hitting desired consistency and reliability.<br>This is most likely to be needed on <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> systems, particularly actuated <a data-tooltip-position="top" aria-label="Superstructure Shooter" data-href="Superstructure Shooter" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Shooter</a> systems. This is akin to a "calibration" as much as it is homing.<br>In these cases, homing routines will tend to find the absolute position by driving downward toward a hard stop. In doing so, this applies drive train tension toward the down direction. However, during normal operation, the drive train tension will be upward, against gravity. <br>This gives a small, but potentially significant difference between the "zero" detected by the sensor, and the "zero" you actually want. Notably, this value is not a consistent value, and wear over the life of the robot can impact it.<br>Similarly, in "no-homing" scenarios where you have gravity assertion, the backlash tension is effectively randomized. <br>To resolve this, backlash compensation then needs to run to apply tension "upward" before fully asserting a fully defined system state. This is a scenario where a time-based operation is suitable, as it's a fast operation, from a known state. The power applied should also be small, ideally a large value that won't cause actual motion away from your hard stop (meaning, at/below <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">kS+kG</a> ).<br>For an implementation of this, see <a data-tooltip-position="top" aria-label="https://github.com/stormbots/Crescendo/blob/main/src/main/java/frc/robot/commands/CalibrateShooter.java" rel="noopener nofollow" class="external-link" href="https://github.com/stormbots/Crescendo/blob/main/src/main/java/frc/robot/commands/CalibrateShooter.java" target="_blank">CalibrateShooter</a> from Crescendo.<br><br>Nominally, homing a robot is done once at first run, and from there you know the position. However, sometimes the robot has known mechanical faults that cause routine loss of positioning from the encoder's perspective. However, other sensors may be able to provide insight, and help correct the error.<br>
This kind of error most typically shows up in belt or chain skipping. <br>To overcome these issues, what you can do is run some condition checking alongside your normal runtime code, trying to identify signs that the system is in a potentially incorrect state, and correcting sensor information.<br>This is best demonstrated with examples: <br>
<br>If you home a elevator to the bottom of a drive at position 0, you should never see encoder values be negative. As such, seeing a "negative" encoder value tells you that the mechanism has hit end of travel.
<br>If you have a switch at the limit of travel, you can just re-assert zero every time you hit it. If there's a belt slip, you still end up at zero.
<br>If an arm should rest in an "up" position, but the slip trends to push it down, retraction failures might have no good detection modes. So, simply apply a re-homing technique whenever the arm is in idle state.
<br>Band-Aid Fix
Online Position Recovery is a useful technique in a pinch. But, as with all other hardware faults, it's best to fix it in hardware. Use only when needed.
<br>If the system is running nominally, these techniques don't provide much value, and can cause other runtime surprises and complexity, so it's discouraged.<br>
In cases where such loss of control is hypothetical or infrequent, simply giving drivers a homing/button tends to be a better approach. <br><br>When doing homing, you typically have 4 system states, each with their own behavior. Referring it to it as a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machine</a> is generally simpler <br><br><br>The UnHomed state should be the default bootup state. This state should prepare your system to <br>
<br>A boolean flag or state variable your system can utilize
<br>Safe operational current limits; Typically this means a low output current or speed control.
<br>It's often a good plan to have some way to manually trigger a system to go into the Unhomed state and begin homing again. This allows your robot drivers to recover from unexpected conditions when they come up. There's a number of ways your robot can lose position during operation, most of which have nothing to do with software.<br><br>The Homing state should simply run the desired homing strategy. <br>Modeling this sequence tends to be the tricky part, and a careless approach will typically reveal a few issues<br>
<br>Modelling the system with driving logic in the subsystem and Periodic routine typically clashes with the general flow of the Command structure. 
<br>Modelling the Homing as a command can result in drivers cancelling the command, leaving the system in an unknown state
<br>And, trying to continuously re-apply homing and cancellation processes can make the drivers frustrated as the system never gets to the known state.
<br>Trying to make many other commands check homing conditions can result in bugs by omission.
<br>The obvious takeaway is that however you home, you want it to be fast and preferably completed before the drivers try to command the system. Working with your designers can streamline this process.<br>Use of the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> decorator withInterruptBehavior(...) allows an easy escape hatch. This flag allows an inversion of how Command are scheduled; Instead of new commands cancelling running ones, this allows your homing command to forcibly block others from getting scheduled.<br>If your system is already operating on an internal state machine, homing can simply be a state within that state machine.<br><br>This state is easy: Your system can now assert the known position, set your Homed state, apply updated power/speed constraints, resume normal operation.<br><br><br>Conveniently, the whole homing process actually fits very neatly into the <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> model, making for a very simple implementation<br>
<br>init() represents the unhomed state and reset
<br>execute() represents the homing state
<br>isFinished() checks the system state and indicates completion
<br>end(cancelled) can handle the homed procedure
<br>class ExampleSubsystem extends SubsystemBase(){
	SparkMax motor = ....;
	private boolean homed=false;
	ExampleSubsystem(){
		motor.setMaxOutputCurrent(4); // Will vary by system
	}

	public Command goHome(){
		return new FunctionalCommand(
			()-&gt;{
				homed=false;
				motor.getAppliedCurrent()
			};
			()-&gt;{motor.set(-0.5);};
			()-&gt;{return motor.getAppliedCurrent()&gt;3}; //isFinished
			(cancelled)-&gt;{
				if(cancelled==false){
					homed = true;
					motor.setMaxOutputCurrent(30);
				}
			};
		)
		//Optionally: prevent other commands from stopping this one
		//This is a *very* powerful option, and one that
		//Should only be used when you know it's what you want.
		.withInterruptBehavior(kCancelIncoming)
		// Failsafe in case something goes wrong,since otherwise you 
		// can't exit this command by button mashing
		.withTimeout(5);
		}
} 
<br>This command can then be inserted at the start of autonomous, ensuring that your bot is always homed during a match. It also can be easily mapped to a button, allowing for mid-match recovery. If needed, it can also be broken up into a slightly more complicated command sequence.<br>For situations where you won't be running an auto (typical testing and practice field scenarios), the use of <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> can facilitate automatic checking and scheduling<br>class ExampleSubsystem extends SubsystemBase(){
	ExampleSubsystem(){
		Trigger.new(Driverstation::isEnabled)
		.and(()-&gt;isHomed==false)
		.whileTrue(goHome())
	}
}
<br>Alternatively, if you don't want to use the withInterruptBehavior(...) option, you can hijack other command calls with Commands.either(...) or new ConditionalCommand(...)<br>class ExampleSubsystem extends SubsystemBase(){
/* ... */
	//Intercept commands directly to prevent unhomed operation
	public Command goUp(){
		return either(
		stop(),
		goHome(),
		()-&gt;isHomed
	}
/* ... */
<br>While generally not preferable, a DefaultCommand and the either/ConditionalCommand notation can be used to  initiate homing. This is typically not recommended due to defaultCommands having an implicit low priority, while homing is a very high priority task.Homing Sequences<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> <br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>
<br>Create a Widget on a dashboard to show the field
<br>Populate the Field with your robot, and one or more targets
<br>Utilize the Field to help develop a "useful feature" displayed on the Field
<br>As a telemetry task, success is thus open ended, and should just be part of your development process; The actual feature can be anything, but a few examples we've seen before are<br>
<br>showing which of several targets your code has deemed best, and react to it
<br>a path your robot is following, and where the bot is while following it
<br>The current Vision targets and where your bot is when seeing them
<br>A field position used as an adjustable target 
<br>The projected path for a selected auto
<br>Inidcate proximity or zones "zones" for performing a task, such as the acceptable range for a shooting task or intaking process.
<br><br>Odometry is also known as Position Tracking. In FRC, this is generally regarded as knowing the position of your robot in the game field. It is most beneficial when combined with the robot to then have the robot move between positions on the field, and interact with other known positions. <br>Actually obtaining odometry depends on the design of the bot: <a data-tooltip-position="top" aria-label="Level 1/Differential Drive Odometry" data-href="Level 1/Differential Drive Odometry" href="https://stormbots.github.io/KnowledgeBase/Level 1/Differential Drive Odometry" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive Odometry</a> or <a data-href="Swerve Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Odometry</a> , and often involves vision systems via <a data-tooltip-position="top" aria-label="Limelight Odometry" data-href="Limelight Odometry" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">LimeLight Odometry</a> or <a data-href="PhotonVision Odometry" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-odometry.html" class="internal-link" target="_self" rel="noopener nofollow">PhotonVision Odometry</a><br>This document is concerned with the prerequisite: Being able to actually view, compare, and validate positions using robot telemetry.<br><br><img alt="telemetry-elastic.png" src="https://stormbots.github.io/KnowledgeBase/assets/telemetry-elastic.png"><br>Telemetry for Odometry revolves around the Field2D object. Both Glass and Elastic can display the Field2D object as a game field on the dashboard, including associated robot positions and any secondary objects.<br>In general, Glass is the superior option for most programming tasks and development, allowing easier customization to help reduce clutter and provide clarity between objects. <br>The WPILib Docs are excellent at helping demonstrate many of these examples:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/field2d-widget.html</a><br><br>In Robots, a Pose represents a specific location and state of a robot's actuator. Within the context of odometry, a pose represents the robot's location on a 2D plane. In most cases, this means the location on the game field. <br>In order to represent such a state, we need 3 things: The X position, the Y position, and a rotation. <br>In WPILib, this is handled by the <a data-href="Pose2d" href="https://stormbots.github.io/KnowledgeBase/misc/pose2d.html" class="internal-link" target="_self" rel="noopener nofollow">Pose2d</a> object, which can be provided to and returned from many utilities interacting with the robot position, including drivetrain path planning, vision, simulation, and telemetry.<br><br>The Field2D object in WPILib contains a number of utilities for keeping tabs on odometry. It can be added with just a couple lines. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		//We only want to send the actual Field object _once_,
		//so we often do it in the constructor. Changes will be 
		//sent automatically as the Field2d object itself is updated.
				
		//Preferred: Set the NetworkTables name explicitly, 
		//and give it a unique, descriptive name
		SmartDashboard.putData("ChassisField",field);
		
		// This form uses the default name "Field" as the key.
		// Not recommended in most cases
		//SmartDashboard.putData(field);
	}

}
<br>This creates a blank, empty field, with your robot position, probably at (0,0)  in the bottom left corner, on the blue side of the field. <br>Meaningfully updating the robot pose is out of scope, and differs by drivetrain type; However, the basic gist is <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	//Set up an odometry object to track our robot
	DifferentialDrivePoseEstimator odometry=new DifferentialDrivePoseEstimator(
	 /* Complex constructor parameters; not relevant*/
	)
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Read the odometry object and set the pose. //Reference only
		field.setRobotPose(odometry.getPoseMeters());
		
		// Or, we can just set it manually for testing.
		field.setRobotPose(new Pose2d(2.7,3.1, new Rotation2d(Math.PI/2.0) ));	
	}
}
<br>Now, when we open our Field2D widget in Glass, we'll see that our robot is at a new position. If we fully implemented our Pose Estimator object, we'd see that this provides realtime tracking of our position.<br>A .getRobotPose() also exists, but tends to be less useful in practice, as most classes that will interact with the Robot and Field will likely have access to the Odometry object directly. <br>Note, that the Field2d object we create is a unique reference, with it's own unique local data; only the NetworkTables key might have overlap when using default keys. This means if we want to properly share a Field across multiple classes, we either need to fetch the NetworkTables data and copy it over, create a single Field object in RobotContainer and pass it to, or create a DriverField object as a <a data-tooltip-position="top" aria-label="Singletons" data-href="Singletons" href="https://stormbots.github.io/KnowledgeBase/level-2/singletons.html" class="internal-link" target="_self" rel="noopener nofollow">Singleton</a> that can facilitate a single object.<br><br>Where Field2d objects really shine is in adding supplemental information about other field objects. The utility varies by game, but it's great for showing a variety of things such as <br>
<br>Targets/objectives
<br>Nearest/best target
<br>Nearest game piece (detected by vision systems)
<br>These can be done using the getObject(name) method; This grabs the named object from the field, creating it if it doesn't already exist.<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
	}
	
	public void periodic(){
		//Can provide any number of pose arguments
		field.getObject("GamePieces").setPoses(
			new Pose2d(1,1),
			new Pose2d(1,2),
			new Pose2d(1,3),
		);
		//You can also pass a single List&lt;Pose2d&gt; 
		//if you have a list of poses already
		
		field.getObject("BestGamePiece").setPose(
			new Pose2d(1,2)	
		);
	}

}
<br>Note It's worth considering that for objects that never move, you could set  objects once in the constructor, and they work fine. However, if the user accidentally moves them in the UI, it creates a visual mis-match between what the code is doing and what the user sees. As a result, it's often better to just throw it in a Periodic.<br><br>A niche, but very useful application of field objects is to get precise driver feedback on field location data.  This can be done using the following code setup:<br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command aimAtCustomTarget(){
		return run(()-&gt;{
			var target=field.getObject("DriverTarget").getPose();
			//Do math to figure out the angle to target
			//Set your drivetrain to face the target
		};
	}
	
	public void periodic(){
		//No setting DriverTarget pose here!
	};
}
<br>In this case, we take advantage of the "set once" approach in constructors; The drivers or programmers can modify the position, and then we now read it back into the code. <br>This can be very useful for testing to create "moving targets" to test dynamic behavior without having to drive the bot. It can also help you create "simulation" poses for testing math relating to Pose2D objects.<br> is especially true for simulation, as this allows you quickly test pose-related functions and makes sure that things happen how you expect.<br>One practical application is match-specific targets for cooperating with allies. An example is in 2024 Crescendo: a common game tactic was to "pass" rings across the field, by shooting to an open area near where your allies would be. However, since the game pieces can get stuck in/on robots, and different robots have different intakes, and each ally has different sight lines, making the ideal pass target unknown until the actual match is about to start. An adjustable target let the alliance sort it out before a match without having to change the code.<br><br>When doing path-planning for drivetrains, it's often helpful to display the full intended path, rather than a lot of individual poses. <br>class Drivetrain extends SubsystemBase{
	Field2D field = new Field();
	
	public Drivetrain(){//constructor
		SmartDashboard.putData("ChassisField",field);
		//Set the pose  exactly once at boot
		field.getObject("DriverTarget").setPose(
			new Pose2d(1,2)	
		);
	}
	
	public Command buildAuto1(){
		var  trajectory=// Get the trajectory object from your path tool
		field.getObject("autoTrajectory").setTrajectory(trajectory);
		return run(()-&gt;{
			//draw the rest of the owl
		};
	}
	

}
<br>In this use case, the work will likely be done inside your Auto class after selecting the appropriate one. Basic Odometry+Telemetry<br><br><br>
<br>
Configure a NavX or gyro on the robot

<br>
Find a way to zero the sensor when the robot is enabled in auto

<br>
Create a command that tells you when the robot is pointed the same way as when it started

<br>
Print the difference between the robot's starting angle and current angle

<br>
TODO

<br>
what's an mxp

<br>
what port/interface to use, usb

<br>
which axis are you reading

<br>
Gyro Sensing<br>Absolute encoders are sensors that measure a physical rotation directly. These differ from <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a> due to measurement range, as well as the specific data they provide.<br><br>
<br>Take testbench, define a range of motion with measurable real-world angular units.
<br>Configure an absolute encoder to report units of that range
<br>Validate that the reported range of the encoder is accurate over the fully defined range of motion.
<br>Validate the 
<br><br>If we recall how <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a> work, they tell us nothing about the system until verified against a reference. Once we have a reference and initialize the sensor, then we can track the system, and compute the system state.  <br>In contrast, absolute encoders are designed to capture the full system state all at once, at all times. When set up properly, the sensor itself is a reference.<br><br>Both sensors track the same state change (rotation), and when leveraged properly, can provide complete system state information<br><br>While the precise construction can vary, many absolute encoders tend to work in the same basic style: divide your measured distance into two regions. Then divide those two regions into two more regions each, and repeat as many times as needed to get the desired precision!<br>When you do this across a single rotation, you get a simple binary encoder shown here: <br><img alt="encoder-gray-code.png" src="https://stormbots.github.io/KnowledgeBase/assets/encoder-gray-code.png"><br>With 3 subdivisions, you can divide the circle in  regions. This means at all times, you know where you are within a 45 degree region. Since each region is on/off, it's common to describe absolute encoders as "X bit" resolution; One bit per sensor region.<br>Commonly, you'll see encoders with one of the following resolutions. <br><br><br>The typical encoder we use in FRC is the <a data-tooltip-position="top" aria-label="https://docs.revrobotics.com/rev-crossover-products/sensors/tbe/application-examples" rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/rev-crossover-products/sensors/tbe/application-examples" target="_blank">Rev Through Bore Encoder</a> . This is a 10 bit encoder, and provides interfaces by either <br>
<br>Plugging it into the Spark Max
<br>Plugging it into the RoboRio's DIO port. 
<br><br>When plugged into the RoboRio, you can interface with it using the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" target="_blank">DutyCycleEncoder</a> class and associated features.<br>public class ExampleSubsystem{
	// Initializes a duty cycle encoder on DIO pins 0 
	// Configure it to to return a value of 4 for a full rotation, 
	// with the encoder reporting 0 half way through rotation (2 out of 4)
	DutyCycleEncoder encoder = new DutyCycleEncoder(0, 4.0, 2.0);
	
	//... other subsystem code will be here ...
	
	public void periodic(){
		//Read the encoder and print out the value
		System.out.println(encoder.get());
	}
}
<br>Real systems will likely use encoder ranges of  2*Math.PI (for Radians) or 360 (for degrees). <br>The "zero" value will depend on your exact system, but should be the encoder reading when your system is at a physical "zero" value. In most cases, you'd want to correlate "physical zero" with an arm horizontal, which simplifies visualizing the system, and calculations for <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> for <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm subsystems</a> later. However, use whatever makes sense for your subsystem, as defined by your <a data-href="Robot Design Analysis" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-design-analysis.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Design Analysis</a>'s coordinate system.<br><br>When a Through Bore Encoder is connected to a Spark, it'll look very similar to connecting a <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoder</a> in terms of setting up the Spark and applying/getting config, with a few new options<br>ExampleSubsystem extends SubsystemBase{
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();

		//Configure the reported units for one full rotation.
		// The default factor is 1, measuring fractions of a rotation.
		// Generally, this will be 360 for degrees, or 2*Math.PI for radians
		var absConversionFactor=360;
		config.absoluteEncoder
		.positionConversionFactor(absConversionFactor);
		//The velocity defaults to units/minute ; Units per second tends to
		//preferable for FRC time scales.
		config.absoluteEncoder
		.velocityConversionFactor(absConversionFactor / 60.0);
		//Configure the "sensor phase"; If a positive motor output 
		//causes a decrease in sensor output, then we want to set the 
		// sensor as "inverted", and would change this to true.
		config.absoluteEncoder
		.inverted(false);

		motor.configure(
			config,
			ResetMode.kResetSafeParameters,
			PersistMode.kPersistParameters
		);
	}
	// ... other stuff
	public void periodic(){
		//And, query the encoder for position.
		var angle = motor.getAbsoluteEncoder().getPosition();
		var velocity = motor.getAbsoluteEncoder.getVelocity();
		// ... now use the values for something.
	}
}
<br><br>Remember that the intent of an absolute encoder is to capture your system state directly. But what happens when your system can exceed the encoder's ability to track it? <br>If you answered "depends on the way you track things", you're correct. By their nature absolute encoders have a "discontinuity"; Some angle at which they jump from one end of their valid range to another. Instead of [3,2,1,-1,-2] you get [3,2,1,359,358]! You can easily imagine how this messes with anything relying on those numbers.. <br>For a Through Bore + Spark configuration, by default it measures "one rotation", and the discontinuity matches the range of 0..1 rotations , or 0..360 degrees with a typical conversion factor. This convention means that it will not return negative values when read through motor.getAbsoluteEncoder().getPosition() ! <br><img alt="absolute-angle-discontinuity.svg" src="https://stormbots.github.io/KnowledgeBase/assets/absolute-angle-discontinuity.svg"><br>Unfortunately, this convention often puts the discontinuity directly in range of motion, meaning we have to deal with it frequently. <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> controllers especially do not like discontinuities in their normal range. <br>Ideally, we can move the discontinuity somewhere we don't cross it due to physical hardware constraints.<br>There's a few approaches you can use to resolve this, depending on exactly how your system should work, and what it's built to do!<br><br>This is the easiest and probably ideal solution for many systems. The Spark has a method that changes the system from reporting [0..1)rotations to (-0.5..0.5]. rotations. Or, with a typical conversion factor applied, (-180..180] degrees. <br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		config.absoluteEncoder.zeroCentered(true);
		// .. other stuff
		}
	}
<br>Most FRC systems won't have a range of 180 degrees, making this a very quick and easy fix. <br>PID Integration
Rev documentation makes it unclear if zeroCentered(true) works as expected with the onboard Spark PID controller.<br>
If you test this, report back so we can replace this warning with correct information. 
<br><br>Since this is common, some <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> or <a data-tooltip-position="top" aria-label="Closed Loop Controller" data-href="Closed Loop Controller" href="https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop</a> controllers can simply take the discontinuity directly in their configuration. This bypasses the need to fix it on the sensor side.<br>For Sparks, the configuration option is as follows:<br>sparkConfig.closedLoop.positionWrappingInputRange(min,max);
<br>Setpoint Wrapping in controllers 
Be mindful of how setpoints are wrapped when passed to the controller! Just because the sensor is wrapped, doesn't mean it also handles setpoint values too.<br>
If the PID is given an unreachable setpoint due to sensor wrapping, it can generate uncontrolled motion. Make sure you check and use wrapper functions for setpoints as needed.
<br><br>In some cases, you can just avoid directly calling motor.getAbsoluteEncoder().getPosition(),  and instead go through a function to handle the discontinuity. This usually looks like this<br>// In a subsystem using an absolute encoder
private double getAngleAbsolute(){
	double absoluteAngle = motor.getAbsoluteEncoder().getPosition();
	// Mote the discontinuity from 0 to -90
	if(absoluteAngle&gt;270){
		absoluteAngle-=360;
	}
	return absoluteAngle;
}
<br>This example gives us a range of -90 to 270, representing a system that could rotate anywhere but straight downward. <br>This pattern works well for code aspects that live on the Roborio, but note this doesn't handle things like the onboard Spark PID controllers! Those still live with the discontinuity, and would cause problems.<br><br>Instead of using the Absolute encoder as it's own source of angles, we simply refer to the <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoder</a>. In this case, both encoders should be configured to provide the same measured unit (radians/degrees/rotations of the system), and then you can simply read the value of the absolute, and set the state of the relative. <br>More information for this technique is provided at <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a>, alongside other considerations for transferring data between sensors like this.<br><br>Since an absolute encoder represents a physical system state, an important consideration is preserving the physical link between system state and the sensor.<br>On the Rev Through Bore, the link between system state and encoder state is maintained by the physical housing, and the white plastic ring that connects to a hex shaft.<br><img alt="Rev Through Bore Encoder.png" src="https://stormbots.github.io/KnowledgeBase/assets/rev-through-bore-encoder.png"><br>You can see that the white hex ring has a small notch to help track physical alignment, as does the black housing. The notch's placement itself is unimportant; However, keeping the notch consistency aligned is very important!<br>If we take a calibrated, working system, but then re-assemble it it incorrectly, we completely skew our system's concept of what the physical system looks like. Let's take a look at an example arm.<br><img alt="absolute-sensor-rotation-error.svg" src="https://stormbots.github.io/KnowledgeBase/assets/absolute-sensor-rotation-error.svg"><br>We can see in this case we have a one-notch error, which is 60 degrees. This means that the system thinks the arm is pointing up, but the arm is actually still rather low. This is generally referred to as a "clocking" error.<br>When we feed an error like this into motor control tools like a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>, the discrepancy means the system will be driving the arm well outside your expected ranges! This can result in significant damage if it catches you by surprise. <br>As a result, it's worth taking the time and effort to annotate the expected alignment for the white ring and the other parts of the system. This allows you to quickly validate the system in case of rework or disassembly. <br>Ideally, build teams should be aware of the notch alignment and it's impact! While you can easily adjust offsets in code, such offsets have to ripple through all active code branches and multiple users, which can generate a to a fair amount of disruption. However, in some cases the code disruption is still easier to resolve than further disassembling and re-assembling parts of the robot. It's something that's bound to happen at some point in the season.<br><br><br><br>Grey code encoders use binary subdivision similar to the "binary encoder" indicated above, but structure their divisions and output table differently. These differences make for some useful properties:<br>
<br>Only one bit changes at a time during rotation
<br>Subdivisions are grouped in a way that reduces the rate of change on any given track
<br>If you look closely, the Quadrature signal used by <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a> is a special case of a 2 bit Grey Code! Looking for this "quadrature" pattern where each track has a 50% overlap to the change across adjacent tracks is a giveaway that an encoder is using gray code.<br><img alt="Gray-code-table-Gray-coding-to-read-position.gif" src="https://stormbots.github.io/KnowledgeBase/assets/gray-code-table-gray-coding-to-read-position.gif"><br><br>In certain systems, you can measure an X and a Y offset, generating a sin and cosine value. The unique sin and cos values generate a unique angle with high precision.<br><img alt="Circle_cos_sin.gif" src="https://stormbots.github.io/KnowledgeBase/assets/circle_cos_sin.gif"><br><br>In some cases like an Elevator you might want to track motion across a larger range than a single encoder could manage. This is most common for linear systems like <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a>. <br>By stepping an encoder down, can convert 1 rotation of travel (maybe ~1-3 inches at ~0.01" precision) into a more useful ~50 inches at ~0.5" precision! This gives you absolute knowledge of your system, but at a much lower precision.<br>However, if you were to stack a normal encoder on top, you could use each encoder within their optimal ranges: One encoder can provide a rough area, and the other can provide the precision.<br><br>This is a numerical trick that can allow use of two smaller encoders and some clever math to extend two encoders ranges out a significant distance at high precision. This would permit absolute encoders to effectively handle <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> systems or other linear travel.<br><a rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem" target="_blank">https://en.wikipedia.org/wiki/Chinese_remainder_theorem</a><br><br>
<br>Advantages
<br>Disadvantages
<br>Discontinuity handling
<br>Integration with relative encoders<br>
<a data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a>
Absolute Encoders<br><br>requires<br>
<a data-href="Auto Differential" href="https://stormbots.github.io/KnowledgeBase/level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Limelight Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight Basics</a><br><br>
<br>Create a button that aims your chassis at a target
<br>Ensure the above button allows drivers to move toward and away from target while it's held
<br>Create a pipeline that allows you to drive to the left/right of the target instead of directly at it
<br>Create a button that aligns you with a game piece, and allows drivers to drive at it
Limelight Assist Driving<br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> Limelight Odometry<br><br><br>Triggers are a simple boolean condition that robot code can use to interact with commands, including starting and stopping them.<br><br>
<br>Start a command when the robot is enabled, and ends automatically
<br>Create a Trigger with multiple required conditions before running a command
<br>Read a sensor input in a Trigger, and run a command when the sensor enters a true state.
<br><br>
<br>Support command+trigger subsystem interfaces
<br>Model system state into binary regions
<br>loose coupling of subsystems
<br>Tolerances on sensors
<br>Joystick buttons = trigger ; Hidden common use case
<br>Starting commands with triggers
<br>ending commands with triggers
<br>sequencing component
<br><br>The first, easiest introduction to Triggers is the CommandXboxController class, used to interact with the driver's joystick! <br>Each button is a trigger, and a great learning reference. Each new project has some triggers for you, set up and ready to go!<br>public class RobotContainer{
	private final CommandXboxController m_driverController =
	new CommandXboxController(OperatorConstants.kDriverControllerPort);
	//That constant equals 0  btw
	
	private void configureBindings() {
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.exampleMethodCommand());
}
<br>In this case, m_driverController.b() generates a new Trigger interacting with the B button on the controller.<br>
Here, we see that the Trigger uses .whileTrue(command) . This Trigger option 1) Starts the command when the button is pressed, and 2) Cancels the command when it's released. <br>whileTrue tends to be a very good option for Drivers and controller inputs : it enables good muscle memory, and predictable human-&gt;robot interactions. Similarly, with no buttons being pressed, no commands are running: This means your robot is predictably running only defaultCommands and becomes easy to reason about as a programmer.<br><br>Triggers are a great way to wrap sensor and subsystem "state", and expose it to be integrated with Commands. <br>While it's less common to launch commands based on these types of Triggers, Triggers provide several functions that prove useful, and help clean up your subsystem and command code. <br>Common triggers include<br>
<br>Confirming you're at an arbitrary commanded position, usually written isOnTarget / isAtGoal / isAtSetpoint(), or something similar. 
<br>Confirming that you're at a relevant named position, such as atScoringPosition, atLevel2, atLevel3, atPickupAngle
<br>Confirming the state of a game piece: Usually isGamepieceLoaded, replacing Gamepiece with the name of the current year's item.
<br>isWithinRange() ; Common for rangefinders like <a data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">LaserCan</a>
<br>Usually, these are further customized to provide very clear, yes/no queries with true/false responses.<br><br>For a full reference of available options, see here:<br>
<a rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/button/Trigger.html" target="_blank">https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/button/Trigger.html</a><br>The most helpful ones will tend to be  <br>whileTrue: Extremely useful for driver interactions<br>
onTrue : Very good for automated sensor interactions, such as automatically starting intake processes.<br>and and or : Allow joining two existing Triggers. This can clean up some code, most notably writing command.until(...) conditions. <br>and is also helpful for attaching multiple conditions to existing triggers, to further filter conditions.<br>getAsBoolean can be useful, as it simply returns the true/false value of the checked condition. This allows Triggers to be used as simple Boolean functions, or as boolean variables.<br>debounce(time) prevents the trigger from changing output until the condition is in the new state for time seconds. A small debounce can improve reliability and prevent misfires by handling sensor quirks or environmental errors that can trigger the condition without really being in the intended state.<br>
<br>This is especially useful for measuring time-sensitive readings like velocity and current, as they provide extremely noisy signals otherwise.
<br>Helpful for Position-based measures, ensuring that the system is "stable" and not bouncing around the target position
<br>Helpful when anding multiple sensor reading, to ensure that the system has settled on the desired state properly.
<br><br>Triggers are a bit strange; When they're created, they're included in the robot's Command Scheduler, and it's not needed to make sure they stay in scope to continue working. <br>However, you do need to keep them in an accessible scope if you want other parts of the system to continue working. This leads to a few variants on where they go in your codebase.<br>The important detail is that a Trigger should only be created once, and not created in execute blocks or using Factory methods.<br><br>This style is useful for "interface" functions; Ones that will be used inside or outside of your subsystem to tell you something about it.<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
	}
	public Trigger isEncoderAround20 = new Trigger(
		()-&gt;encoder.get()&gt;15 &amp;&amp; encoder.get &lt; 25
	)
}
<br><br>If a command is just running automated actions, but won't be referenced, you can simply put it in a constructor.  This will schedule the command, and work invisibly in the background.<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
		new Trigger(DriverStation::isEnabled)
		.and(()-&gt;isHomed==false)
		.onTrue(goHome())
	}
<br>(see also <a data-href="#Automatically launching commands at startup" href="https://stormbots.github.io/KnowledgeBase/about:blank#Automatically_launching_commands_at_startup" class="internal-link" target="_self" rel="noopener nofollow">Automatically launching commands at startup</a> for more info about this use case)<br><br>Less common, but some Trigger checks interfacing with multiple subsystems may need to be created in RobotContainer.  Generally, we want to minimize these for single-subsystem interactions. <br>Usually, the constructor is fine, but for complex robots, you might want to create a configureTriggers() utility function, just as the constructor has a configureBindings for joystick buttons.<br>public class RobotContainer{
	public RobotContainer(){ //constructor
		new Trigger(DriverStation::isEnabled)
		.and(()-&gt;elevator.isHomed==false)
		.onTrue(elevator.goHome())
	}
<br>This one even has an example in the code!<br>public class RobotContainer{
	private void configureBindings() {
		// Schedule `ExampleCommand` when `exampleCondition` changes to `true`
		new Trigger(m_exampleSubsystem::exampleCondition)
		.onTrue(new ExampleCommand(m_exampleSubsystem));
	}
}
<br><br>This is an unusual edge case; Sometimes, your Trigger will rely on something in your class that is not yet initialized. Because of this, you can't put it as a class member, since that would need to evaluate immediately. But you can't put it in the constructor, because that'd hide the scope, and you can't access it!<br>The solution is do both; We reserve the location in memory, allowing Java to process the class, and then come back and evaluate our Trigger when we construct the class. <br>public class ExampleSubsystem{
	public Trigger isEncoderAround20; //uninitialized!
	
	public ExampleSubsystem(){
		// We now initialize it 
		isEncoderAround20 = new Trigger(
			()-&gt;encoder.get()&gt;15 &amp;&amp; encoder.get &lt; 25
		);
	}
	
}
<br>In general we try to avoid this pattern; It often leads to forgotten initialization steps, and produces more noise and redundancy. However, it does resolve this particular problem.<br><br><br>On initially reviewing this example code, you might expect it to work as written when the robot starts up<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
		new Trigger(()-&gt;isHomed)==false).onTrue(goHome());
	}
	public Command goHome(){
		return run(()-&gt;/*Do a homing process*/);
	}
}
<br>However, it fails for a very surprising reason, relating to the robot's boot process,and the fact that commands don't run when in Disabled Mode. The timeline of events is as indicated:<br>
<br>The robot boots
<br>The ExampleSubsystem is created, and the trigger is registered with the <a data-href="Scheduler" href="https://stormbots.github.io/KnowledgeBase/Scheduler" class="internal-link" target="_self" rel="noopener nofollow">Scheduler</a>
<br>Eventually, initialization is complete
<br>The robot enters Disabled mode
<br>isHomed is  checked and false. 
<br>goHome is started, and immediately stopped.
<br>Eventually, the driver enables the robot
<br>The robot enters Enabled mode.
<br>isHomed is still false, rather than becoming false so nothing happens. 
<br>What the heck!<br>The issue is that the command state is not considered for onTrue; Only the condition is. In some cases "homing" might deserve .onTrue; But other triggers (like automatic gamepiece alignment or adjustment) might interfere with other robot processes!<br>The trick is to explicitly check for the robot to be enabled first, and then your other condition afterward.<br>public class ExampleSubsystem{
	public ExampleSubsystem(){
		new Trigger(DriverStation::isEnabled)
		.and(()-&gt;isHomed==false)
		.onTrue(goHome());
	}
	public Command goHome(){
		return run(()-&gt;/*Do a homing process*/);
	}
}
<br>In this case, DriverStation::isEnabled will always fail until the robot is in a state where it could run a command. Only then will it check  the isHomed status, see the condition is true, and attempt to schedule the command. Success!<br><br>Scheduling some actions based on sensors might wind up interfering with other ongoing robot tasks. Remember, they're exactly like a driver hitting a button!<br>For example, if you automatically "grab" a loaded game piece, like this: <br>public class IntakeSubsystem extends SubsystemBase{
	public IntakeSubsystem(){
		new Trigger(isGamePieceLoaded).onTrue(holdGamePiece());
	}
	public Command holdGamePiece(){
		return run(()-&gt;motor.set(0.1));
	}
	
}
<br>and then try to run a sequence like this:<br>public class RobotContainer(){
	public Command fancyGrabGamepiece(){
		return new SequentialCommand(){
			elevator.goToBottom(),
			intake.intake(), //&lt;-- This causes your trigger to run! 
			//Command will get cancelled here
			elevator.goToScoringPosition() //won't run
		}
	}
}
<br>You will be annoyed by the unexpected behavior. Worse, if there's a sensor glitch, you might cancel scoring operations too! Instead of getting points, you just suck the game piece back in. <br>In cases where such conflicts might come up, you can detect if a Command requires the subystem, by adding some conditions to the trigger, preventing unexpected launches during other actions. <br>	//Check to see if *any* command is scheduled.
	new Trigger(isGamePieceLoaded)
	.and(this.getCurrentCommand()==null) //Null returned if no command running
	.onTrue(holdGamePiece());

	//Check to see if the current command is "default"
	// We probably don't mind interrupting the default.
	new Trigger(isGamePieceLoaded)
	.and(this.getCurrentCommand()==this.getDefaultCommand())
	.onTrue(holdGamePiece());
	//Note, if you have no defaultCommand getDefaultCommand() will 
	//return null!
<br>These methods allow your trigger to intentionally set its own priority below other commands that might be interacting with the system. <br>However, in some cases you might simply be better off using an intelligent DefaultCommand for such automated actions, but this is a useful tool to be aware of!<br>Test this behavior
While these specific Trigger techniques been used successfully in the past, these examples are not written from older, validated code and may contain errors.<br>
Trigger/command behavior might also be changing in 2025, rendering these obsolete or working differently.
Triggers<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:hardware" class="tag" target="_blank" rel="noopener nofollow">#hardware</a> <a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> <br><br>
<br>Connect to the LaserCan using GrappleHook
<br>Create a new Lasercan sensor subsystem
<br>Create a Trigger that returns true while an object is within X" of the sensor
LaserCan<br><br>Requires<br>
<a data-href="Auto Differential" href="https://stormbots.github.io/KnowledgeBase/level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Gyro Sensing" href="https://stormbots.github.io/KnowledgeBase/level-1/gyro-sensing.html" class="internal-link" target="_self" rel="noopener nofollow">Gyro Sensing</a><br><br>
<br>Create a button that causes the robot to face a bearing of 0 degrees
<br>Create 3 additional buttons to face 90, 180, and 270. 
<br>Ensure that the drivers can hold those buttons and use the throttle to drive in the indicated direction
<br>Create an 4 step auto that traverses a predefined path using gyro headings and encoder distances
Gyro Driving<br><br>Requires:<br>
<a data-href="Robot Code Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Configure a Spark motor encoder
<br>Read an encoder position
<br>Configure encoder range/units through gearing
<br>Enable/Disable Soft Limits
<br><br>An Encoder is a sensor that provides information about a mechanism's rotation. <br>Since motors generally apply power through rotation, clever use of encoders allows you to infer a significant amount of system information. <br>Encoders wind up being one of our primary sensors on FRC bots, due to their prevalence and flexibility.<br><br><br>The simplest version of an encoder is simple sensor that switches between one and zero during a rotation.<br><img alt="Incremental_encoder.gif" src="https://stormbots.github.io/KnowledgeBase/assets/incremental_encoder.gif"><br>This simplified encoder is often called a "gear tooth" sensor, since it's commonly associated with sensors that directly measure the one or more teeth on a gear directly. This generates a single pulse train like this:<br>
<img alt="Digital_Gear_Tooth_Sensor.gif" src="https://stormbots.github.io/KnowledgeBase/assets/digital_gear_tooth_sensor.gif"><br>This pulse train switching between 0 and 1 provides some information about the rotation of the shaft: By counting the time between changes you can calculate the speed of the system. By counting the number of cycles, you can also tell how many teeth have passed.<br>However, this sensor is limited: The pulse train looks exactly the same whether you're going forward or backward! So you can't know what direction you're going, just how fast or how far. <br>As a result, this sensor type is mostly used for measuring velocity where the direction is known by some other mean: Often the output of a motor itself. <br><br>An effective way to add the direction back in is to just track a different position. By carefully selecting a location that triggers slightly off from the first one, you get some interesting effects.<br><img alt="Incremental_directional_encoder.gif" src="https://stormbots.github.io/KnowledgeBase/assets/incremental_directional_encoder.gif"><br>Tracking the signals (from left to right), you get signal values that look like this:<br><img alt="quad-encoder-waveform-output.png" src="https://stormbots.github.io/KnowledgeBase/assets/quad-encoder-waveform-output.png"><br>Because of the way the two signals overlap, you now have 4 signal states: 00, 01, 11, and 00. And importantly, you from any particular state, you can only go to 2 of other 3 states! For example, you cannot go directly from 11 to 00 : You must go to either 10 or 01. <br>Because of this, you always know what way a rotation is happening: If you're at 11, and go to 10, you're going clockwise. <br>This property means that quadrature encoders are much more capable than GearTooth encoders. It can still track velocity, but can measure velocities at low speeds, or with external inputs where you wouldn't know the direction. <br>In addition, since you always know the direction, you can also just count the pulses as they come by. This lets you know precisely how far something has rotated, effectively indefinitely. <br>It's important to note that another name for these is a "Relative encoder", since it only tells you a rotation relative to when it started counting! This means where your system is when the sensor starts is an important consideration!<br><br><br>The Rio can directly handle external quadrature encoders using the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" target="_blank">WPI Lib Encoders</a> classes. While uncommon in modern FRC, they show up on occasion. <br><br>Modern FRC uses brushless motors for most operations, and have built in encoders that are ready to use! As a result, this is the most common interaction with encoders.<br>These are accessed by interfacing with a Spark Motor controller, like so. <br>ExampleSubsystem extends SubsystemBase{
	//Note: Your motor ID will probably be something different!
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	RelativeEncoder encoder = motor.getEncoder();

	// ... other stuff this way
}
<br>Rookie Coder notes
If you're still getting the hang of code structure, you can work in the ExampleSubsystem.java file for now! It's all set up on new Command Based Robot templates, and will work like you're expecting.
<br>Finding Motor IDs
If you're unsure about the motor ID, you can do get it using the <a data-href="Rev Hardware Client#Identifying a motor ID" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html#Identifying_a_motor_ID" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client &gt; Identifying a motor ID</a>
<br>We now have an encoder.... but it's not doing anything. Let's make it do something. Encoders are good at telling you how far they rotated, so let's print that. <br>ExampleSubsystem extends SubsystemBase{
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	RelativeEncoder encoder = motor.getEncoder();
	
	// ... other stuff
	
	public void periodic (){
		System.out.println(encoder.getPosition());
	}
}
<br>Deploy this to the robot, and you should pop up with the Riolog tab in VSCode. If not, hit CTRL+Shift+P to bring up the VS Code Command Pallete. Type "Start Riolog" to select the option, then hit enter.<br>You should now see a screen full of numbers. So... try rotating your motor. It should change, but it's unclear how much. We haven't configured it to any sort of a known state.<br>To get better diagnostic information such as graphs, or multiple values at once, you might check out <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a><br><br>The <a data-href="Rev Hardware Client" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a> page can assist with adjusting parameters, which is useful for quick diagnostics and testing. <br>To configure it in code, we need to do a few things. First, is set up a config object, and clear factory defaults. This means we have a lot of potential quirks cleaned up instantly.<br>ExampleSubsystem extends SubsystemBase{
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	RelativeEncoder encoder = motor.getEncoder();
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		armMotor.configure(
			//The configuration settings to apply
			config,
			//Whether or not to reset all unspecivied values
			ResetMode.kResetSafeParameters,
			//Whether or not to keep the new values after 
			//power cycling the motor controller
			PersistMode.kPersistParameters
		);
	}	
	// ... other stuff
}
<br>If you run this on your test bench, you'll probably see the numbers change differently than they did prior. By default, the encoder is configured to provide "Rotations" from the getPosition() method. If you rotate the motor shaft exactly once, the encoder will return 1. <br>If your testbench has some gearing involved, you'll get a different number multiplied by the gearing. For example, if you're on a Kit Of Parts drivetrain, it might have a gear ratio of 12.75:1. This means it takes 12.75 motor rotations to rotate the output wheel once. Or, put the opposite way: If you rotate drivetrain wheel exactly once, you should get an encoder reading of 12.75. <br>However, we generally care more about the output of the system than the motor, so we want to apply a conversion factor so we can "read" the output directly. <br>To get this, we need to take that logic above, and rotate our system's output exactly once. Record the number of "motor rotations" as your conversion factor, and we'll add it to the code.<br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		var conversionfactor=12.75; //1 divided by whatever number you determined
		config.encoder.positionConversionFactor(1/conversionfactor);
		armMotor.configure(
			config,
			ResetMode.kResetSafeParameters,
			PersistMode.kPersistParameters
		);
	}	
	// ... other stuff
}
<br>The "conversion factor" is just a multiplier from the base unit (1 rotation). Since we know that 1 output rotation generates 12.75 motor rotations, we want to divide by 12.75. <br>And, after we deploy this, we'll see that we can rotate our wheel once, and get an "encoder" reading of 1. <br><br>We've been glossing over velocity, but it's time! This is helpful too. The process from this point is actually pretty easy, and we can get it with just a few minor changes. <br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		var conversionfactor=12.75; //1 divided by whatever number you determined
		config.encoder.positionConversionFactor(1/conversionfactor);
		//Configure the velocity conversion factor too
		config.encoder.velocityConversionFactor(1/conversionfactor/60);
		armMotor.configure(
			config,
			ResetMode.kResetSafeParameters,
			PersistMode.kPersistParameters
		);
	}	
	// ... other stuff
	public void periodic (){
		//Change to velocity
		System.out.println(encoder.getVelocity());
	}
}

<br>The main detail of note is that we use the same conversion factor to account for gearing.<br>
We also have two ways of doing velocity conversion, depending on our desired Rate unit. <br>By default, 1/conversionfactor will give us Rotations Per Minute. In this case, the extra /60 is to convert from rev's default Velocity unit of Rotations Per Minute to Rotations Per Second. For many of our tasks, having the unit in "per second" winds up being more useful since it's easier to visualize.<br>Generally, we'll calculate the conversion factor using Position since it removes the aspect of time; This makes it much, much simpler to get accurate results. <br><br>Now that we can convert motor rotations to output shaft rotation, we can go a step further and convert that output rotation to a linear motion. This is pretty straightforward: Over 1 rotation, you cover 1 circumference of distance. So, just divide your conversion factor by your wheel diameter. Since we're calculating "x distance per rotation", so you would expect a division here.<br>
The final configuration will look something like this:<br>// ... stuff
	var circumference = Math::PI * 4; // 4 inch wheel
	//1 divided by whatever number you determined
	var conversionfactor=12.75/circumference;
// ... the rest of the stuff
<br><br>If the units to configure your encoder is overwhelming, consider <a data-href="Factor Label" href="https://stormbots.github.io/KnowledgeBase/misc/factor-label.html" class="internal-link" target="_self" rel="noopener nofollow">Factor Label</a> methods to help you step through it. This is a useful method of tabulating units to keep track of conversions like this. <br>As a sample calculation, this is what it looks to set up the conversion for a KOP bot's drivetrain from motor rotations to inches per second.<br><br><br>Another way we'll commonly handle encoder configuration is through a simple empirical process:<br>
<br>Set the encoder conversion to 1 , putting the units as "motor rotations"
<br>Put the system to known physical condition that's easy to measure. (zero feet traveled, arm at horizontal, etc)
<br>Zero the encoder (either a power cycle or a code reset)
<br>Move the system to a new physical condition that's also easy to measure. (10 feet traveled, arm at vertical, etc)
<br>Keeping with our Kitbot example, in factor label form it would look something like this:<br><br>Doing the math, we get  inches/motor rotations, and our conversion factor is decided!<br>An advantage of this method is that it requires no knowledge about how a system is geared. This is great for getting a system running and validating calculations. It can also help with systems that have difficult to calculate ratios, such as winding ropes or straps. <br>One big disadvantage is precision: Every time you repeat this calculation, the results are slightly different. This may or may not be a problem, depending on the mechanism. <br>Competition Consideration
It's not advised to use empirical analysis for drivetrains! During competition, wheel wear will often force constant re-calibration. However, in pit environment it's very challenging to get space to push a drivetrain. This makes corrections time consuming and inaccurate, making your drivetrain and autos inconsistent.
<br><br>Having insight into the robot provides a ton of value, especially when combined with  <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> and <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> . This makes it easy to do things like <br>
<br>See if a shooter is near a desired RPM before feeding a game piece into it
<br>See how far you've driven and stop
<br>Check a system's speed to see if it jammed.
<br>We're not quite ready to do things like precisely control RPM, speed, or distance. For that, we need a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>.<br><br>Quadrature encoders are powerful, but not without flaws. The main thing is fundamental to position tracking with this type of encoder:<br>
<br>You need to already know where you are when you you start counting pulses to have a meaningful knowledge of the system's position
<br>If something causes it to lose count (such as loss of power or a code reset), then you've lost the connection to the reference, and now don't know where you are.
<br>There's a couple ways to avoid this. The easiest way is to start at your reference, and not lose count! As you might expect, this places some constraints on how you as humans boot up the robot. It also carries a small (but non-zero) risk for the second case. <br>For fully mitigating this, you need to make use of <a data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a> , which allow you to fully recapture your reference from an unknown starting state.<br>Other options include simply using different sensors! For example, <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a> can capture rotation data. <br><br>Encoders all have functions to set or zero the current encoder value value. For our example, we could do this using the following code<br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		//Reset encoder on boot ?
		encoder.setPosition(0);
	}
	// Other stuff
<br>But should we? We need to consider both the mechanisms physical state and the code state carefully, since we expect them to correlate. Let's examine the typical points at which one or both of these can change<br>
<br>When power is applied, the mechanism is in an unknown position, the encoder is at zero, and the code runs initialization.
<br>When you deploy new code after running it, the mechanism can be in any state, the encoder is unchanged (by default) , and our code re-runs initialization
<br>This leads to the following cases: <br>
<br>If we power on the bot in an known reference state, the encoder will match it for the first run of code.
<br>If we do not reset position in initialization, we can always assert that the encoder still matches the physical position, even if we re-run or restart code.
<br>If we do reset position, we do so without being able to assert that we're at the hardware reference!  This means we have to physically check that we're at the hardware each time manually. 
<br>Because of this, for now we probably do not want to zero the encoder, which allows us to set the physical state once on boot, and re-use it indefinitely. <br>If needed, you can generate <a data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a>, which are ways for the bot to physically assert a known system state and do the reset encoders safely. These are usually optional (at least initially), but are critical for robust high-torque systems or high precision ones.Encoder Basics<br><br>Requires:<br>
<a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>Hardware: <br>
<br>Switches
<br>Encoder
<br>LaserCan
<br><br>
<br>Create a Trigger that represents a sensor condition
<br>Create a Joystick command that runs indefinitely, but stops when the Trigger is in a true condition. 
<br>Repeat with a different sensor type
<br>Create a Trigger that performs a Command automatically when triggered
<br><br>Sensing is interacting with physical objects, and changing robot behaviour based on it.<br>
This can use a variety of sensors and methods, and will change from system to system<br><br>Often simple sensors like break beams or switches can tell you something very useful about the system state, which can help you set up a different, more precise sensor. <br>The most common application is in <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> such as a <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> type systems. On boot, your your <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder</a> may not properly reflect the system state, and thus the elevator position is invalid. But, if you you have a switch at the end of travel you can use this to re-initialize your encoder, as the simple switch.Sensing Basics<br><br>Requires:<br>
<a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br><br>
<br>
??? 

<br>
Covering system "state" is very useful, especially in subsystems

<br>
ConditionalCommand + SelectCommand can be useful for attributing actions and states on simple systems

<br>
Need to find a sensible formal way to cover it; It's easy to make "custom" state machines for simple systems, but hard to scale up in complexity with consistent patterns.

<br><br>
<br>States of Unloaded, unaligned, loaded, scoring
<br>Consideration: Explain state machines here, as an explanation of how they're used and what they represent<br>Actually make it a workshop later.<br><br>This example demonstrates a small video game character and how you might handle their Jump logic<br>State Machines<br><br>Requires:<br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create an Arm subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world angle values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current angle
<br>Create a setAngle function that takes a angle, and returns a command that runs indefinitely to the target angle
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
SuperStructure Arm<br><br>Requires<br>
<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Create a PID system on a test bench
<br>Tune necessary PIDs using encoders
<br>Set a velocity using a PID
<br>Set a angular position using a PID
<br>Set a elevator position using a PID
<br>Plot the system's position, target, and error as you command it.
<br><br>TODO:<br>
Add some graphs<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/DylanHojnoski/obsidian-graphs" target="_blank">https://github.com/DylanHojnoski/obsidian-graphs</a><br>
Write synopsis<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/revlib/spark/closed-loop" target="_blank">https://docs.revrobotics.com/revlib/spark/closed-loop</a><br><br>A PID system is a <a data-href="Closed Loop Controller" href="https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controller</a> designed to reduce system error through a simple, efficient mathematical approach.<br>You may also appreciate Chapter 1 and 2 from <a data-href="controls-engineering-in-frc.pdf" href="https://stormbots.github.io/KnowledgeBase/misc/controls-engineering-in-frc.pdf" class="internal-link" target="_self" rel="noopener nofollow">controls-engineering-in-frc.pdf</a> , which covers PIDs very well. <br><br><br><br>Often in robotics, we care a lot about the final state of a system: The position it's at, the rate it's going, the height of an elevator, etc. <br>However, the process of getting and maintaining this target state might not be trivial. It might require a variety of motor outputs to get there, change over time,  or be unpredictable due to external factors like game piece weight.<br>A closed loop controller is designed to manage exactly this. Instead of simply setting the output directly (a motor speed), we can instead provide a setpoint, representing the target state of our system. This can be a position, rate, temperature, brightness, or any other  measurable quantity. It's sometimes considered the "goal state".<br>A closed loop controller's job is to then manage the measured quantity and adjust the output to maintain that setpoint. In technical terms, we "feed back" the output as an input to this controller, forming a "closed loop" in our process diagram.<br><img alt="open-loop-closed-loop-diagram.png" src="https://stormbots.github.io/KnowledgeBase/assets/open-loop-closed-loop-diagram.png"><br><br>Before getting started, we  need to identify a few things: <br>
<br>A setpoint: This is the goal state of your system. This will have units in that target state, be it height, meters, rotations/second, or whatever you're trying to do. 
<br>An output: This is often a motor actuator, and likely 
<br>A measurement: The current state of your system from a sensor; It should have the same units as your Setpoint.
<br>Controller: The technical name for the logic that is controlling the motor output. In our case, it's a PID controller, although many types of controllers exist.
<br><br>To get an an intuitive understanding about PIDs and feedback loops, it can help to start from scratch, and kind of recreating it from the basic assumptions and simple code.<br>Let's start from the core concept of "I want this system to go to a position and stay there". <br>Initially, you might simply say "OK, if we're below the target position, go up.  If we're above the target position, go down." This is a great starting point, with the following pseudo-code.<br>setpoint= 15  //your target position, in arbitrary units
sensor= 0 //Initial position
if(sensor &lt; setpoint){ output = 1 }
else if(sensor &gt; setpoint){ output = -1 }
motor.set(output)
<br>However, you might see a problem. What happens when setpoint and sensor are equal? <br>If you responded with "It rapidly switches between full forward and full reverse", you would be correct. If you also thought "This sounds like it might damage things", then you'll understand why this controller is named a "Bang-bang" controller, due to the name of the noises it tends to make.<br>Your instinct for this might be to simply not go full power. Which doesn't solve the problem, but reduces it's negative impacts. But it also creates a new problem. Now it's going to oscillate at the setpoint (but less loudly), and it's also going to take longer to get there.<br>So, let's complicate this a bit. Let's take our previous bang-bang, but split the response into two different regions: Far away, and closer. This is easier if we introduce a new term: Error. Error just represents the difference between our setpoint and our sensor, simplifying the code and procedure. "Error" helpfully is a useful term, which we'll use a lot.<br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	error = setpoint-sensor 
	if     (error &gt; 5){ output = -1 }
	else if(error &gt; 0){ output = -0.2 }
	else if(error &lt; 0){ output = 0.2 }
	else if(error &lt; -5){ output = 1 }
	motor.set(output)
})
<br>We've now slightly improved things; Now, we can expect more reasonable responses as we're close, and fast responses far away. But we still have the same problem; Those harsh transitions across each else if. Splitting up into more and more branches doesn't seem like it'll help. To resolve the problem, we'd need an infinite number of tiers, dependent on how far we are from our targets. <br>With a bit of math, we can do that! Our error term tells us how far we are, and the sign tells us what direction we need to go... so let's just scale that by some value. Since this is a constant value, and the resulting output is proportional to this term, let's call it kp: Our proportional constant. <br>run(()-&gt;{
	setpoint= 15  //your target position, in arbitrary units
	sensor= 0 //read your sensor here
	kp = 0.1
	error = setpoint-sensor 
	output = error*kp
	motor.set(output)
)}
<br>Now we have a better behaved algorithm! At a distance of 10, our output is 1. At 5, it's half. When on target, it's zero! It scales just how we want. <br>Try this on a real system, and adjust the kP until your motor reliably gets to your setpoint, where error is approximately zero. <br>In doing so, you might notice that you can still oscillate around your setpoint if your gains are too high. You'll also notice that as you get closer, your output drops to zero. This means, at some point you stop being able to get closer to your target. <br>This is easily seen on an elevator system. You know that gravity pulls the elevator down, requiring the motor to push it back up. For the sake of example, let's say an output of 0.2 holds it up. Using our previous kP of 0.1, a distance of 2 generates that output of 0.2. If the distance is 1, we only generate 0.1... which is not enough to hold it! Our system actually is only stable below where we want. What gives! <br> This general case is referred to as "standing error" ; Every loop through our PID fails to reduce the error to zero, which eventually settles on a constant value. So.... what if.... we just add that error up over time? We can then incorporate that error into our outputs. Let's do it.<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
kp = 0.1
ki = 0.001
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	output = error*kp + errorsum*ki
	motor.set(output)
}
<br>The mathematical operation involved here is called integration, which is what this term is called. That's the "I" in PID.<br>
In many practical FRC applications, this is probably as far as you need to go! P and PI controllers can do a lot of work, to suitable precision. This a a very flexible, powerful controller, and can get "pretty good" control over a lot of mechanisms. <br>This is probably a good time to read across the  <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/pidcontroller.html" target="_blank">WPILib PID Controller</a>  page; This covers several useful features. Using this built-in PID, we can reduce our previous code to a nice formalized version that looks something like this.<br>PIDController pid = new PIDController(kP, kI, kD);
run(()-&gt;{
	sensor = motor.getEncoder.getPosition();
	motor.set(pid.calculate(sensor, setpoint))
})
<br>A critical detail in good PID controllers is the iZone or ErrorZone. We can easily visualize what problem this is solving by just asking "What happens if we get a game piece stuck in our system"?<br>
Well, we cannot get to our setpoint. So, our errorSum gets larger, and larger.... until our system is running full power into this obstacle. That's not great. Most of the time, something will break in this scenario. <br>So, the iZone allows you to constrain the amount of error the controller actually stores. It might be hard to visualize the specific numbers, but you can just work backward from the math. If output = errorsum*kI, then maxIDesiredTermOutput=iZone*kI. So iZone=maxIDesiredTermOutput/kI.<br>Lastly, what's the D in PID?<br>Well, it's less intuitive, but let's try. Have you seen the large spike in output when you change a setpoint? Give the output a plot, if you so desire. For now, let's just reason through a system using the previous example PI values, and a large setpoint change resulting in an error of 20. <br>Your PI controller is now outputting a value of 2.0 ; That's double full power! Your system will go full speed immediately with a sharp jolt, have a ton of momentum at the halfway point, and probably overshoot the final target. So, what we want to do is constrain the speed; We want it fast but not too fast. So, we want to reduce it according to how fast we're going.<br>
Since we're focusing on error as our main term, let's look at the rate the error changes. When the error is changing fast we want to reduce the output. The difference is simply defined as error-previousError, so a similar strategy with gains gives us output+=kP*(error-previousError) .<br>
This indeed gives us what we want: When the rate of change is high, the contribution is negative and large; Acting to reduce the total output, slowing the corrective action.<br>However, this term has another secret power, which disturbance rejection. Let's assume we're at a steady position, and the system is settled, and error=0. Now, let's bonk the system downward, giving us a sudden large, positive error. Suddenly nonzero-0 is positive, and the system generates a upward force. For this interaction, all components of the PID are working in tandem to get things back in place quickly.<br>Adding this back in, gives us the fundamental PID loop:<br>setpoint= 15  //your target position, in arbitrary units
errorsum=0
lastSensor=0
kp = 0.1
ki = 0.001
kd = 0.01
run(()-&gt;{
	sensor= 0 //read your sensor here
	error = setpoint-sensor
	errorsum += error
	errordelta = sensor-lastSensor
	lastSensor=sensor
	output = error*kp + errorsum*ki + errordelta*kd
	motor.set(output)
}
<br><br>OK, that's enough nice things. Understanding PIDs requires knowing when they work well, and when they don't, and when they actually cause problems. <br>
<br>PIDs are reactive, not predictive. Note our key term is "error" ; PIDs only act when the system is already not where you want it, and must be far enough away that the generated math can create corrective action.
<br>Large setpoint changes break the math. When you change a setpoint, the P output gets really big, really fast, resulting in an output spike. When the PID is acting to correct it, the errorSum for the I term is building up, and cannot decrease until it's on the other side of the setpoint. This almost always results in overshoot, and is a pain to resolve.  
<br>Oscillation: PIDs inherently generate oscillations unless tuned perfectly. Sometimes big, sometimes small.
<br>D term instability: D terms are notoriously quirky. Large D terms and velocity spikes can result in bouncy, jostly motion towards setpoints, and can result in harsh, very rapid oscillations around the zero, particularly when systems have significant <a data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanical Backlash</a>.
<br>PIDS vs Hard stops: Most systems have one or more <a data-href="Hard Stops" href="https://stormbots.github.io/KnowledgeBase/level-1/hard-stops.html" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a>, which present a problem to the I term output. This requires some consideration on how your encoders are initialized, as well as your setpoints.
<br>Tuning is either simple....or very time consuming.
<br>Only works on "Linear" systems: Meaning, systems where the system's current state does not impact how the system responds to a given output. <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> are an example of a non-linear system, and to a given output very differently when up and horizontally. These cannot be properly controlled by just a PID. 
<br>So, how do you make the best use of PIDs?<br>
<br>Reduce the range of your setpoint changes. There's a few ways to go about it, but the easiest are <a data-href="clamping" href="https://stormbots.github.io/KnowledgeBase/misc/clamping.html" class="internal-link" target="_self" rel="noopener nofollow">clamping</a> changes, <a data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a> and <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> . With such constraints, your error is always small, so you can tune more aggressively for that range. 
<br>Utilize <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> to create the basic action; Feed-forwards create the "expected output" to your motions, reducing the resulting error significantly. This means your PID can be tuned to act sharply on disturbances and unplanned events, which is what they're designed for.
<br>In other words: This is an error correction mechanism. By reducing or controlling the initial error a PID would act on, you can greatly simplify the PID's affect on your system, usually making it easier to get better motions. Using a PID as the "primary action" for a system might work, but tends to generate unexpected challenges.<br><br>Tuning describes the process of dialing in our "gain values"; In our examples, we named these kP, kI, and kD. These values don't change the process of our PID, but it changes how it responds.<br>There's actually several "formal process" for tuning PIDs; However, in practice these often are more complicated and aggressive than we really want. You can read about them if you'd like <a data-tooltip-position="top" aria-label="https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_(Woolf)/09%3A_Proportional-Integral-Derivative_(PID)_Control/9.03%3A_PID_Tuning_via_Classical_Methods" rel="noopener nofollow" class="external-link" href="https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_(Woolf)/09%3A_Proportional-Integral-Derivative_(PID)_Control/9.03%3A_PID_Tuning_via_Classical_Methods" target="_blank">PID Tuning via Classical Methods</a><br>In practice though, the typical PID tuning process is more straightforward, but finicky.<br>
<br>Define a small range you want to work with: This will be a subset of 
<br>Create a plot of your setpoint, current state/measurements, and system output. <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a> is usually good enough here.
<br>Starting at low values, increase the P term until your system starts to oscillate near the goal  state. Reduce the P term until it doesn't. Since you can easily 
<br>Add an I term, and increase the value until your system gets to the goal state with minimal overshoot. Often I terms should start very small; Often around 1%-10% of your P term. Remember, this term is summed every loop; So it can build up very quickly when the error is large. 
<br>If you're tuning a shooter system, get it to target speed, and feed in a game piece; Increase the D term until you maintain the RPM to an effective extent. 
<br>Rev Velocity Filtering
Rev controllers by default implement a velocity filter, making it nearly impossible to detect rapid changes in system velocity. This in turn makes it nearly impossible to tune a D-term.<br>
<a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a> Document how to remove these filters
<br>Hazards of Tuning
Be aware that poorly tuned PIDs might have very unexpected, uncontrolled motions, especially when making big setpoint changes.<br>
They can jolt unexpectedly, breaking chains and gearboxes. They can overshoot, slamming into endstops and breaking frames. They'll often oscillate shaking loose cables, straps, and stressing your robot.<br>
Always err on the side of making initial gains smaller than expected, and focus on safety when tuning. 
<br>Setpoint Jumps + Disabled robots
Remember that for PID systems the setpoint determines motor output;  If the bot  is disabled, and then re-enabled, the bot will actuate to the setpoint!<br>
Make sure that your bot handles re-enabling gracefully; Often the best approach is to re-initialize the setpoint to the bot's current position, and reset the PID controller to clear the I-term's error sum.
<br><br>In seasons past, a majority of our programming time was just fiddling with PID values to get the bot behaviour how we want it. This really sucks. Instead, there's more practical routines to avoid the need for precision PID tuning. <br>
<br>Create a plot of your setpoint, current state/measurements, and system output. <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a> is usually good enough here.
<br>Add a <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> : It doesn't have to be perfect, but having a basic model of your system massively reduces the error, and significantly reduces time spent fixing PID tuning. This is essential for Arms; The FeedForward can easily handle the non-linear aspects that the PID struggles with.
<br>In cases where game pieces contribute significantly to the system load, account for it with your FeedForward: Have two different sets of FeedForward values for the loaded and unloaded states
<br>Use <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>: A Trapezoidal profile is optimal and remarkably straightforward. This prevents many edge cases on PIDs such as sharp transitions and overshoot. It provides very controlled, rapid motion. 

<br>Alternatively, reduce setpoint changes through use of a Ramp Rate or <a data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a>. This winds up being as much or more work than Motion Profiles with worse results, but can be easier to retrofit in existing code.
<br>An even easier and less effective option is simply <a data-tooltip-position="top" aria-label="clamping" data-href="clamping" href="https://stormbots.github.io/KnowledgeBase/misc/clamping.html" class="internal-link" target="_self" rel="noopener nofollow">Clamp</a> clamp the setpoint within a small range around the current state. This provides a max error, but does not eliminate the sharp transitions.


<br>Set a very small ClosedLoopRampRate; Just enough to prevent high-frequency oscillations, which will tend to occur when the setpoint is at rest, especially against <a data-href="Hard Stops" href="https://stormbots.github.io/KnowledgeBase/level-1/hard-stops.html" class="internal-link" target="_self" rel="noopener nofollow">Hard Stops</a> or if <a data-tooltip-position="top" aria-label="Mechanical Backlash" data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Backlash</a> is involved. This is just a <a data-tooltip-position="top" aria-label="Slew Rate Limiting" data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiter</a> being run on the motor controller against the output.
<br>From here, the actual PID values are likely to barely matter, making tuning extremely straightforward: <br>
<br>Increase the P term until you're on target through motions and not oscillating sharply at rest
<br>Find a sensible output value that fixes static/long term disturbances (change in weight, friction, etc). Calculate the target iZone  to a sensible output just above what's needed to fix those. 
<br>Start with I term of zero; Increase the I term if your system starts lagging during some long motions, or if it sometimes struggles to reach setpoint during
<br>If your system is expected to maintain it's state through predictable disturbances (such as maintaining shooter RPM when launching a game piece), test the system against those disturbances, and increase the D term as needed. You may need to decrease the P term slightly to prevent oscillations when doing this.
<br>Watch your plots. A well tuned system should 

<br>Quickly approach the target goal state
<br>Avoid overshooting the target
<br>Settle on a stable output value
<br>Recover to the target goal state (quickly if needed)


<br><br>
<br>Discontinuity + setpoint wrappping for PIDs + absolutes
<br>
PID<br><a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>
<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Install the WPILib VS Code IDE
<br>Make a new robot project
<br>Create a new subsystem
<br>Install the Rev third Library
<br>Basic requirements to start working  on robot projects
<br>Create a new empty subsystem 
<br>Create a new empty command
<br>Add your new command and subsystem to RobotContainer.
<br><br>Programming prerequisites, listed in <a data-href="Coding Basics" href="https://stormbots.github.io/KnowledgeBase/level-0/coding-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Basics</a> for now<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html</a><br><br>When you open a new robot project you'll see a lot of files we'll interact with.<br>
<br>src/main

<br>deploy
<br>java
<br>frc/frc/robot

<br>commands

<br>ExampleCommand.java


<br>subsystems

<br>ExampleSubsystem.java


<br>Constants.java
<br>Main.java
<br>Robot.java
<br>RobotContainer.java




<br>vendordeps
<br>For typical projects, you'll be spending the most time in RobotContainer, subsystems, and occasionally commands. <br>For some early practice projects, or special use cases you might also interact with Robot.java,  ExampleCommand.java, or ExampleSubsystem.java a bit.<br><br>Many helpful utilities we'll use for robot projects are represented using code that's not available by default. WPILib has a small manager to assist with installing these, detailed here: <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries</a><br><br>We'll also utilize a number of software tools for special interactions with hardware or software components. Some of these include <br>
<br><a data-href="Rev Hardware Client" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a> , a motor controller management tool
<br><a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">GrappleHook</a> , which manages the LaserCan configuration
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" target="_blank">NI Driver Station</a> is needed for systems that will want to enable and drive a robot. 
<br><br>The hardest part of getting started with robots is figuring out where your robot code goes. <br><br>Robot.java is a very powerful file, and it's possible to write your entire robot in just this one file! For reasons we'll get into later, we do not want to do this. However, the setup of it does a good job explaining how a robot works. Let's look at the structure of this file for now<br>public class Robot extends TimedRobot {
	private Command m_autonomousCommand;
	private final RobotContainer m_robotContainer;
	public Robot() {
		m_robotContainer = new RobotContainer();
	}
	
	public void robotPeriodic() {}
	
	public void disabledInit() {}
	public void disabledPeriodic() {}
		
	public void autonomousInit() {}
	public void autonomousPeriodic() {}
	
	public void teleopInit() {}
	public void teleopPeriodic() {}
	
	public void testInit() {}
	public void testPeriodic() {}
	
	//a few more ignored bits for now
}
<br>From the pairing, we can group these into several different modes<br>
<br>"Robot"
<br>Autonomous
<br>Teleop
<br>Test
<br>Indeed, if we look at our <a data-href="Driver Station" href="https://stormbots.github.io/KnowledgeBase/misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a>, we see several modes mentioned.<br>
<img alt="driverstation.jpg" src="https://stormbots.github.io/KnowledgeBase/assets/driverstation.jpg"><br>
Teleop, Auto, and Test are simply selectable operational modes. However, you might want to utilize each one slightly differently.<br>"Practice mode" is intended to simulate real matches: This DriverStation mode runs Autonomous mode for 15 seconds, and then Teleop Mode for the remainder of a match time. <br>"Disabled" mode is automatically selected whenever the robot is not enabled. This includes when the robot boots up, as well as as whenever you hit "disabled" on the driver station.<br>
Disabled mode will also cancel any running <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> . <br>"Robot mode" isn't an explicit mode: Instead, of "Robot Init", we just use the constructor: It runs when the robot boots up. In most cases, the primary task of this is to set up Robot Container.<br>
robotPeriodic just runs every loop, regardless of what other loop is also running.<br>We can also see a grouping of <br>
<br>Init
<br>Periodic<br>
Whenever any new "mode" starts, we first run the Init function once, and then we run the periodic. The robot will continue run associated Periodic functions every loop, 50 times per second. 
<br>We generally won't add much code in Robot.java, but understanding how it works is a helpful starting point to understanding the robot itself. <br><br>As mentioned above, the "Robot Container" is created when you create a new project, and one of the first things that gets executed when running robot code. <br>This file contains a small number of functions and examples to help you organized. <br>public class RobotContainer(){
	ExampleSubsystem subsystem = new ExampleSubsystem();
	ExampleCommand command = new ExampleCommand();
	CommandXboxJoystick joystick = new CommandXboxJoystick(0);
	RobotContainer(){
		configureBindings();
	}
	public void configureBindings(){
		//Not a special function; Just intended to help organize 
	}
	public Command getAutonomousCommand(){/*stuff*/}
}
<br>This file introduces a couple new concepts  <br>
<br><a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, which form the  "actions" you want the robot to perform
<br><a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>, or the different parts of the robot that could perform actions
<br><a data-href="Joysticks" href="https://stormbots.github.io/KnowledgeBase/misc/joysticks.html" class="internal-link" target="_self" rel="noopener nofollow">Joysticks</a> , which serve as the standard input method.
<br>The use of Commands and Subsystems goes a long way to managing complex robot interactions across many subsystems. However, they're certainly tricky concepts to get right off the bat. <br><br>Sometimes, you'll have oddball constants that you need to access in multiple places in your code. Constants.java advertises itself as a place to sort and organize these constants. <br>Without getting too into the "why", in general you should minimize use of Constants.java; It often leads to several problems as your robot complexity increases. <br>Instead, keep your constants as close to where they're used as possible, and move them up through the robot hierarchy as necessary. This is known as  "scope management" or "encapsulation".<br>
<br>If a value is used once, just use the value directly. This covers a lot of setup values like PID tuning values.
<br>If your value is used repeatedly inside a subsystem, make it a private constant in that subsystem. This is common for conversion factors, min/max values, or paired output values
<br>If a constant is strongly associated with a subsystem, but needs to be referenced elsewhere, make it a public constant in that subsystem.
<br>Lastly, if something is not associated with a subsystem, and used repeatedly across multiple subsystems, Constants.java is the place. 
<br>If you find yourself depending on a lot of constants, you might need to consider <a data-href="Refactoring" href="https://stormbots.github.io/KnowledgeBase/misc/refactoring.html" class="internal-link" target="_self" rel="noopener nofollow">Refactoring</a> your code a bit to streamline things. Note that Stormbots code generally has almost nothing in here! <br><br>The ExampleSubsystem.java file is a preconfigured, blank <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a>. We'll explore Subsystems in depth later.<br>By default, this class is created, and the periodic() function it contains will run every code loop. This makes it a great place to put a lot of starter code with minimal setup and fuss.<br><br>This is a standard, blank <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> . By itself, this file is not too useful. However, the fact that it exists allows useful joystick interactions to be set up in RobotContainer.java<br><br>The code examples provided in early code samples will be built using ExampleSubsystem and ExampleCommand, built into every new robot project. They should work as expected without a deeper understanding of Command based robots while you get your footing, and enabling you to migrate to Command based robots once you get there. If an example doesn't talk about Command based stuff, you probably don't have to worry about it!<br><br>While you can just create new files in a "normal" way, it's easy to accidentally miss code details that make things harder for yourself. <br>Instead, WPILib+VSCode has a built in way to do this. Simply right click the appropriate folder, and find the "Create new class/command" option.<br><img alt="creating-new-command-1.png" src="https://stormbots.github.io/KnowledgeBase/assets/creating-new-command-1.png"><br>This will present you with a list of common FRC classes. The typical ones you'd use are Command and Subsystem.<br><img alt="creating-new-command-2.png" src="https://stormbots.github.io/KnowledgeBase/assets/creating-new-command-2.png"><br><br>For those familiar with coding, you might wonder "Where does code actually start from?". This is a fair question in FRC code, which is a more complicated framework. The code path itself is predictable and a simplified view looks like this<br>- Main Bot Initialization
  - Robot.java::RobotInit
    - RobotContainer
      - Subsystem Constructors
      - Command constructors
  - Enter Disabled mode
    
- Disabled Mode
  - Initialize 
    - Robot.java::DisabledInit()
  - Loop
    - Robot.java::DisabledPeriodic
    - (each subsystem)::periodic()
      
- Teleop Mode
  - Initialize 
    - Robot.java::TeleopInit()
    - (any active commands)::init()
  - Loop
    - Robot.java::TeleopPeriodic()
    - (each subsystem)::periodic()
    - (any active commands)::execute()
<br>This is a lot of complexity if you're new to coding, but don't panic. You can mostly ignore a lot of this complexity, and our examples will help you position things properly until you get your bearings. <br>The complex part, robot actions that move motors and do things, basically boil down into<br>initialize/prep on boot
disabled
initialize
run
stop
<br>We will quickly capture this with our <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> framework, enabling you to do simple things very quickly and efficiently, like they're self-contained little programs.<br><br><a data-href="Deploying Code" href="https://stormbots.github.io/KnowledgeBase/level-0/deploying-code.html" class="internal-link" target="_self" rel="noopener nofollow">Deploying Code</a>Robot Code Basics<br><br>Requires:<br>
<a data-href="Robot Code Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Create a command that runs indefinitely
<br>Have that command start+end on a joystick button
<br>Create a command that starts on a joystick press, and stop it with a different button
<br>Create a default command that lets you know when it's running through <a data-tooltip-position="top" aria-label="Basic Telemetry" data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Telemetry</a>
<br>Create a runCommand using a function pointer
<br>Create a runCommand using a lambda
<br>Learning order
You can learn this without having done <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>, but it's often more fun to learn alongside it in order to have more interesting, visual commands while experimenting.<br>
The commands provided as an example just print little messages visible in the RioLog, allowing this to be set up without motors
<br><br>A Command is an event driven code structure that allows you manage when code runs, what resources it uses, and when it ends. <br>In the context of a robot, it allows you to easily manage a lot of the complexity involved with managing multiple <a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> <br>The code structure itself is fairly straightforward, and defines a few methods; Each method defines what code runs at what time. <br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){}
	public void initialize(){}
	public void execute(){}
	public boolean isFinished(){ return false; }
	public void end(boolean cancelled){}
}
<br>Behind the scenes, the robot runs a command scheduler, which helps manage what runs when. Once started, a command will run according to the following flowchart, more formally known as a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">state machine</a>. <br><br>This is the surface level complexity, which sets you up for how to view, read, and write commands. <br><br>A key aspect of Commands is their ability to claim temporary, exclusive  ownership over a <a data-href="Subsystem" href="https://stormbots.github.io/KnowledgeBase/Subsystem" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> .  This is done by passing the subsystem into a command, and then adding it as a requirementcontroll<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(ExampleSubsystem subsystemName){
		addRequirements(subsystemName);
	}
<br>Now, whenever the command is started, it will forcibly claim that subsystem. It'll release that claim when it runs it's end() block.<br>This ability of subsystems to hold a claim on a resource has a lot of utility. The main value is in preventing you from doing silly things like trying to tell a motor to go forward and backward at once.<br><br>Now that we've established subsystem ownership, what happens when you do try to tell your motor to go forward and then backward?<br>When you start the command, it will forcibly interrupt other commands that share a resource with it, ensuring that the new command has exclusive access. <br>It'll look like this<br><br>When a command is cancelled, the command scheduler runs the commands end(cancelled) block, passing in a value of true. Whole not typical, some commands will need to do different cleanup routines depending on whether they exited on a task completion, or if something else kicks em off a subsystem. <br><br>Commands can be started in one of 3 ways:<br>
<br>via a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>'s start condition
<br>Directly scheduling it via the command's .schedule() method.
<br>Automatically as a DefaultCommand
<br>They can be stopped via a few methods<br>
<br>When the command returns true from it's isFinished() method
<br>When launched by a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>, and the run condition is no longer met
<br>Calling a command's .cancel() method directly
<br>When the command is cancelled by a new command that claims a required subsystem.
<br><br>It's often the case that a subsystem will have a clear, preferred action when nothing else is going on. In some cases, it's stopping a spinning roller, intake, or shooter. In others it's retracting an intake. Maybe you want your lights to do a nice idle pattern. Maybe you want your chassis joystick to just start when the robot does.<br>Default commands are ideal for this. Default commands run just like normal commands, but are automatically re-started once nothing else requires the associated subsystem resource.<br>Just like normal command, they're automatically stopped when the robot is disable, and cancelled when something else requires it.<br>
Unlike normal commands, it's not allowed to have the command return true from isFinished(). The scheduler expects default commands to run until they're cancelled. <br>Also unlike other commands, a subsystem must require the associated subsystem, and cannot require other subsystems. <br>Command groups + default commands
It's worth making a note that a Default Command cannot start during a Command Group that contains a command requiring the subsystem! If you're planning complex command sequences like an auto, make sure they don't rely on DefaultCommands as part of their operation.
<br><br>As you're writing new subsystems, make sure you consider whether you should require a subsystem. <br>You'll always want to require subsystems that you will modify, or otherwise need exclusive access to. This commonly involves commands that direct a motor, change settings, or something of that sort. <br>In some cases, you'll have a subsystem that only reads from a subsystem. Maybe you have an LED subsystem, and want to change lights according to an Elevator subsystems's height.<br>
One way to do this is have a command that requires the LEDs (needs to change the lights), but does not require the Elevator (it's just reading the encoder).<br>As a general rule, most commands you write will simply require exactly one subsystem. Commands that need to require multiple subsystems can come up, but typically this is handled by command composition and command groups.<br><br>Every new project will have an example command in a dedicated file, which should look familiar<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){
		//Runs once when the command is created as the robot boots up.
		//Register required subsystems, if appropriate
		//addRequirements(subsystem1, subsystem2...);
	}
	public void initialize(){
		//Runs once when the command is started/scheduled
	}
	public void execute(){
		//Runs every code loop
	}
	public boolean isFinished(){
		//Returns true if the command considers it's task done, and should exit
		return false;
	}
	public void end(boolean cancelled){
		//Perform cleanup; Can do different things if it's cancelled
	}
}
<br>This form of command is mostly good for instructional purposes while you're getting started. <br>On more complex robot projects, trying to use the file-based Commands forces a lot of mess in your Subsystems; In order for these to work, you need to make many of your Subsystem details public, often requiring you to make a bunch of extra functions to support them. <br><br>Command factories are the optimal way to manage your commands. With this convention, you don't create a separate  Command files, but create methods in your <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> that build and return new Command objects. This convention is commonly called a "Factory" pattern.<br>
Here's a short example and reference layout:<br>//In your subsystem
Roller extends SubsystemBase{
	Roller(){}

	public Command spinForward(){
		return Commands.run(()-&gt;{
			System.out.println("Spin Forward!!");
		},this);
	}
}
<br>//In your robotContainer.java, let's create a copy of that command
RobotContainer{
	RobotContainer(){
		joystick.a().whileTrue(roller.spinForward());
	}
}

<br>That's it! Not a lot of code, but gives you a flexible base to start with.<br>This example uses Commands.run() one of the many options in the <a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" target="_blank">Commands Class</a>. These command shortcuts let you provide <a data-href="Lambdas" href="https://stormbots.github.io/KnowledgeBase/misc/lambdas.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas</a> representing some combination of a Command's normal Initialize, Execute, isFinished, or End functions. A couple notable examples are<br>
<br>Commands.run : Takes a single lambda for the Execute blocks
<br>Commands.startRun : Takes two lambdas for the Initialize and Execute blocks
<br>Commands.startEnd : Takes two lambdas for the Initialize and End Blocks
<br>Most commands you'll write can be written like this, making for simple and concise subsystems. <br>Watch the Requires
Many Commands helpers require you to provide the required subsystem after the lambdas. If you forget, you can end up with multiple commands fighting to modify the current subsystem
<br>Building on the above, Subsystems have several of these command helpers build in! You can see this.startRun(...), this.run(..) etc; These commands work the same as the Commands. versions, but automatically require the current subsystem.<br>There's a notable special case in new FunctionalCommand(...), which takes 4 lambdas for a full command, perfectly suitable for those odd use cases.<br><br>The real power of commands comes from the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" target="_blank">Command Compositions</a> , and "decorator" functions. These functions enable a lot of power, allowing you to change how/when commands run, and pairing them with other commands for complex sequencing and autos. <br>For now, let's focus on the two that are more immediately useful: <br>
<br>command.withTimeout(time) , which runs a command for a set duration. 
<br>command.until(()-&gt;someCondition) , which allows you to exit a command on things like sensor inputs. 
<br>Commands also has some helpful commands for hooking multiple commands together as well. The most useful is a simple sequence.<br>Commands.sequence(
	roller.spinForward().withTimeout(0.1),
	roller.spinBackward().withTimeout(0.1),
	roller.spinForward().withTimeout(0.5)
)
<br>For  simple sequencing you can also use the command.andThen(otherCommand) decorator.<br>One of the most powerful is the Parallel compositor. This allows you to drive multiple subsystems at once. This example would spin rollers, move an elevator, and set your lighting color simultaneous.<br>Commands.parallel(
	roller.spinForward(),
	elevator.setHeight(27),
	leds.setColor(Color.Red)
).until(elevator.isAtSetpoint())
<br>There's multiple variants of this, which allow various "exit conditions" for existing commands, but a simple parallel with an explicit exit condition tends to be the easiest.<br><br>For this example, let's assume we have a shooter, consisting of <br>
<br>A Pivot to control aiming
<br>Flywheels, which handle the shooting RPM
<br>a Feeder that can push a held game piece into the flywheels<br>
Mechanically, our sequence should then be 
<br>Spin up our shooter and aim
<br>Once we're spun up, feed the game piece into the shooter
<br>Spin down and put our shooter back at a rest position
<br>RobotContainer{
	//Pretend these all work as expected!
	Pivot pivot = new Pivot();
	Flywheel flywheel = new Flywheel();
	Feeder feeder = new Feeder();
	
	CommandJoystick joystick = new CommandJoystick(/*...*/)
	
	RobotContainer(){	
		joystick.a().whileTrueOnce(
			/* The command sequence is shown below for clarity */
		);
	}
	
}
<br>// This would go in the spot indicated above
Commands.sequence()
	//Spin up and wait til we're ready
	Commands.parallel(
		flywheel.setShootRPM(),
		pivot.setShootingAngle()
	)
	.until(
		pivot.isAtShootingPosition())
		.and( flywheels.isAtShootingRPM() 
	),

	//Keep the shooter+pivot running, and feed it a game piece
	Commands.parallel(
		flywheel.setShootRPM(),
		pivot.setShootingAngle(),
		feeder.feedGamepieceIntoFlywheels()
	).withTimeout(1),

	//Set everything down. 
	Commands.parallel(
		flywheel.stop(),
		pivot.setAngleToResting(),
		feeder.stop()
	).pivot.isAtShootingPosition()
)
<br>These kinds of commands are very powerful, but can get unweildy.<br>
When building complex sequences, consider using a <a data-tooltip-position="top" aria-label="Code Patterns > Factory Pattern" data-href="Code Patterns#Factory Pattern" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html#Factory_Pattern" class="internal-link" target="_self" rel="noopener nofollow">Factory Pattern</a> to name and parameterize smaller, reusable snippets.<br><br>WPILib's docs document a few useful commands, but the full rundown is here: <br>The ones are the "newer" formats; These are subsystem methods (and factories, so you won't see new when using them), and automatically include the subsystem for you.<br>
<a rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" target="_blank">https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html</a><br>These ones are the older style;  They do the same things with different names, and don't include commands. In general, we'll avoid using these, but it's good to know about them for occasional corner cases.<br>
<a rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html" target="_blank">https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html</a><br><br>Now that you have some command knowledge, there's a few things to keep in mind to make using commands seamless and consistent.<br><br>When interacting with subsystems, we mostly only care about the actual commands.<br>As a result, avoid getting caught in the trap of writing "functions" and then pulling those into commands, like this: <br>public exampleSubsystem extends SubsystemBase{
	public void runMotor(double power){ motor.set(power); }
	public Command runMotorCommand(){
		return run(this::runMotor);
	}
}
<br>Doing generates more code, uses up good names, and can generate confusion about which one you want. It can also lead you to complicate the Function to do things that a Command is better at.<br>Instead, just go straight into building out command factories. <br>public exampleSubsystem extends SubsystemBase{
	public Command runMotor(double power){
		return run(()-&gt;motor.set(power) );
	}
}
<br><br>Most subsystems will have a "Default Command" that handles the passive behavior, so it's not necessary for each individual command to deal with exit conditions. This greatly simplifies writing other commands, since they all get an implied stop() or holdPosition() when you're done! Your DefaultCommand is great as a "self care" operation when nothing else is going on.<br>There are exceptions though, and some commands might have multiple preferred "defaults" based on things like "are we holding a game piece". In such cases, your defaultCommand might have some additional logic, often using ConditionalCommands, SelectCommand, and the .repeatedly() decorator .<br><br>When making your basic, simple commands, do not attach exit conditions. Doing so will significantly complicate typical usage. <br>As an example, let's say your intake.setAngle(...) command extends an intake arm, then exits when reaching the target angle. Now, you put that into a button for your drivers. Well, it extends, then exits. This either leaves it in "uncommanded" (retaining the last provided motor value and likely just going downward), or lets the defaultCommand run (which probably pulls the intake back in!). What you want to happen is to actually maintain the command until the driver releases the button or you intake a game piece. But.... it's unfortunately challenging to cancel the original exit behavior. It's easy to cut a process short; But much harder to make it go longer.<br>Instead, make base commands run forever, and create <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> or Boolean functions that checks for common exit conditions  such as isAtSetpoint(); When you use your command, just use .until(system::isAtSetpoint) if appropriate.<br>Later, once you start making more complicated sequences, some of them might have no reasonable case where you'd want that sequence to exit; Such as "getGamePieceFromGroundAndRetractBackIntoRobot()" . This (verbosely named) hypothetical obviously doesn't need to keep going .<br><br>Often, you want to start with simple Commands that do simple things. A roller system might need an intake(), stop(), eject() , which just run forever, setting a motor speed. Arms might just have a setAngle() that PIDs to an angle. <br>These are easy to test, and easy to work with in bigger, more complex sequences.<br><br>Putting it all together, let's take two subsystems: a roller attached to an arm, together working as an intake. Then fill in some simple commands.<br>public ExampleIntake extends SubsystemBase{
	//motor created here
	ExampleIntake(){ //constructor
		//configure motor here
		setDefaultCommand(defaultCommand());
	}
	public Command intake(){
		return run(()-&gt;motor.run(.5) );
	}
	public Command stop(){
		return run(()-&gt;motor.run(0) );
	}
	public boolean isGamepieceLoaded(){
		return sensor.read()==false;
	}
	public Command defaultCommand(){
		return either(
			()-&gt;motor.run(.1),
			this::stop,
			this::isGamepieceLoaded
		);
	}
}
<br>public ExampleArm extends SubsystemBase{
	//motor created here
	ExampleArm(){//constructor
		//configure motor here
		setDefaultCommand(()-&gt;setArmAngle(90));
	}
	public boolean isAtTargetAngle(){
		return /*out of scope for now*/;
	}
	public Command setArmAngle(double angle){
		return run(()-&gt;motor.getPIDController().setReference(angle,/*...*/) );
	}
}
<br>public RobotContainer{
	//joystick and subsystem creation would go here
	RobotContainer(){
		joystick.a().whileHeld(grabGamepieceFromFloor());
	}
	public Command grabGamepieceFromFloor(){
		return new SequentialCommandGroup(
			new ParallelCommandGroup(
				intake.intake(),
				arm.setArmAngle(20)
			).until(intake::isGamepieceLoaded),
			new ParallelCommandGroup(
				intake.intake(),
				arm.setArmAngle(90)
			).until(arm::isAtTargetAngle)
		)
	}
}
<br>Here you can see all this come together: <br>
<br>We have a couple simple named commands for our rollers. 
<br>We have a more complex one that sets an arm position using a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>
<br>We have a couple boolean conditions we can check for potential system states
<br>We have a composite sequence that does a full, complete task. It uses different exit conditions, from different subsystems.
<br>And, we have a smart defaultCommand that does something different when loaded vs unloaded, so none of our other commands have to deal with it. The intake handles it for us.
Commands<br><br>Requires:<br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br>
Reading Resources:<br>
<a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a><br><br>
<br>Create an Elevator subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current height
<br>Create a setHeight function that takes a height, and returns a command that runs indefinitely to the target height
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
<br><br>Elevators are a common linear motion system in FRC, generally used to raise game pieces from the floor to a high scoring objective. <br>While mechanically straightforward, Elevators wind up generating a notable step up in code and control complexity compared to <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Roller</a> systems.<br><br>
<br>Encoder calibration
<br>Homing
<br>Soft Limits
<br>Calculating FeedForwards
<br>Calculating PIDs
<br>
<br>Recommended:<br>
<br>Motion profile
<br>Code Preperation<br>
<br>Set up your system as indicated in <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a>
<br>Tuning preperation<br>
<br>temporarily define <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> as bootup zero.
<br>calibrate encoder units to Inches: <a data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a>
<br>Verify units
<br>Define soft limits (zero and below max height)
<br>Estimate and configure a low P value. This will be used for controlled preliminary motion, and just needs to move the system and not oscillate at setpoints.
<br>plot motor output, via the motor.getAppliedOutput() method.
<br>Test setting a PID setpoint to the middle of the range; The system should go up and simply settle somewhere. Height is not important.
<br>You will need a setPower style command that allows arbitrary input.
<br>Tuning<br>
<br>Determine the approximate system kG: Set the initial PID to a value that moves the elevator upward, and add that value  to your feed-forward configuration.
<br>Now you can use easily use your manual adjustment command to add a joystick input + the rough kG to calculate a precise kS and kG, as indicated in <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a>
<br>With the FeedForward configured, almost any kP will work to get the system to setpoints. You may need to adjust your kP downward to prevent oscillation, or upward if your game piece's weight 
<br><br>This uses the streamlined WPILib <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/profiled-pidcontroller.html#combining-motion-profiling-and-pid-control-with-profiledpidcontroller" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/profiled-pidcontroller.html#combining-motion-profiling-and-pid-control-with-profiledpidcontroller" target="_blank">ProfiledPIDController</a> providing the simplest complete implementation.<br>
There's many useful methods here: <a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/controller/ProfiledPIDController.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/math/controller/ProfiledPIDController.html" target="_blank">ProfiledPIDController Method Reference</a>,<br>This is configured to use Volts for feedforward and PID gains, so be mindful!<br>Using the WPILib base classes, generally suitable for Elevators<br>
 ProfiledElevator.java<br><br>	
	//Once tuned, a profiled PID is the gold standard for most control actions
	//The primary version _should not_ exit, as it complicates composition.
	public Command setPosition(double position){
		return startRun(()-&gt;{
			//Do initial reset for PID/profile
		},
		()-&gt;{}
			//Run the profiledPID
		});
	}
	
	//This version simply adds the exit condition to the setPosition
	//This helps clean up autos and sequences.
	public Command setPositionExit(double position){
		return setPosition(position).until(isAtPosition);
	}
	


	public Command setAngle(DoubleSupplier position){
		return startRun(
		()-&gt;{
			startTimer = Timer.getFPGATimestamp();
			//Seed the initial state/setpoint with the current state
			setpoint = new TrapezoidProfile.State(
				getAngle().in(Degrees),
				motor.getEncoder().getVelocity()
			);
			//Update in the Init to prevent trigger timing misfires
			goal = new TrapezoidProfile.State(position.getAsDouble(), 0);
		},
		()-&gt;{
			//Make sure the goal is dynamically updated
			goal = new TrapezoidProfile.State(position.getAsDouble(), 0);
			//update our setpoint to be our next state
			setpoint = profile.calculate(0.02, setpoint, goal);
			var ff = feedforward.calculate(setpoint.position, setpoint.velocity);
			motor.getClosedLoopController()
			.setReference(
				setpoint.position,
				ControlType.kPosition, ClosedLoopSlot.kSlot0,
				ff, ArbFFUnits.kVoltage
			);
		}
		);
	}
	
	public Angle getAngle(){
		return Degree.of(motor.getEncoder().getPosition());
	}
	public AngularVelocity getVelocity(){
		return DegreesPerSecond.of(motor.getEncoder().getVelocity());
	}
	public TrapezoidProfile.State getState(){
		return new TrapezoidProfile.State(
		  motor.getEncoder().getPosition(),
		  motor.getEncoder().getVelocity()
		);
	}
}
SuperStructure Elevator<br><br>Requires:<br>
<a data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br>Recommends:<br>
<a data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a><br>Requires as needed:<br>
<a data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Rollers</a><br>
<a data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Elevator</a><br>
<a data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Arm</a><br><br>
<br>Create an "over the bumper" intake system
<br>Add a controller button to engage the intake process. It must retract when released
<br>The button must automatically stop and retract the intake when a game piece is retracted
<br><br>Intake complexity can range from very simple rollers that capture a game piece, to complex actuated systems intertwined with other scoring mechanisms. <br>A common "over the bumper" intake archetype is a deployed system that<br>
<br>Actuates outward past the frame perimeter
<br>Engages rollers to intake game piece
<br>Retracts with the game piece upon completion of a game piece
<br>The speed of deployment and retraction both impact cycle times, forming a critical competitive aspect of the bot. <br>The automatic detection and retraction provide cycle advantages (streamlining the driver experience), but also prevent fouls and damage due to the collisions on the deployed mechanism.<br><br>The major practical difference between intakes and other "subsystems" is their routine interaction with unknowns. Intake arms might extend into walls, intake rollers might get pressed into a loading station, and everything is approaching game pieces in a variety of speeds and states. Every FRC intake is different, but this one aspect is consistent.<br>Good mechanical design goes a long way to handling unknowns, but programming is affected too.  Programming a robust intake demands identifying and resolving ways that these interactions can go wrong, and resolving them in a way that leaves the robot in an operational state (and preferably, with a game piece). Sometimes this is resolved in code, and sometimes requires hardware or design tweaks. Intakes tend to have more physical iterations than many other parts of the robot.<br><br>For most intakes, you want a clear confirmation that the intake process is Done and a game piece is loaded. This typically means reviewing the mechanical design, and identifying what, if any, sensing methods will work reliably to identify successful intake.<br>Common approaches are<br>
<br>Break beams / Range finders like <a data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">LaserCan</a> : Since these sensors are non-contact, they provide a easy to use, and relatively safe way to interact with game pieces with little design overhead. 
<br>A backplate with a switch/button: This requires special mechanical design, but gives a simple boolean state to indicate successful loading. This typically only works with intakes that interact with a back-stop, but can be made to work with other mechanisms that can actuate a switch when objects are in a known position
<br>Current Detection: This is a common option for intakes that pull in directly into a backstop, particularly for rigid game pieces. Like other places where current detection is used, it's either trivial + very effective, or ineffective + extremely challenging, depending on the design and interactions. 
<br>Speed/Stall Detection: Like above but measuring roller speed rather than motor current. 
<br>A good understanding of <a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a> , and familiarity with our other sensors available will go a long way to making a robust intake.<br><br>When intaking objects, many things can go wrong with. Here's a quick list of considerations:<br>
<br>A game piece can be oriented wrong, jamming the intake.
<br>A game piece can be loaded from weird angles or during unexpected motions, jamming the intake
<br>A game piece can be loaded at the edge of the intake, binding against mechanical supports
<br>A game piece load can be interrupted by drivers, leaving the intake in a "default command" state  while half-loaded
<br>A game piece can be damaged, loading in incorrectly or binding
<br>A game piece can be stretched/deformed inside the bot or intake
<br>A game piece can be smaller/larger than originally expected, causing various effects
<br>The game piece can be damaged due to excess force when stalled/jammed
<br>The game piece can be damaged due to initial contact with rollers at a high speed
<br>The intake can be extended past frame perimeter, and then slam into a wall
<br>The intake can be extend past the frame perimeter into a wall. 
<br>The rollers can jam against an intake pressed against a wall
<br>The rollers+game piece can force other systems into unexpected angles due to wall/floor/loading station interactions
<br>Intakes can fling past the robot perimeter during collisions, colliding with other robots (collecting fouls or snagging wires)
<br>Murphy's law applies! If anything can go wrong, it will. When testing, you might be tempted to assume errors are a one-off, but instead record them and try to replicate errors as part of your testing routine. It's easier to fix at home than it is in the middle of a competition. <br>When coding, pay close attention to <br>
<br>Expected mechanism currents: Make sure that your intake is operating with reasonable current limits, and set high enough to work quickly, but low enough to prevent harm when something goes wrong.
<br>Intake Default Commands: Ideally, the code for your intake should ensure the system ends up in a stable, safe resting location.
<br>The expected and actual positions: In some cases, if there's a large mismatch between expected positions and the current one, you might infer there's a wall/object in the way and halt loading, or apply a different routine.
<br>Command conditions: Make sure that your start/stop conditions work reliably under a variety of conditions, and not just the "values when testing". You might need to increase them or add additional states in which sensor values are handled differently or ignored.
<br><br>A good intake doesn't need to perfectly load a game piece in every scenario, but it does need to have a way to recover so you can resume the match. Let's look at a couple approaches<br><br>The optimal result, of course, is successfully resolving the fault and loading the game piece. Several fault conditions can be resolved through a more complex routine. A couple common ones are <br>
<br>Stop + restart the intake (with motor coast mode). This works surprisingly well, as it lets the game piece settle, slip away from obstructions, and then another intake attempt might successfully complete the load operation.
<br>Reverse + restart the intake. A more complex (and finicky) option, but with the same effect. This an help alleviate many types of jamming, stretching, squishing, and errant game piece modes, as well as re-seat intake wheels.
<br>Re-orient + restart: This can come up if there's mechanical quirks, such as known collision or positional errors that can result in binding (like snagging on a bumper). Moving your system a bit might fix this, allowing a successful intake
<br>A good load routine might need support from your mechanical teams to fix some edge cases. Get them involved!<br><br>If we can't fix it, let's not break it: This is a fault mitigation tactic, intended to preserve game piece and robot safety, and allow the robot to continue a match.<br>The most important part of this is to facilitate the drivers: They need an Eject button, that when held tries to clear a game piece from the system, putting it outside the frame perimeter. A good eject button might be a simple "roller goes backwards", but also might have more complex logic (positioning a system a specific way first) or even controlling other subsystems (such as feeders, indexers, or shooters). <br>Historically, a good Eject button solves a huge amount of problems, with drivers quickly identifying various error cases, and resolving with a quick tap. Often drivers can tap eject to implement "load it anyway" solution, helping prove it on the field before it's programmed as a real solution.<br><br>The big oof 💀. When this happens, your robot is basically out of commission on the field, or your drivers are  slamming it against a wall to knock things loose.<br>In this case, you should be aiming to identify, replicate, and resolve the root cause. It's very likely that this requires mechanical teams to assist. <br>If the jam is not able to be mechanically prevented, then Programming's job is to resolve the intake process to make it impossible, or at least convert it to a temporary stall. <br><br>Within the vast possibility space of the intake you'll handle, there's a few good practices<br>
<br>Test early, test often, capture a lot of errors:
<br>Revise the hardware, then revise the software: 
<br>Closed loop: Several fault conditions can be avoided by using a velocity PID and feed-forwards to generate a slower, more consistent initial interaction with game pieces, and automatically apply more power in fault condition.
<br>Operate with l
SuperStructure Intake<br>Requires:<br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a velocity FF for a roller system that enables you to set the output in RPM
<br>Create a gravity FF for a elevator system that holds the system in place without resisting external movement
<br>Create a gravity FF for an arm system that holds the system in place without resisting external movement
<br><br>Feedforwards model an expected motor output for a  system to hit specific target values.<br>
The easiest example is a motor roller. Let's say you want to run at ~3000 RPM. You know your motor has a top speed of ~6000 RPM at 100% output, so you'd correctly expect that driving the motor at 50% would get about 3000 RPM. This simple correlation is the essence of a feed-forward. The details are specific to the system at play. <br><br>The WPILib docs have good fundamentals on feedforwards that is worth reading.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br><br>Feed-forwards are specifically tuned to the system you're trying to operate, but helpfully fall into a few simple terms, and straightforward calculations. In many cases, the addition of one or two terms can be sufficient to improve and simplify control. <br><br>The simplest feedforward you'll encounter is the "static feed-forward". This term represents initial momentum, friction, and certain motor dynamics. <br>You can see this in systems by simply trying to move very slow. You'll often notice that the output doesn't move it until you hit a certain threshhold. That threshhold is approximately equal to kS.<br>The static feed-forward affects output according to the simple equation of  <br><br>a kG value effectively represents the value needed for a system to negate gravity. <br>Elevators are the simpler case: You can generally imagine that since an elevator has a constant weight, it should take a constant amount of force to hold it up. This means the elevator Gravity gain is simply a constant value, affecting the output as  ; You don't need any other considerations regarding the system motion, because gravity is always constant. <br>A more complex kG calculation is needed for pivot or arm system. You can get a good sense of this by grabbing a heavy book, and holding it at your side with your arm down. Then, rotate your arm outward, fully horizontal. Then, rotate your arm all the way upward. You'll probably notice that the book is much harder to hold steady when it's horizontal than up or down.<br>The same is true for these systems, where the force needed to counter gravity changes based on the angle of the system. To be precise, it's maximum at horizontal, zero when directly above or below the pivot. Mathematically, it follows the function  ratio, lending this version of the feed-forward the nickname kCos.<br>This form of the gravity constant affects the output according to<br>
, where  is is the maximum output, at horizontal. <a data-footref="kcos" href="https://stormbots.github.io/KnowledgeBase/about:blank#fn-1-488dae701d7b73ab" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> <br><br>The velocity feed-forward represents the expected output to maintain a target velocity. This term accounts for physical effects like dynamic friction and air resistance, and a handful of  <br>This is most easily visualized on systems with a velocity goal state. In that case,  is easily known, and contributes to the output as  .<br>In contrast, for positional control systems, knowing the desired system velocity is quite a challenge. In general, you won't know the target velocity unless you're using a <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to to generate the instantaneous velocity target. <br><br>The acceleration feed-forward largely negates a few inertial effects. It simply provides a boost to output to achieve the target velocity quicker.<br>like ,  is typically only known when you're working with <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>. <br><br>Putting this all together, it's helpful to de-mystify the math happening behind the scenes.<br>The short form is just a re-clarification of the terms and their units<br>
: Output to overcome gravity ()<br>
: Output to overcome static friction ()<br>
: Output per unit of target velocity ()<br>
: Output per unit of target acceleration ()<br>A roller system will often simply be<br>
If you don't have a motion profile, kA will simply be zero, and and kS might also be negligible unless you plan to operate at very low RPM.<br>An elevator system will look similar:<br>
Without a motion profile, you cannot properly utilize kV and kA, which simplifies down to<br>
where  is generally derived by  (since you know the current and previous positions).<br>Lastly, elevator systems differ only by the cosine term to scale kG.<br>
Again simplifying for systems with no motion profile, you get<br>
It's helpful to recognize that because the angle is being fed to a  function, you cannot use degrees here! Make sure to convert. <br>Of course, the intent of a feed-forward is to model your mechanics to improve control. As your system increases in complexity, and demands for precision increase, optimal control might require additional complexity! A few common cases: <br>
<br>If you have a pivot arm that extends, your kG won't be constant! 
<br>Moving an empty system and one loaded with heavy objects might require different feed-forward models entirely.
<br>Long arms might be impacted by motion of systems they're mounted on, like elevators or the chassis itself! You can add that in and apply corrective forces right away.
<br><br>Since a feed-forward is prediction about how your system behaves, it works very well for fast, responsive control. However, it's not perfect; If something goes wrong, your feed-forward simply doesn't know about it, because it's not measuring what actually happens. <br>In contrast, feed-back controllers like a  <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> are designed to act on the error between a system's current state and target state, and make corrective actions based on the error. Without first encountering system error, it doesn't do anything.<br>The combination of a feed-forward along with a feed-back system is the power combo that provides robust, predictable motion.<br><br>WPILib has several classes that streamline the underlying math for common systems, although knowing the math still comes in handy! The docs explain them (and associated warnings) well.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/controllers/feedforward.html</a><br>Integrating in a robot project is as simple as crunching the numbers for your feed-forward and adding it to your motor value that you write every loop.<br>ExampleSystem extends SubsystemBase(){

	SparkMax motor = new SparkMax(...)
	// Declare our FF terms and our object to help us compute things.
	double kS = 0.0;
	double kG = 0.0;
	double kV = 0.0;
	double kA = 0.0;
	ElevatorFeedforward feedforward = new ElevatorFeedforward(kS, kG, kV, kA);
	
	ExampleSubsystem(){}

	Command moveManual(double percentOutput){
		return run(()-&gt;{
			var output ;
			//We don't have a motion profile or other velocity control
			//Therefore, we can only assert that the velocity and accel are zero
			output = percentOutput+feedforward.calculate(0,0);
			// If we check the math, this feedforward.calculate() thus 
			// evaluates as simply kg;
			
			// We can improve this by instead manually calculating a bit
			// since we known the direction we want to move in
			output = percentOutput + Math.signOf(percentOutput) + kG;
			motor.set(output);
		})
	}

	Command movePID(double targetPosition){
		return run(()-&gt;{
			//Same notes as moveManual's calculations 
			var feedforwardOutput = feedforward.calculate(0,0);
			// When using the Spark closed loop control, 
			// we can pass the feed-forward directly to the onboard PID
			motor
			.getClosedLoopController()
			.setReference(
				targetPosition,
				ControlType.kPosition,
				ClosedLoopSlot.kSlot0,
				feedforwardOutput, 
				ArbFFUnits.kPercentOut
			);
			//Note, the ArbFFUnits should match the units you calculated!
		})
	}

	Command moveProfiled(double targetPosition){
		// This is the only instance where we know all parameters to make 
		// full use of a feedforward.
		// Check [[Motion Profiles]] for further reading
	}
	
}
<br>2026 update?
Rev released a new FeedForward config API that might allow advanced feed-forwards to be run directly on controller. Look into it and add examples!<br>
<a rel="noopener nofollow" class="external-link" href="https://codedocs.revrobotics.com/java/com/revrobotics/spark/config/feedforwardconfig" target="_blank">https://codedocs.revrobotics.com/java/com/revrobotics/spark/config/feedforwardconfig</a>
<br><br>High gains
When tuning feed-forwards, it's helpful to recognize that values being too high will result in notable problems, but gains being too low generally result in lower performance.<br>
Just remember that the lowest possible value is 0; Which is equivalent to not using that feed forward in the first place. Can only improve from there. 
<br>FeedForward Units
It's worth clarifying that the "units" of feedForward are usually provided in "volts", rather than "percent output". This allows FeedForwards to operate reliably in spite of changes of supply voltage, which can vary from 13 volts on a fresh battery to ~10 volts at the end of a match.<br>
Percent output on the other hand is just how much of the available voltage to output; This makes it suboptimal for controlled calculations in this case. 
<br><br>These two terms are defined at the boundary between "moving" and "not moving", and thus are closely intertwined. Or, in other words, they interfere with finding the other. So it's best to find them both at once.<br>It's easiest to find these with manual input, with your controller input scaled down to give you the most possible control.<br>Start by positioning your system so you have room to move both up and down. Then, hold the system perfectly steady, and increase output until it just barely moves upward. Record that value.<br>
Hold the system stable again, and then decrease output until it just barely starts moving down. Again, record the value. <br>Thinking back to what each term represents, if a system starts moving up, then the provided input must be equal to ; You've negated both gravity and the friction holding it in place. Similarly, to start moving down, you need to be applying . This insight means you can generate the following two equations  <br><br>Helpfully, for systems where  like roller systems, several terms cancel out and you just get  .<br>For pivot/arm systems, this routine works as described if you can calculate kG at approximately horizontal. It cannot work if the pivot is vertical. If your system cannot be held horizontal, you may need to be creative, or do a bit of trig to account for your recorded  being decreased by <br>Importantly, this routine actually returns a kS that's often slightly too high, resulting in undesired oscillation. That's because we recorded a minimum that causes motion, rather than the maximum value that doesn't cause motion. Simply put, it's easier to find this way. So, we can just compensate by reducing the calculated kS slightly; Usually multiplying it by 0.9 works great. <br><br>Because this type of system system is also relatively linear and simple, finding it is pretty simple. We know that , and expect . <br>We know  is going to be constrained by our motor's maximum RPM, and that maxOutput is defined by our api units (either +/-1.0 for "percentage" or +/-12 for "volt output"). <br>This means we can quickly assert that  should be pretty close to . <br><br>Beyond roller kV, kA and kV values are tricky to identify with simple routines, and require <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a> to take advantage of. As such, they're somewhat beyond the scope of this article.<br>The optimal option is using <a data-href="System Identification" href="https://stormbots.github.io/KnowledgeBase/level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a> to calculate the system response to inputs over time. This can provide optimal, easily repeatable results. However, it involves a lot of setup, and potentially hazardous to your robot when done without caution.<br>The other option is to tune by hand; This is not especially challenging, and mostly involves a process of moving between goal states, watching graphs, and twiddling numbers. It usually looks like this:<br>
<br>Identify two setpoints, away from hard stops but with sufficient range of motion you can hit target velocities. 
<br>While cycling between setpoints, ihen increase kV until the system generates velocities that match the target velocities. They'll generally lag behind during the accelleration phase. 
<br>Then, increase kA until the accelleration shifts and the system perfectly tracks your profile. 
<br>Increase profile constraints and and repeat until system performance is attained. Starting small and slow prevents damage to the mechanics of your system.
<br>This process benefits from a relatively low P gain, which helps keep the system stable. Once your system is tuned, you'll probably want a relatively high P gain, now that you can assert the feed-forward is keeping your error close to zero. <br><br>
<br>
<br>Note, you might observe that the kCos output,   is reading the current system state, and say "hey!  That's a feed back system, not a feed forward!" and you are technically correct; the best kind of correct. However, kCos is often implemented this way, as it's much more stable than the feed-forward version. In that version, you apply , regardless of what  happens to actually be. Feel free to do a thought experiment on how this might present problems in real-world systems.<a href="https://stormbots.github.io/KnowledgeBase/about:blank#fnref-1-488dae701d7b73ab" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
FeedForwards<br><br>Requires:<br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>Recommends:<br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create a Roller serving as a simple intake
<br>Create Commands for loading, ejecting, and stopping
<br>Create a default command that stops the subsystem
<br>Bind the load and eject operations to a joystick
<br>Optional Bonus criteria: <br>
<br>Configure the Roller to use RPM instead of setPower
<br>Add a FeedForward and basic PID
<br>Confirm the intake roughly maintains the target RPM when intaking/ejecting
<br><br>A Roller system is a simple actuator type: A single motor output mechanically connected to a rotating shaft. Objects contacting the shaft forms the useful motion of a Roller system. This can also extended with additional shafts, belts, or gearing to adjust the contact range.<br>Despite the simplicity, Rollers are very flexible and useful systems in FRC. When paired with clever mechanical design, Rollers can accomplish a wide variety of game tasks, empower other system types, and serve as the foundation of more complex systems.<br><br>On their own, rollers can be designed to serve a few functions <br>
<br>Fixed position <a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intakes</a>, responsible for pulling objects into a robot
<br>Simple scoring mechanisms for ejecting a game piece from the bot
<br>Simple launchers game pieces from the robot at higher speeds
<br>As motion systems to move game pieces through the bot
<br>As a simple feeder system for allowing or blocking game piece motion within the bot.
<br>Rollers of this nature are very common on Kitbot designs, owing to the mechanical simplicity and robustness of these systems. <br>For more complex bots, Roller systems are usually modified with extra mechanical features or actuated. These include<br>
<br>A <a data-tooltip-position="top" aria-label="SuperStructure Flywheel" data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">Flywheel</a> system, which provides more accurate launching of game pieces through precision control and increased momentum
<br>As <a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexers/Feeder/Passthrough</a>, providing precision control of game pieces through a bot.
<br>As actuated <a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intakes</a>, often with rollers attached to <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> or linkages<br>
These documents discuss the special considerations for improving Rollers in those applications.
<br><br><br>In keeping with a Roller being a simple system, they're simple to implement: You've already done this with <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>.<br>To integrate a Roller system into your bot code, there's simply a few additional considerations:<br>
<br>The function of your roller: This determines the role and name of your system. Like all subsystems, you want the name to be reflective of it's task, and unique to help clarify discussion around the system. 
<br>Level of control needed: Rollers often start simple and grow in complexity, which is generally preferred. But, sometimes you can tell that your system will get complicated, and it's worth planning for. 
<br>The base tasks this system performs. 
<br>sometimes a Roller system will serve multiple roles: Usually, it's good to recognize this early to facilitate naming and configuration.
<br>These are effectively what we see in <a data-href="Robot Design Analysis" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-design-analysis.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Design Analysis</a> , but especially pertinent for Roller systems. Since your system will likely have multiple rollers, naming them "Rollers" is probably a bad idea. Assigning good names to the roller system and the actions it performs will make your code easier to follow.<br>Rollers generally will have a few simple actions, mostly setting a power and direction, with appropriate names depending on the intent of the action:<br>
<br>Intake rollers usually have "intake", "eject", and "stop" which apply a fixed motor power. Larger game pieces might also have a "hold", which applies a lower power to keep things from shifting or falling out.
<br>Rollers in a Launcher role will usually have "shoot" and "stop", and rarely need to do much else.  
<br>Rollers serving as a "feeder" will usually alternate between the "launcher" and "intake" roles; So it'll need appropriate actions for both.
<br><br>Appropriately, a useful, minimal roller system is very straightforward, and done previously in <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>. But this time let's clean up names.<br>public Launcher extends SubsystemBase{
	SparkMax motor = new SparkMax(42,kBrushless);

	Launcher(){
		//Normal constructor tasks
		//Configure motor: See Motor Control for example code
		//Set the default command; In this case, just power down the roller
		setDefaultCommand(setPower(0)); //By default, stop
	}
	public Command setPower(double power){
		// Note use of a command that requires the subsystem by default
		// and does not exit
		return run(()-&gt;motor.set(power));
	}
	public Command launchNear(){
		return setPower(0.5);
	}
	public Command launchFar(){
		return setPower(1);
	}
}
<br>For most Roller systems, you'll want to keep a similar style of code structure: By having a setPower(...) command <a data-tooltip-position="top" aria-label="Code Patterns" data-href="Code Patterns" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html" class="internal-link" target="_self" rel="noopener nofollow">Factory</a>, you can quickly build out your other verbs with minimal hassle. This also allows easier testing, in case you have to do something like attach a <a data-tooltip-position="top" aria-label="Joysticks" data-href="Joysticks" href="https://stormbots.github.io/KnowledgeBase/misc/joysticks.html" class="internal-link" target="_self" rel="noopener nofollow">Joystick</a> to figure out the exact right power for a particular task. <br>In general, representing actions using named command factories with no arguments is preferable, and will provide the cleanest code base.  The alternatives such as making programmers remember the right number, or feeding constants into setPower will result in much more syntax and likelyhood of errors.<br>Having dedicated command factories also provides a cleaner step into modifying logic for certain actions. Sometimes later you'll need to convert a simple task into a short sequence, and this convention allows that to be done easily.<br><br>Without straying too far from a "simple" subsystem, there's still a bit we can do to resolve problems, prevent damage, or streamline our code.<br><br>Sometimes with Roller systems, you'll notice that the power needed to move a game piece often provides undesirable effects when initially contacting a game piece. Or, that sometimes a game piece loads wrong, jams, and the normal power setting won't move it.<br>This is a classic case where error correcting methods like <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>s shine! By switching your roller from a "set power" configuration to a "set rotational speed" one, you can have your rollers run at a consistent speed, adjusting the power necessary to keep things moving. <br>Notably though, PIDs for rollers are very annoying to dial in, owing to the fact that they behave very differently when loaded and unloaded, and even more so when they need to actually resolve an error condition like a jam!<br>
The use of a <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> aids this significantly: Feedforward values for rollers are extremely easy to calculate, and can model the roller in an unloaded, normal state. This allows you to operate "unloaded", with nearly zero error. When operating with very low error, your PID will be much easier to deal with, and much more forgiving to larger values.<br>You can then tune the P gain of your PID such that your system behaves as expected when loaded with your game piece. If the FF+P alone won't resolve a jamming issue, but more power will, you can add an I gain until that helps push things through.<br><br>Some Roller actions can be improved through the use of <a data-tooltip-position="top" aria-label="Sensing Basics" data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensors</a>, which generally detect the game piece directly. This helps rollers know when they can stop and end sequences, or select one of two actions to perform. <br>However, it is possible (although sometimes a bit tricky) to read the motor controller's built in sensors: Often the Current draw and encoder velocity. When attempting this, it's recommended to use <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> with a Debounce operation, which provides a much cleaner signal than directly reading these <br>You can also read the controller position too! Sometimes this requires a physical reference (effectively <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> a game piece), which allows you to assert the precise game piece location in the bot.<br>
In other cases you can make assertions solely from relative motion: Such as asserting if the roller rotated 5 times, it's no longer physically possible to still be holding a game piece, so it's successfully ejected.<br><br>Many Roller systems, particularly intakes will wind up with in one of two states: Loaded or Unloaded, with each requiring a separate conditional action.<br>The defaultCommand of a Roller system is a great place to use this, using the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> utility ConditionalCommand (akaeither ). A common case is to apply a "hold" operation when a game piece is loaded, but stop rollers if not.  <br>Implemented this way, you can usually avoid more complex <a data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a>, and streamline a great deal of code within other sequences interacting with your roller.<br><br>Some Roller systems will pull objects in, where the object hits a hard stop. This is most common on intakes. In all cases, you want to constrain the power such that nothing gets damaged when the roller pulls a game piece in and stalls.<br>Beyond that, in some cases you can set the current very low, and replace explicit hold() actions and sensors with just this lower output current. You simply run the intake normally, letting the motor controller apply an appropriate output current.<br>This is not common, but can be useful to streamline some bots, especially with drivers that simply want to hold the intake button to hold a game piece.<br><br>Should jams be possible in your roller system, encoder velocity and output current can be useful references, when combined with the consideration that <br>When a "jam" occurs, you can typicaly note <br>
<br>A high commanded power
<br>A high output current
<br>A low velocity
<br>//Current detection
new Trigger(()-&gt;motor.getAppliedOutput()&gt;=.7 &amp;&amp; motor.getOutputCurrent()&gt;4).debounce(0.2);
//Speed Detection
new Trigger(()-&gt;motor.getAppliedOutput()&gt;=.7 &amp;&amp; motor.getEncoder().getVelocity()&lt;300).debounce(0.2);
<br>However, care should be taken to ensure that these do not also catch the spin up time for motors! When a motor transitions from rest to  high speed, it also generates significant current, a low speed, and high commanded output.<br>Debouncing the trigger not only helps clean up the output signal, but for many simple Roller systems, they spin up quickly enough that the debounce time can simply be set higher than the spin up duration.SuperStructure Rollers<br><br>Requires:<a data-href="Robot Code Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br>
Recommends:<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br><br>
<br>Spin a motor
<br>Configure a motor with max current
<br>Control on/off via joystick button
<br>Control speed via joystick
<br><br>Learning order
This curriculum does not require or assume solid knowledge of <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> structure; It's just about spinning motors. All code here uses existing Example structure that's default on Command Based Robot projects.<br>
However, it's recommended to learn Motor Control alongside or after <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, as we'll use them for everything afterwards anyway.
<br>Rev Lib
This documentation assumes you have the third party Rev Library installed. You can find instructions here.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html</a>
<br>Wiring and Electrical
This document also assumes correct wiring and powering of a motor controller. This should be the case if you're using a testbench. 
<br>Identifying the right motor
Most of our motors will have sticky notes with the correct ID number; However, if something doesn't seem to work, you can check it using this process using the<br>
<a data-href="Rev Hardware Client" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a><br>
<br><br><br>
<br>Plug in your computer into any available Spark controller. The one you're interested is easier.
<br>If you don't see anything useful, click "Scan For Devices" down in the bottom left
<br>You should see one (or more!) devices in the left side.
<br>Select the device that looks like your motor
<br>Click the "Blink" button, and look at your physical hardware. The light should be flickering
<br>If not, repeat this process until you find it.
<br>You can see the Device ID in the device settings, and put that in your code. 

<br><br><br>Conceptually, running a motor is really easy, with just a few lines of code! You can, in fact, run a motor with this.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	/// Other code+functions; Ignore for now.
	int motorID = 0; //This will depend on the motor you need to run
	SparkMax motor = new SparkMax(motorID,MotorType.kBrushless);

	public ExampleSubsystem(){}

	public void periodic(){
		// Will run once every robot loop
		// Motors will only run when it's enabled...
		// but will *always* run when enabled!
		motor.set(0.1);
		//Motor range is [-1 .. 1], but we want to run slow for this
	}
}
<br>The hard part is always in making it do what you want, when you want. <br><br>Most useful robots need a bit more basic setup for the configuration. This example code walks through some of the most common configurations used when making a simple motor system.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	/// Other code+functions; Ignore for now.
	int motorID = 0; //This will depend on the motor you need to run
	SparkMax motor = new SparkMax(motorID,MotorType.kBrushless);
	
	public ExampleSubsystem(){
		//First we create a configuration structure
		var config = new SparkMaxConfig();
		//This is the "passive" mode for the motor.
		// Brake has high resistance to turning
		// Coast will spin freely. 
		// Both modes have useful applications
	    config.idleMode(IdleMode.kBrake);
	    // This changes the direction a motor spins when you give
	    // it a positive "set" value. Typically, you want to make 
	    // "positive inputs" correlate to "positive outputs",
	    // such as "positive forward" or "positive upward"
	    config.inverted(false);
		// Reduce the maximum power output of the motor controller. 
		// Default is 80A, which is *A LOT* of power!.
		// 10 is often a good starting point, and you can go up from there
	    config.smartCurrentLimit(10);
	    // This controls the maximum rate the output can change. 
	    // This is in "time between 0 and full output". A low value
	    // makes a more responsive system. 
	    // However, zero puts a *lot* of mechanical and electrical 
	    // strain on your system when there's turning things on/off.
	    // Having 0.05 is generally an optimal value for starting.
	    // Check the [[Slew Rate Limiting]] article for more info!
	    config.openLoopRampRate(0.05);

		//Lastly, we apply the parameters
	    motor.configure(
	      config, 
	      ResetMode.kResetSafeParameters, 
	      PersistMode.kNoPersistParameters
	    );
	}

	public void periodic(){ }
}
<br><br><br>Config import warning!
Watch your imports when setting up Spark Configs. If you're not mindful, VSCode will pull in<br>
import com.revrobotics.servohub.ServoHub.ResetMode;<br>
instead of the desired<br>
import com.revrobotics.spark.SparkBase.ResetMode;<br>
This shows up as a error on your line for<br>
motor.config(....);
<br><br><br>The next goal is to make a motor spin when you press a button, and stop when you release it.<br>Commands
The following examples utilize the Command structure, but do not require understanding it. You can just follow along, or read <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> to figure that out. 
The minimum bit of knowledge is that 

<br>Commands are an easy way to get the robot to start/stop bits of code
<br>Commands are an easy way to attach bits of code to a controller 
<br>The syntax looks a bit weird, that's normal.

Trying to avoid the Command structure entirely is simply a lot of work, or involves a lot of really bad habits and starting points to unlearn later.
<br>We're going to work with some Example code that exists in any new project. The relevant part looks like this.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	/// Other code+functions be here
	
	public Command exampleMethodCommand() {
		return runOnce(
			() -&gt; {
			  /* one-time action goes here */
			});
	}

	
	public void periodic(){ }
}
<br>Let's fill in our subsystem with everything we need to get this moving. <br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	int motorID = 0; //This will depend on the motor you need to run
	SparkMax motor = new SparkMax(motorID,MotorType.kBrushless);
	
	public ExampleSubsystem(){
		var config = new SparkMaxConfig();
		// ! Copy all the motor config from the Practical Example above! 
		// ... omitted here for readability ... 
		motor.configure(
			config,
			ResetMode.kResetSafeParameters, 
			PersistMode.kNoPersistParameters
	    );
	}
	
	public Command exampleMethodCommand() {
		return runOnce(
			() -&gt; {
			  motor.set(0.1) // Run at 10% power
			});
	}

	public void periodic(){ }
}
<br>Without any further ado, if you deploy this code, enable the robot, and hit "B", your motor will spin! <br>CAUTION Note it will not stop spinning! Even when you disable and re-enable the robot, it will continue to spin. We never told it how to stop.<br>An important detail about smart motor controllers is that they remember the last value they were told to output, and will keep outputting it. As a general rule, we want our code to always provide a suitable output. <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> give us a good tool set to handle this, but for now let's just do things manually.<br><br>Next let's make two changes: One, we copy the existing exampleMethodCommand. We'll name the new copy stop, and have it provide an output of 0.<br>Then, we'll just rename exampleMethodCommand to spin. We should now have two commands that look like this. <br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructor stuff 
	
	public Command spin() {
		return runOnce(
			() -&gt; {
			  motor.set(0.1) // Run at 10% power
			});
	}

	public Command stop() {
		return runOnce(
			() -&gt; {
			  motor.set(0) // Run at 10% power
			});
	}

}
<br>We'll also notice that changing the function name of  exampleMethodCommand has caused a compiler error in RobotContainer! Let's take a look<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		//The line with a an error
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.exampleMethodCommand());
	}
}

<br>Here we see how our joystick is actually starting our  "spin" operation. Since we changed the name in our subsystem, let's change it here too. <br>We also need to actually run stop at some point; Controllers have a number of ways to interact with buttons, based on the <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> class. <br>We already know it runs spin when pressed (true), we just need to add something for when it's released. So, let's do that. The final code should look like<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.spin())
		.onFalse(m_exampleSubsystem.stop())
		;
	}
}
<br>If you deploy this, you should see the desired behavior: It starts when you press the button, and stops when you release it.<br>Real code flow
Just a heads up: Once we're experienced with  <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> we'll have better options for handling stopping motors and handling "default states". This works for simple stuff, but on complex robots you'll run into problems.
<br><br>So far, we have a start/stop, but only one specific speed. Let's go back to our subsystem, copy our existing function, and introduce some parameters so we can provide arbitrary outputs via a joystick. <br>Just like any normal function, we can add parameters. In this  case, we're shortcutting some technical topics and just passing a whole joystick.<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructors and other functions 
	
	public Command spinJoystick(CommandXboxController joystick) {
		return run(() -&gt; { // Note this now says run, not runOnce.
			motor.set(joystick.getLeftY());
		});
	}
}
<br>Then hop back to RobotContainer. Let's make another button sequence, but this time on A<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		//Stuff for the B button
		
		//our new button
		m_driverController.a()
		.whileTrue(m_exampleSubsystem.spinJoystick(m_driverController))
		.onFalse(m_exampleSubsystem.stop())
		;
	}
}
<br>Give this a go! Now, while you're holding A, you can control the motor speed with the left Y axis.<br>Real code: Don't pass joysticks
Long term, we'll avoid passing joysticks; This makes it very hard to keep tabs on how buttons and joysticks are assigned. However, at this stage we're bypassing <a data-tooltip-position="top" aria-label="Lambdas" data-href="Lambdas" href="https://stormbots.github.io/KnowledgeBase/misc/lambdas.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas</a> which are the technical topic needed to do this right.<br>
If you can do this with your <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> knowledge, go ahead and fix it after going through this!
<br><br><br>We've dodged a lot of "the right way" to get things moving. If you're coming back here after learning <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, we can adjust things to better represent a real robot with more solid foundations. <br><br>Knowing how commands work, you know there's a couple wrong parts here. <br>
<br>The runOnce is suboptimal; This sets the motor, exits, and makes it hard to detect when you cancel it. 
<br>We don't command the robot at all times during motion; Most of the time it's running it's left as the prior state
<br>We don't need to add an explicit stop command on our joystick; We have the end state of our commands that can help. 
<br>Putting those into place, we get<br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructor stuff 
	
	public Command spin() {
		return run(() -&gt; {
			  motor.set(0.1) // Run at 10% power
			})
			.finallyDo(()-&gt;motor.set(0))
			;
	}
}
<br>This lets us simplify our button a bit, since we now know spin() always stops the motor when we're done.<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		m_driverController.b()
		.whileTrue(m_exampleSubsystem.spin())
	}
}
<br>As before, our button now starts and stops.<br><br>Previously, we just passed the whole joystick to avoid DoubleSuppliers and Lambdas. Let's now add this properly. <br>// ExampleSubsystem.java
ExampleSubsystem extends SubsystemBase{
	// ... All the constructors and other functions 
	
	public Command spinJoystick(DoubleSupplier speed) {
		return run(() -&gt; {
			motor.set(speed.get());
		})
		.finallyDo(()-&gt;motor.set(0))
		;
	}
}
<br>Then hop back to RobotContainer, and instead of a joystick, pass the supplier function.<br>public class RobotContainer{
	// ... Bunch of stuff here ...
	private void configureBindings() {
		// ... Some stuff here ...
		
		//Stuff for the B button
		
		//our new button
		m_driverController.a()
		.whileTrue(m_exampleSubsystem.spinJoystick(m_driverController::getLeftX))

		;
	}
}
<br>There we go! We've now corrected some of our shortcuts, and have a code structure more suited for building off of.Motor Control<br><br>Requires:<br>
<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a Differential Drivetrain
<br>Configure a Command to operate the drive using joysticks
<br>??? Add rate limiting to joysticks to make the system control better 
<br>??? Add  constraints to rotation to make robot drive better
Differential Drive<br><br><br>
<br>Create a simple autonomous that drives forward and stops
<br>Create a two-step autonomous that drives forward and backward
<br>Create a four step autonomous that drives forward, runs a mock "place object" command, backs up, then turns around.
Auto DifferentialCoding Basics.canvas]]></description><link>https://stormbots.github.io/KnowledgeBase/stormbreakers-tree.html</link><guid isPermaLink="false">StormBreakers Tree.canvas</guid><pubDate>Fri, 26 Sep 2025 01:48:22 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/assets/git-graph-commit-history.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/assets/git-graph-commit-history.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Absolute Encoders]]></title><description><![CDATA[ 
 <br>Absolute encoders are sensors that measure a physical rotation directly. These differ from <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a> due to measurement range, as well as the specific data they provide.<br><br>
<br>Take testbench, define a range of motion with measurable real-world angular units.
<br>Configure an absolute encoder to report units of that range
<br>Validate that the reported range of the encoder is accurate over the fully defined range of motion.
<br>Validate the 
<br><br>If we recall how <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a> work, they tell us nothing about the system until verified against a reference. Once we have a reference and initialize the sensor, then we can track the system, and compute the system state.  <br>In contrast, absolute encoders are designed to capture the full system state all at once, at all times. When set up properly, the sensor itself is a reference.<br><br>Both sensors track the same state change (rotation), and when leveraged properly, can provide complete system state information<br><br>While the precise construction can vary, many absolute encoders tend to work in the same basic style: divide your measured distance into two regions. Then divide those two regions into two more regions each, and repeat as many times as needed to get the desired precision!<br>When you do this across a single rotation, you get a simple binary encoder shown here: <br><img alt="encoder-gray-code.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/encoder-gray-code.png"><br>With 3 subdivisions, you can divide the circle in  regions. This means at all times, you know where you are within a 45 degree region. Since each region is on/off, it's common to describe absolute encoders as "X bit" resolution; One bit per sensor region.<br>Commonly, you'll see encoders with one of the following resolutions. <br><br><br>The typical encoder we use in FRC is the <a data-tooltip-position="top" aria-label="https://docs.revrobotics.com/rev-crossover-products/sensors/tbe/application-examples" rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/rev-crossover-products/sensors/tbe/application-examples" target="_blank">Rev Through Bore Encoder</a> . This is a 10 bit encoder, and provides interfaces by either <br>
<br>Plugging it into the Spark Max
<br>Plugging it into the RoboRio's DIO port. 
<br><br>When plugged into the RoboRio, you can interface with it using the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" target="_blank">DutyCycleEncoder</a> class and associated features.<br>public class ExampleSubsystem{
	// Initializes a duty cycle encoder on DIO pins 0 
	// Configure it to to return a value of 4 for a full rotation, 
	// with the encoder reporting 0 half way through rotation (2 out of 4)
	DutyCycleEncoder encoder = new DutyCycleEncoder(0, 4.0, 2.0);
	
	//... other subsystem code will be here ...
	
	public void periodic(){
		//Read the encoder and print out the value
		System.out.println(encoder.get());
	}
}
<br>Real systems will likely use encoder ranges of  2*Math.PI (for Radians) or 360 (for degrees). <br>The "zero" value will depend on your exact system, but should be the encoder reading when your system is at a physical "zero" value. In most cases, you'd want to correlate "physical zero" with an arm horizontal, which simplifies visualizing the system, and calculations for <a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> for <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm subsystems</a> later. However, use whatever makes sense for your subsystem, as defined by your <a data-href="Robot Design Analysis" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-design-analysis.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Design Analysis</a>'s coordinate system.<br><br>When a Through Bore Encoder is connected to a Spark, it'll look very similar to connecting a <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoder</a> in terms of setting up the Spark and applying/getting config, with a few new options<br>ExampleSubsystem extends SubsystemBase{
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();

		//Configure the reported units for one full rotation.
		// The default factor is 1, measuring fractions of a rotation.
		// Generally, this will be 360 for degrees, or 2*Math.PI for radians
		var absConversionFactor=360;
		config.absoluteEncoder
		.positionConversionFactor(absConversionFactor);
		//The velocity defaults to units/minute ; Units per second tends to
		//preferable for FRC time scales.
		config.absoluteEncoder
		.velocityConversionFactor(absConversionFactor / 60.0);
		//Configure the "sensor phase"; If a positive motor output 
		//causes a decrease in sensor output, then we want to set the 
		// sensor as "inverted", and would change this to true.
		config.absoluteEncoder
		.inverted(false);

		motor.configure(
			config,
			ResetMode.kResetSafeParameters,
			PersistMode.kPersistParameters
		);
	}
	// ... other stuff
	public void periodic(){
		//And, query the encoder for position.
		var angle = motor.getAbsoluteEncoder().getPosition();
		var velocity = motor.getAbsoluteEncoder.getVelocity();
		// ... now use the values for something.
	}
}
<br><br>Remember that the intent of an absolute encoder is to capture your system state directly. But what happens when your system can exceed the encoder's ability to track it? <br>If you answered "depends on the way you track things", you're correct. By their nature absolute encoders have a "discontinuity"; Some angle at which they jump from one end of their valid range to another. Instead of [3,2,1,-1,-2] you get [3,2,1,359,358]! You can easily imagine how this messes with anything relying on those numbers.. <br>For a Through Bore + Spark configuration, by default it measures "one rotation", and the discontinuity matches the range of 0..1 rotations , or 0..360 degrees with a typical conversion factor. This convention means that it will not return negative values when read through motor.getAbsoluteEncoder().getPosition() ! <br><img alt="absolute-angle-discontinuity.svg" src="https://stormbots.github.io/KnowledgeBase/lib/media/absolute-angle-discontinuity.svg"><br>Unfortunately, this convention often puts the discontinuity directly in range of motion, meaning we have to deal with it frequently. <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> controllers especially do not like discontinuities in their normal range. <br>Ideally, we can move the discontinuity somewhere we don't cross it due to physical hardware constraints.<br>There's a few approaches you can use to resolve this, depending on exactly how your system should work, and what it's built to do!<br><br>This is the easiest and probably ideal solution for many systems. The Spark has a method that changes the system from reporting [0..1)rotations to (-0.5..0.5]. rotations. Or, with a typical conversion factor applied, (-180..180] degrees. <br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		config.absoluteEncoder.zeroCentered(true);
		// .. other stuff
		}
	}
<br>Most FRC systems won't have a range of 180 degrees, making this a very quick and easy fix. <br>PID Integration
Rev documentation makes it unclear if zeroCentered(true) works as expected with the onboard Spark PID controller.<br>
If you test this, report back so we can replace this warning with correct information. 
<br><br>Since this is common, some <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> or <a data-tooltip-position="top" aria-label="Closed Loop Controller" data-href="Closed Loop Controller" href="https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop</a> controllers can simply take the discontinuity directly in their configuration. This bypasses the need to fix it on the sensor side.<br>For Sparks, the configuration option is as follows:<br>sparkConfig.closedLoop.positionWrappingInputRange(min,max);
<br>Setpoint Wrapping in controllers 
Be mindful of how setpoints are wrapped when passed to the controller! Just because the sensor is wrapped, doesn't mean it also handles setpoint values too.<br>
If the PID is given an unreachable setpoint due to sensor wrapping, it can generate uncontrolled motion. Make sure you check and use wrapper functions for setpoints as needed.
<br><br>In some cases, you can just avoid directly calling motor.getAbsoluteEncoder().getPosition(),  and instead go through a function to handle the discontinuity. This usually looks like this<br>// In a subsystem using an absolute encoder
private double getAngleAbsolute(){
	double absoluteAngle = motor.getAbsoluteEncoder().getPosition();
	// Mote the discontinuity from 0 to -90
	if(absoluteAngle&gt;270){
		absoluteAngle-=360;
	}
	return absoluteAngle;
}
<br>This example gives us a range of -90 to 270, representing a system that could rotate anywhere but straight downward. <br>This pattern works well for code aspects that live on the Roborio, but note this doesn't handle things like the onboard Spark PID controllers! Those still live with the discontinuity, and would cause problems.<br><br>Instead of using the Absolute encoder as it's own source of angles, we simply refer to the <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoder</a>. In this case, both encoders should be configured to provide the same measured unit (radians/degrees/rotations of the system), and then you can simply read the value of the absolute, and set the state of the relative. <br>More information for this technique is provided at <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a>, alongside other considerations for transferring data between sensors like this.<br><br>Since an absolute encoder represents a physical system state, an important consideration is preserving the physical link between system state and the sensor.<br>On the Rev Through Bore, the link between system state and encoder state is maintained by the physical housing, and the white plastic ring that connects to a hex shaft.<br><img alt="Rev Through Bore Encoder.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/rev-through-bore-encoder.png"><br>You can see that the white hex ring has a small notch to help track physical alignment, as does the black housing. The notch's placement itself is unimportant; However, keeping the notch consistency aligned is very important!<br>If we take a calibrated, working system, but then re-assemble it it incorrectly, we completely skew our system's concept of what the physical system looks like. Let's take a look at an example arm.<br><img alt="absolute-sensor-rotation-error.svg" src="https://stormbots.github.io/KnowledgeBase/lib/media/absolute-sensor-rotation-error.svg"><br>We can see in this case we have a one-notch error, which is 60 degrees. This means that the system thinks the arm is pointing up, but the arm is actually still rather low. This is generally referred to as a "clocking" error.<br>When we feed an error like this into motor control tools like a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>, the discrepancy means the system will be driving the arm well outside your expected ranges! This can result in significant damage if it catches you by surprise. <br>As a result, it's worth taking the time and effort to annotate the expected alignment for the white ring and the other parts of the system. This allows you to quickly validate the system in case of rework or disassembly. <br>Ideally, build teams should be aware of the notch alignment and it's impact! While you can easily adjust offsets in code, such offsets have to ripple through all active code branches and multiple users, which can generate a to a fair amount of disruption. However, in some cases the code disruption is still easier to resolve than further disassembling and re-assembling parts of the robot. It's something that's bound to happen at some point in the season.<br><br><br><br>Grey code encoders use binary subdivision similar to the "binary encoder" indicated above, but structure their divisions and output table differently. These differences make for some useful properties:<br>
<br>Only one bit changes at a time during rotation
<br>Subdivisions are grouped in a way that reduces the rate of change on any given track
<br>If you look closely, the Quadrature signal used by <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Relative Encoders</a> is a special case of a 2 bit Grey Code! Looking for this "quadrature" pattern where each track has a 50% overlap to the change across adjacent tracks is a giveaway that an encoder is using gray code.<br><img alt="Gray-code-table-Gray-coding-to-read-position.gif" src="https://stormbots.github.io/KnowledgeBase/lib/media/gray-code-table-gray-coding-to-read-position.gif"><br><br>In certain systems, you can measure an X and a Y offset, generating a sin and cosine value. The unique sin and cos values generate a unique angle with high precision.<br><img alt="Circle_cos_sin.gif" src="https://stormbots.github.io/KnowledgeBase/lib/media/circle_cos_sin.gif"><br><br>In some cases like an Elevator you might want to track motion across a larger range than a single encoder could manage. This is most common for linear systems like <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a>. <br>By stepping an encoder down, can convert 1 rotation of travel (maybe ~1-3 inches at ~0.01" precision) into a more useful ~50 inches at ~0.5" precision! This gives you absolute knowledge of your system, but at a much lower precision.<br>However, if you were to stack a normal encoder on top, you could use each encoder within their optimal ranges: One encoder can provide a rough area, and the other can provide the precision.<br><br>This is a numerical trick that can allow use of two smaller encoders and some clever math to extend two encoders ranges out a significant distance at high precision. This would permit absolute encoders to effectively handle <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> systems or other linear travel.<br><a rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem" target="_blank">https://en.wikipedia.org/wiki/Chinese_remainder_theorem</a><br><br>
<br>Advantages
<br>Disadvantages
<br>Discontinuity handling
<br>Integration with relative encoders<br>
<a data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a>
]]></description><link>https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html</link><guid isPermaLink="false">Hardware/Absolute Encoders.md</guid><pubDate>Sat, 20 Sep 2025 23:35:40 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/encoder-gray-code.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/encoder-gray-code.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Deploying Code]]></title><description><![CDATA[ 
 ]]></description><link>https://stormbots.github.io/KnowledgeBase/level-0/deploying-code.html</link><guid isPermaLink="false">Level 0/Deploying Code.md</guid><pubDate>Sat, 20 Sep 2025 19:16:05 GMT</pubDate></item><item><title><![CDATA[Basic Telemetry]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:todo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#todo</a> 
 <br><br>Understand how to efficiently communicate to and from a robot for diagnostics and control <br><br>
<br>Print a notable event using the RioLog
<br>Find your logged event using DriverStation
<br>Plot some sensor data (such as an encoder reading), and view it on Glass/Elastic
<br>Create a subfolder containing several subsystem data points.
<br>As a telemetry task, success is thus open ended, and should just be part of your development process; The actual feature can be anything, but a few examples we've seen before are<br><br>By definition, a program runs exactly as you the code was written to run. Most notably, this does not strictly mean the code runs as it was intended to. <br>When looking at a robot, there's a bunch of factors that can have be set in ways that were not anticipated, resulting in unexpected behavior.<br>Telemetry helps you see the bot as the bot sees itself, making it much easier to bridge the gap between what it's doing and what it should  be doing. <br><br>Simply printing information to a terminal is often the easiest form of telemetry to write, but rarely the easiest one to use. Because all print operations go through the same output interface, the more information you print, the harder it is to manage.<br>This approach is best used for low-frequency information, especially if you care about quickly accessing the record over time. It's best used for marking notable changes in the system: Completion of tasks, critical events, or errors that pop up. Because of this, it's highly associated with "logging".<br>The methods to print  are attached to the particular print channels<br>//System.out is the normal output channel
System.out.println("string here"); //Print a string
System.out.println(764.3); //you can print numbers, variables, and many other objects

//There's also other methods to handle complex formatting.... 
//But we aren't too interested in these in general.
System.out.printf("Value of thing: %n \n", 12);
<br>A typical way this would be used would be something like this:<br>public ExampleSubsystem{
	boolean isAGamePieceLoaded=false;
	boolean wasAGamePieceLoadedLastCycle=false;
	
	public Command load(){
		//Some operation to load a game piece and run set the loaded state
		return runOnce(()-&gt;isAGamePieceLoaded=true);
	}
	
	public void periodic(){
		if(isAGamePieceLoaded==true &amp;&amp; wasAGamePieceLoadedLastCycle==false){
			System.out.print("Game piece now loaded!");
		}
		if(isAGamePieceLoaded==false &amp;&amp; wasAGamePieceLoadedLastCycle==true){
			System.out.print("Game piece no longer loaded");
		}
		wasAGamePieceLoadedLastCycle=isAGamePieceLoaded
	}
}
<br>Rather than spamming "GAME PIECE LOADED" 50 times a second for however long a game piece is in the bot, this pattern cleanly captures the changes when a piece is loaded or unloaded.<br>In a more typical <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command based robot</a> , you could put print statements like this in the end() operation of your command, making it even easier and cleaner. <br>The typical interface for reading print statements is the RioLog: You can access this via the Command Pallet (CTRL+Shift+P) by just typing &gt; WPILIB: Start Riolog. You may need to connect to the robot first. <br>These print statements also show up in the DriverStation logs viewer, making it easier to pair your printed events with other driver-station and match events. <br><br>Data in our other telemetry applications uses the NetworkTables interface, with the typical easy access mode being the SmartDashboard api. This uses a "key" or name for the data, along with the value. There's a couple function names for different data types you can interact with<br>// Put information into the table
SmartDashboard.putNumber("key",0); // Any numerical types like int or float
SmartDashboard.putString("key","value"); 
SmartDashboard.putBoolean("key",false);
SmartDashboard.putData("key",field2d); //Many built-in WPILIB classes have special support for publishing
<br>You can also "get" values from the dashboard, which is useful for on-robot networking with devices like <a data-tooltip-position="top" aria-label="Limelight Basics" data-href="Limelight Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight</a>, <a data-tooltip-position="top" aria-label="PhotonVision Basics" data-href="PhotonVision Basics" href="https://stormbots.github.io/KnowledgeBase/level-2/photonvision-basics.html" class="internal-link" target="_self" rel="noopener nofollow">PhotonVision</a>, or for certain remote interactions and non-volatile storage.<br>
Note, that since it's possible you could request a key that doesn't exist, all these functions require a "default" value; If the value you're looking for is missing, it'll just  give you the provided default.<br>SmartDashboard.getNumber("key",0);
SmartDashboard.getString("key","not found");
SmartDashboard.getBoolean("key",false);
<br>Networktables also supports hierarchies using the "/" seperator: This allows  you to separate things nicely, and the telemetry tools will let you interface with groups of values.<br>SmartDashboard.putNumber("SystemA/angle",0);
SmartDashboard.putNumber("SystemA/height",0);
SmartDashboard.putNumber("SystemA/distance",0);
SmartDashboard.putNumber("SystemB/angle",0);
<br>While not critical, it is also helpful to recognize that within their appropriate heirarchy, keys are displayed in alphabetical order! Naming things can thus be helpful to organizing and grouping data. <br><br>As you can imagine, with multiple people each trying to get robot diagnostics, this can get very cluttered. There's a few good ways to make good use of Glass for rapid diagnostics:<br>
<br>Group your keys using group/key . All items with the same group/ value get put into the same subfolder, and easier to track. Often subsystem names make a great group pairing, but if you're tracking something specific, making a new group can help. 
<br>Label keys with units: a  key called angle is best when written as angle degree ; This ensures you and others don't confuse it with angle rad.  
<br>Once you have your grouping and units, add more values! Especially when you have multiple values that should be the same. One of the most frequent ways for a system to go wrong is when two values differ, but shouldn't.
<br>A good case study is an arm: You would have <br>
<br>An absolute encoder angle
<br>the relative encoder angle
<br>The target angle
<br>motor output<br>
And you would likely have a lot of other systems going on. So, for the arm you would want to organize things something like this
<br>SmartDashboard.putNumber("arm/enc Abs(deg)",absEncoder.getAngle());
SmartDashboard.putNumber("arm/enc Rel(deg)",encoder.getAngle());
SmartDashboard.putNumber("arm/target(deg)",targetAngle);
SmartDashboard.putNumber("arm/output(%)",motor.getAppliedOutput());
<br>A good sanity check is  to think "if someone else were to read this, could they figure it out without digging in the code". If the answer is no, add a bit more info.<br><br>Glass is our preferred telemetry interface as programmers: It offers great flexibility, easy tracking of many potential outputs, and is relatively easy to use. <br><img alt="telemetry-glass.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/telemetry-glass.png"><br>
Glass does not natively "log" data that it handles though; This makes it great for realtime diagnostics, but is not a great logging solution for tracking data mid-match.<br>This is a great intro to how to get started with Glass:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/dashboards/glass/index.html</a><br>For the most part, you'll be interacting with the NetworkTables block, and adding visual widgets using Plot and the NetworkTables menu item.<br><br>Elastic is a telemetry interface oriented more for drivers, but can be useful for programming and other diagnostics. Elastic excels at providing a flexible UI with good at-a-glance visuals for various numbers and directions.<br><img alt="telemetry-elastic.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/telemetry-elastic.png"><br>Detailed docs are available here:<br>
<a rel="noopener nofollow" class="external-link" href="https://frc-elastic.gitbook.io/docs" target="_blank">https://frc-elastic.gitbook.io/docs</a><br>As a driver tool, it's good practice to set up your drivers with a screen according to their preferences, and then make sure to keep it uncluttered. You can go to Edit -&gt; Lock Layout to prevent unexpected changes. <br>For programming utility, open a new tab, and add widgets and items.<br><br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:todo" class="tag" target="_blank" rel="noopener nofollow">#todo</a> ]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html</link><guid isPermaLink="false">Level 1/Basic Telemetry.md</guid><pubDate>Mon, 22 Sep 2025 08:35:23 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/telemetry-glass.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/telemetry-glass.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Commands]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Robot Code Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Create a command that runs indefinitely
<br>Have that command start+end on a joystick button
<br>Create a command that starts on a joystick press, and stop it with a different button
<br>Create a default command that lets you know when it's running through <a data-tooltip-position="top" aria-label="Basic Telemetry" data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Telemetry</a>
<br>Create a runCommand using a function pointer
<br>Create a runCommand using a lambda
<br>Learning order
You can learn this without having done <a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a>, but it's often more fun to learn alongside it in order to have more interesting, visual commands while experimenting.<br>
The commands provided as an example just print little messages visible in the RioLog, allowing this to be set up without motors
<br><br>A Command is an event driven code structure that allows you manage when code runs, what resources it uses, and when it ends. <br>In the context of a robot, it allows you to easily manage a lot of the complexity involved with managing multiple <a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> <br>The code structure itself is fairly straightforward, and defines a few methods; Each method defines what code runs at what time. <br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){}
	public void initialize(){}
	public void execute(){}
	public boolean isFinished(){ return false; }
	public void end(boolean cancelled){}
}
<br>Behind the scenes, the robot runs a command scheduler, which helps manage what runs when. Once started, a command will run according to the following flowchart, more formally known as a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">state machine</a>. <br><br>This is the surface level complexity, which sets you up for how to view, read, and write commands. <br><br>A key aspect of Commands is their ability to claim temporary, exclusive  ownership over a <a data-href="Subsystem" href="https://stormbots.github.io/KnowledgeBase/Subsystem" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> .  This is done by passing the subsystem into a command, and then adding it as a requirementcontroll<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(ExampleSubsystem subsystemName){
		addRequirements(subsystemName);
	}
<br>Now, whenever the command is started, it will forcibly claim that subsystem. It'll release that claim when it runs it's end() block.<br>This ability of subsystems to hold a claim on a resource has a lot of utility. The main value is in preventing you from doing silly things like trying to tell a motor to go forward and backward at once.<br><br>Now that we've established subsystem ownership, what happens when you do try to tell your motor to go forward and then backward?<br>When you start the command, it will forcibly interrupt other commands that share a resource with it, ensuring that the new command has exclusive access. <br>It'll look like this<br><br>When a command is cancelled, the command scheduler runs the commands end(cancelled) block, passing in a value of true. Whole not typical, some commands will need to do different cleanup routines depending on whether they exited on a task completion, or if something else kicks em off a subsystem. <br><br>Commands can be started in one of 3 ways:<br>
<br>via a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>'s start condition
<br>Directly scheduling it via the command's .schedule() method.
<br>Automatically as a DefaultCommand
<br>They can be stopped via a few methods<br>
<br>When the command returns true from it's isFinished() method
<br>When launched by a <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a>, and the run condition is no longer met
<br>Calling a command's .cancel() method directly
<br>When the command is cancelled by a new command that claims a required subsystem.
<br><br>It's often the case that a subsystem will have a clear, preferred action when nothing else is going on. In some cases, it's stopping a spinning roller, intake, or shooter. In others it's retracting an intake. Maybe you want your lights to do a nice idle pattern. Maybe you want your chassis joystick to just start when the robot does.<br>Default commands are ideal for this. Default commands run just like normal commands, but are automatically re-started once nothing else requires the associated subsystem resource.<br>Just like normal command, they're automatically stopped when the robot is disable, and cancelled when something else requires it.<br>
Unlike normal commands, it's not allowed to have the command return true from isFinished(). The scheduler expects default commands to run until they're cancelled. <br>Also unlike other commands, a subsystem must require the associated subsystem, and cannot require other subsystems. <br>Command groups + default commands
It's worth making a note that a Default Command cannot start during a Command Group that contains a command requiring the subsystem! If you're planning complex command sequences like an auto, make sure they don't rely on DefaultCommands as part of their operation.
<br><br>As you're writing new subsystems, make sure you consider whether you should require a subsystem. <br>You'll always want to require subsystems that you will modify, or otherwise need exclusive access to. This commonly involves commands that direct a motor, change settings, or something of that sort. <br>In some cases, you'll have a subsystem that only reads from a subsystem. Maybe you have an LED subsystem, and want to change lights according to an Elevator subsystems's height.<br>
One way to do this is have a command that requires the LEDs (needs to change the lights), but does not require the Elevator (it's just reading the encoder).<br>As a general rule, most commands you write will simply require exactly one subsystem. Commands that need to require multiple subsystems can come up, but typically this is handled by command composition and command groups.<br><br>Every new project will have an example command in a dedicated file, which should look familiar<br>class ExampleCommand extends CommandBase{
	public ExampleCommand(){
		//Runs once when the command is created as the robot boots up.
		//Register required subsystems, if appropriate
		//addRequirements(subsystem1, subsystem2...);
	}
	public void initialize(){
		//Runs once when the command is started/scheduled
	}
	public void execute(){
		//Runs every code loop
	}
	public boolean isFinished(){
		//Returns true if the command considers it's task done, and should exit
		return false;
	}
	public void end(boolean cancelled){
		//Perform cleanup; Can do different things if it's cancelled
	}
}
<br>This form of command is mostly good for instructional purposes while you're getting started. <br>On more complex robot projects, trying to use the file-based Commands forces a lot of mess in your Subsystems; In order for these to work, you need to make many of your Subsystem details public, often requiring you to make a bunch of extra functions to support them. <br><br>Command factories are the optimal way to manage your commands. With this convention, you don't create a separate  Command files, but create methods in your <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> that build and return new Command objects. This convention is commonly called a "Factory" pattern.<br>
Here's a short example and reference layout:<br>//In your subsystem
Roller extends SubsystemBase{
	Roller(){}

	public Command spinForward(){
		return Commands.run(()-&gt;{
			System.out.println("Spin Forward!!");
		},this);
	}
}
<br>//In your robotContainer.java, let's create a copy of that command
RobotContainer{
	RobotContainer(){
		joystick.a().whileTrue(roller.spinForward());
	}
}

<br>That's it! Not a lot of code, but gives you a flexible base to start with.<br>This example uses Commands.run() one of the many options in the <a data-tooltip-position="top" aria-label="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" target="_blank">Commands Class</a>. These command shortcuts let you provide <a data-href="Lambdas" href="https://stormbots.github.io/KnowledgeBase/misc/lambdas.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas</a> representing some combination of a Command's normal Initialize, Execute, isFinished, or End functions. A couple notable examples are<br>
<br>Commands.run : Takes a single lambda for the Execute blocks
<br>Commands.startRun : Takes two lambdas for the Initialize and Execute blocks
<br>Commands.startEnd : Takes two lambdas for the Initialize and End Blocks
<br>Most commands you'll write can be written like this, making for simple and concise subsystems. <br>Watch the Requires
Many Commands helpers require you to provide the required subsystem after the lambdas. If you forget, you can end up with multiple commands fighting to modify the current subsystem
<br>Building on the above, Subsystems have several of these command helpers build in! You can see this.startRun(...), this.run(..) etc; These commands work the same as the Commands. versions, but automatically require the current subsystem.<br>There's a notable special case in new FunctionalCommand(...), which takes 4 lambdas for a full command, perfectly suitable for those odd use cases.<br><br>The real power of commands comes from the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/command-compositions.html" target="_blank">Command Compositions</a> , and "decorator" functions. These functions enable a lot of power, allowing you to change how/when commands run, and pairing them with other commands for complex sequencing and autos. <br>For now, let's focus on the two that are more immediately useful: <br>
<br>command.withTimeout(time) , which runs a command for a set duration. 
<br>command.until(()-&gt;someCondition) , which allows you to exit a command on things like sensor inputs. 
<br>Commands also has some helpful commands for hooking multiple commands together as well. The most useful is a simple sequence.<br>Commands.sequence(
	roller.spinForward().withTimeout(0.1),
	roller.spinBackward().withTimeout(0.1),
	roller.spinForward().withTimeout(0.5)
)
<br>For  simple sequencing you can also use the command.andThen(otherCommand) decorator.<br>One of the most powerful is the Parallel compositor. This allows you to drive multiple subsystems at once. This example would spin rollers, move an elevator, and set your lighting color simultaneous.<br>Commands.parallel(
	roller.spinForward(),
	elevator.setHeight(27),
	leds.setColor(Color.Red)
).until(elevator.isAtSetpoint())
<br>There's multiple variants of this, which allow various "exit conditions" for existing commands, but a simple parallel with an explicit exit condition tends to be the easiest.<br><br>For this example, let's assume we have a shooter, consisting of <br>
<br>A Pivot to control aiming
<br>Flywheels, which handle the shooting RPM
<br>a Feeder that can push a held game piece into the flywheels<br>
Mechanically, our sequence should then be 
<br>Spin up our shooter and aim
<br>Once we're spun up, feed the game piece into the shooter
<br>Spin down and put our shooter back at a rest position
<br>RobotContainer{
	//Pretend these all work as expected!
	Pivot pivot = new Pivot();
	Flywheel flywheel = new Flywheel();
	Feeder feeder = new Feeder();
	
	CommandJoystick joystick = new CommandJoystick(/*...*/)
	
	RobotContainer(){	
		joystick.a().whileTrueOnce(
			/* The command sequence is shown below for clarity */
		);
	}
	
}
<br>// This would go in the spot indicated above
Commands.sequence()
	//Spin up and wait til we're ready
	Commands.parallel(
		flywheel.setShootRPM(),
		pivot.setShootingAngle()
	)
	.until(
		pivot.isAtShootingPosition())
		.and( flywheels.isAtShootingRPM() 
	),

	//Keep the shooter+pivot running, and feed it a game piece
	Commands.parallel(
		flywheel.setShootRPM(),
		pivot.setShootingAngle(),
		feeder.feedGamepieceIntoFlywheels()
	).withTimeout(1),

	//Set everything down. 
	Commands.parallel(
		flywheel.stop(),
		pivot.setAngleToResting(),
		feeder.stop()
	).pivot.isAtShootingPosition()
)
<br>These kinds of commands are very powerful, but can get unweildy.<br>
When building complex sequences, consider using a <a data-tooltip-position="top" aria-label="Code Patterns > Factory Pattern" data-href="Code Patterns#Factory Pattern" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html#Factory_Pattern" class="internal-link" target="_self" rel="noopener nofollow">Factory Pattern</a> to name and parameterize smaller, reusable snippets.<br><br>WPILib's docs document a few useful commands, but the full rundown is here: <br>The ones are the "newer" formats; These are subsystem methods (and factories, so you won't see new when using them), and automatically include the subsystem for you.<br>
<a rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html" target="_blank">https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Commands.html</a><br>These ones are the older style;  They do the same things with different names, and don't include commands. In general, we'll avoid using these, but it's good to know about them for occasional corner cases.<br>
<a rel="noopener nofollow" class="external-link" href="https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html" target="_blank">https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj2/command/Command.html</a><br><br>Now that you have some command knowledge, there's a few things to keep in mind to make using commands seamless and consistent.<br><br>When interacting with subsystems, we mostly only care about the actual commands.<br>As a result, avoid getting caught in the trap of writing "functions" and then pulling those into commands, like this: <br>public exampleSubsystem extends SubsystemBase{
	public void runMotor(double power){ motor.set(power); }
	public Command runMotorCommand(){
		return run(this::runMotor);
	}
}
<br>Doing generates more code, uses up good names, and can generate confusion about which one you want. It can also lead you to complicate the Function to do things that a Command is better at.<br>Instead, just go straight into building out command factories. <br>public exampleSubsystem extends SubsystemBase{
	public Command runMotor(double power){
		return run(()-&gt;motor.set(power) );
	}
}
<br><br>Most subsystems will have a "Default Command" that handles the passive behavior, so it's not necessary for each individual command to deal with exit conditions. This greatly simplifies writing other commands, since they all get an implied stop() or holdPosition() when you're done! Your DefaultCommand is great as a "self care" operation when nothing else is going on.<br>There are exceptions though, and some commands might have multiple preferred "defaults" based on things like "are we holding a game piece". In such cases, your defaultCommand might have some additional logic, often using ConditionalCommands, SelectCommand, and the .repeatedly() decorator .<br><br>When making your basic, simple commands, do not attach exit conditions. Doing so will significantly complicate typical usage. <br>As an example, let's say your intake.setAngle(...) command extends an intake arm, then exits when reaching the target angle. Now, you put that into a button for your drivers. Well, it extends, then exits. This either leaves it in "uncommanded" (retaining the last provided motor value and likely just going downward), or lets the defaultCommand run (which probably pulls the intake back in!). What you want to happen is to actually maintain the command until the driver releases the button or you intake a game piece. But.... it's unfortunately challenging to cancel the original exit behavior. It's easy to cut a process short; But much harder to make it go longer.<br>Instead, make base commands run forever, and create <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> or Boolean functions that checks for common exit conditions  such as isAtSetpoint(); When you use your command, just use .until(system::isAtSetpoint) if appropriate.<br>Later, once you start making more complicated sequences, some of them might have no reasonable case where you'd want that sequence to exit; Such as "getGamePieceFromGroundAndRetractBackIntoRobot()" . This (verbosely named) hypothetical obviously doesn't need to keep going .<br><br>Often, you want to start with simple Commands that do simple things. A roller system might need an intake(), stop(), eject() , which just run forever, setting a motor speed. Arms might just have a setAngle() that PIDs to an angle. <br>These are easy to test, and easy to work with in bigger, more complex sequences.<br><br>Putting it all together, let's take two subsystems: a roller attached to an arm, together working as an intake. Then fill in some simple commands.<br>public ExampleIntake extends SubsystemBase{
	//motor created here
	ExampleIntake(){ //constructor
		//configure motor here
		setDefaultCommand(defaultCommand());
	}
	public Command intake(){
		return run(()-&gt;motor.run(.5) );
	}
	public Command stop(){
		return run(()-&gt;motor.run(0) );
	}
	public boolean isGamepieceLoaded(){
		return sensor.read()==false;
	}
	public Command defaultCommand(){
		return either(
			()-&gt;motor.run(.1),
			this::stop,
			this::isGamepieceLoaded
		);
	}
}
<br>public ExampleArm extends SubsystemBase{
	//motor created here
	ExampleArm(){//constructor
		//configure motor here
		setDefaultCommand(()-&gt;setArmAngle(90));
	}
	public boolean isAtTargetAngle(){
		return /*out of scope for now*/;
	}
	public Command setArmAngle(double angle){
		return run(()-&gt;motor.getPIDController().setReference(angle,/*...*/) );
	}
}
<br>public RobotContainer{
	//joystick and subsystem creation would go here
	RobotContainer(){
		joystick.a().whileHeld(grabGamepieceFromFloor());
	}
	public Command grabGamepieceFromFloor(){
		return new SequentialCommandGroup(
			new ParallelCommandGroup(
				intake.intake(),
				arm.setArmAngle(20)
			).until(intake::isGamepieceLoaded),
			new ParallelCommandGroup(
				intake.intake(),
				arm.setArmAngle(90)
			).until(arm::isAtTargetAngle)
		)
	}
}
<br>Here you can see all this come together: <br>
<br>We have a couple simple named commands for our rollers. 
<br>We have a more complex one that sets an arm position using a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>
<br>We have a couple boolean conditions we can check for potential system states
<br>We have a composite sequence that does a full, complete task. It uses different exit conditions, from different subsystems.
<br>And, we have a smart defaultCommand that does something different when loaded vs unloaded, so none of our other commands have to deal with it. The intake handles it for us.
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/commands.html</link><guid isPermaLink="false">Level 1/Commands.md</guid><pubDate>Mon, 22 Sep 2025 02:19:58 GMT</pubDate></item><item><title><![CDATA[Limelight Basics]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>
<a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a><br><br>
<br>Configure a Limelight to 
<br>Identify an April Tag
<br>Create a trigger that returns true if a target is in view
<br>When a target is in view, print the offset between forward and the target
<br>Estimate the distance to the target
<br>Configure the LL to identify a game piece of your choice.
<br>Indicate angle between forward and game piece.
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/limelight-basics.html</link><guid isPermaLink="false">Level 1/Limelight Basics.md</guid><pubDate>Mon, 22 Sep 2025 08:28:47 GMT</pubDate></item><item><title><![CDATA[Limelight Odometry]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:stub" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stub</a> 
 <br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> ]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/limelight-odometry.html</link><guid isPermaLink="false">Level 1/Limelight Odometry.md</guid><pubDate>Sun, 21 Sep 2025 03:17:42 GMT</pubDate></item><item><title><![CDATA[Robot Code Basics]]></title><description><![CDATA[ 
 <br><a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br>
<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder Basics</a><br><br>
<br>Install the WPILib VS Code IDE
<br>Make a new robot project
<br>Create a new subsystem
<br>Install the Rev third Library
<br>Basic requirements to start working  on robot projects
<br>Create a new empty subsystem 
<br>Create a new empty command
<br>Add your new command and subsystem to RobotContainer.
<br><br>Programming prerequisites, listed in <a data-href="Coding Basics" href="https://stormbots.github.io/KnowledgeBase/level-0/coding-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Coding Basics</a> for now<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/commandbased/structuring-command-based-project.html</a><br><br>When you open a new robot project you'll see a lot of files we'll interact with.<br>
<br>src/main

<br>deploy
<br>java
<br>frc/frc/robot

<br>commands

<br>ExampleCommand.java


<br>subsystems

<br>ExampleSubsystem.java


<br>Constants.java
<br>Main.java
<br>Robot.java
<br>RobotContainer.java




<br>vendordeps
<br>For typical projects, you'll be spending the most time in RobotContainer, subsystems, and occasionally commands. <br>For some early practice projects, or special use cases you might also interact with Robot.java,  ExampleCommand.java, or ExampleSubsystem.java a bit.<br><br>Many helpful utilities we'll use for robot projects are represented using code that's not available by default. WPILib has a small manager to assist with installing these, detailed here: <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries" target="_blank">https://docs.wpilib.org/en/latest/docs/software/vscode-overview/3rd-party-libraries.html#adding-offline-libraries</a><br><br>We'll also utilize a number of software tools for special interactions with hardware or software components. Some of these include <br>
<br><a data-href="Rev Hardware Client" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a> , a motor controller management tool
<br><a data-tooltip-position="top" aria-label="LaserCan" data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">GrappleHook</a> , which manages the LaserCan configuration
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html" target="_blank">NI Driver Station</a> is needed for systems that will want to enable and drive a robot. 
<br><br>The hardest part of getting started with robots is figuring out where your robot code goes. <br><br>Robot.java is a very powerful file, and it's possible to write your entire robot in just this one file! For reasons we'll get into later, we do not want to do this. However, the setup of it does a good job explaining how a robot works. Let's look at the structure of this file for now<br>public class Robot extends TimedRobot {
	private Command m_autonomousCommand;
	private final RobotContainer m_robotContainer;
	public Robot() {
		m_robotContainer = new RobotContainer();
	}
	
	public void robotPeriodic() {}
	
	public void disabledInit() {}
	public void disabledPeriodic() {}
		
	public void autonomousInit() {}
	public void autonomousPeriodic() {}
	
	public void teleopInit() {}
	public void teleopPeriodic() {}
	
	public void testInit() {}
	public void testPeriodic() {}
	
	//a few more ignored bits for now
}
<br>From the pairing, we can group these into several different modes<br>
<br>"Robot"
<br>Autonomous
<br>Teleop
<br>Test
<br>Indeed, if we look at our <a data-href="Driver Station" href="https://stormbots.github.io/KnowledgeBase/misc/driver-station.html" class="internal-link" target="_self" rel="noopener nofollow">Driver Station</a>, we see several modes mentioned.<br>
<img alt="driverstation.jpg" src="https://stormbots.github.io/KnowledgeBase/lib/media/driverstation.jpg"><br>
Teleop, Auto, and Test are simply selectable operational modes. However, you might want to utilize each one slightly differently.<br>"Practice mode" is intended to simulate real matches: This DriverStation mode runs Autonomous mode for 15 seconds, and then Teleop Mode for the remainder of a match time. <br>"Disabled" mode is automatically selected whenever the robot is not enabled. This includes when the robot boots up, as well as as whenever you hit "disabled" on the driver station.<br>
Disabled mode will also cancel any running <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> . <br>"Robot mode" isn't an explicit mode: Instead, of "Robot Init", we just use the constructor: It runs when the robot boots up. In most cases, the primary task of this is to set up Robot Container.<br>
robotPeriodic just runs every loop, regardless of what other loop is also running.<br>We can also see a grouping of <br>
<br>Init
<br>Periodic<br>
Whenever any new "mode" starts, we first run the Init function once, and then we run the periodic. The robot will continue run associated Periodic functions every loop, 50 times per second. 
<br>We generally won't add much code in Robot.java, but understanding how it works is a helpful starting point to understanding the robot itself. <br><br>As mentioned above, the "Robot Container" is created when you create a new project, and one of the first things that gets executed when running robot code. <br>This file contains a small number of functions and examples to help you organized. <br>public class RobotContainer(){
	ExampleSubsystem subsystem = new ExampleSubsystem();
	ExampleCommand command = new ExampleCommand();
	CommandXboxJoystick joystick = new CommandXboxJoystick(0);
	RobotContainer(){
		configureBindings();
	}
	public void configureBindings(){
		//Not a special function; Just intended to help organize 
	}
	public Command getAutonomousCommand(){/*stuff*/}
}
<br>This file introduces a couple new concepts  <br>
<br><a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>, which form the  "actions" you want the robot to perform
<br><a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>, or the different parts of the robot that could perform actions
<br><a data-href="Joysticks" href="https://stormbots.github.io/KnowledgeBase/misc/joysticks.html" class="internal-link" target="_self" rel="noopener nofollow">Joysticks</a> , which serve as the standard input method.
<br>The use of Commands and Subsystems goes a long way to managing complex robot interactions across many subsystems. However, they're certainly tricky concepts to get right off the bat. <br><br>Sometimes, you'll have oddball constants that you need to access in multiple places in your code. Constants.java advertises itself as a place to sort and organize these constants. <br>Without getting too into the "why", in general you should minimize use of Constants.java; It often leads to several problems as your robot complexity increases. <br>Instead, keep your constants as close to where they're used as possible, and move them up through the robot hierarchy as necessary. This is known as  "scope management" or "encapsulation".<br>
<br>If a value is used once, just use the value directly. This covers a lot of setup values like PID tuning values.
<br>If your value is used repeatedly inside a subsystem, make it a private constant in that subsystem. This is common for conversion factors, min/max values, or paired output values
<br>If a constant is strongly associated with a subsystem, but needs to be referenced elsewhere, make it a public constant in that subsystem.
<br>Lastly, if something is not associated with a subsystem, and used repeatedly across multiple subsystems, Constants.java is the place. 
<br>If you find yourself depending on a lot of constants, you might need to consider <a data-href="Refactoring" href="https://stormbots.github.io/KnowledgeBase/misc/refactoring.html" class="internal-link" target="_self" rel="noopener nofollow">Refactoring</a> your code a bit to streamline things. Note that Stormbots code generally has almost nothing in here! <br><br>The ExampleSubsystem.java file is a preconfigured, blank <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a>. We'll explore Subsystems in depth later.<br>By default, this class is created, and the periodic() function it contains will run every code loop. This makes it a great place to put a lot of starter code with minimal setup and fuss.<br><br>This is a standard, blank <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> . By itself, this file is not too useful. However, the fact that it exists allows useful joystick interactions to be set up in RobotContainer.java<br><br>The code examples provided in early code samples will be built using ExampleSubsystem and ExampleCommand, built into every new robot project. They should work as expected without a deeper understanding of Command based robots while you get your footing, and enabling you to migrate to Command based robots once you get there. If an example doesn't talk about Command based stuff, you probably don't have to worry about it!<br><br>While you can just create new files in a "normal" way, it's easy to accidentally miss code details that make things harder for yourself. <br>Instead, WPILib+VSCode has a built in way to do this. Simply right click the appropriate folder, and find the "Create new class/command" option.<br><img alt="creating-new-command-1.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/creating-new-command-1.png"><br>This will present you with a list of common FRC classes. The typical ones you'd use are Command and Subsystem.<br><img alt="creating-new-command-2.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/creating-new-command-2.png"><br><br>For those familiar with coding, you might wonder "Where does code actually start from?". This is a fair question in FRC code, which is a more complicated framework. The code path itself is predictable and a simplified view looks like this<br>- Main Bot Initialization
  - Robot.java::RobotInit
    - RobotContainer
      - Subsystem Constructors
      - Command constructors
  - Enter Disabled mode
    
- Disabled Mode
  - Initialize 
    - Robot.java::DisabledInit()
  - Loop
    - Robot.java::DisabledPeriodic
    - (each subsystem)::periodic()
      
- Teleop Mode
  - Initialize 
    - Robot.java::TeleopInit()
    - (any active commands)::init()
  - Loop
    - Robot.java::TeleopPeriodic()
    - (each subsystem)::periodic()
    - (any active commands)::execute()
<br>This is a lot of complexity if you're new to coding, but don't panic. You can mostly ignore a lot of this complexity, and our examples will help you position things properly until you get your bearings. <br>The complex part, robot actions that move motors and do things, basically boil down into<br>initialize/prep on boot
disabled
initialize
run
stop
<br>We will quickly capture this with our <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> framework, enabling you to do simple things very quickly and efficiently, like they're self-contained little programs.<br><br><a data-href="Deploying Code" href="https://stormbots.github.io/KnowledgeBase/level-0/deploying-code.html" class="internal-link" target="_self" rel="noopener nofollow">Deploying Code</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html</link><guid isPermaLink="false">Level 1/Robot Code Basics.md</guid><pubDate>Sat, 20 Sep 2025 19:17:09 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/driverstation.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/driverstation.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Mechanism2d]]></title><description><![CDATA[ 
 <br><br>
<br>Create a basic Arm or Elevator motion system
<br>Create a Mechanism 2D representation of the control angle
<br>Create additional visual flair on mechanism to help indicate mechanism context
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/mechanism2d.html</link><guid isPermaLink="false">Level 2/Mechanism2d.md</guid><pubDate>Mon, 22 Sep 2025 08:32:12 GMT</pubDate></item><item><title><![CDATA[SuperStructure Flywheel]]></title><description><![CDATA[ 
 <br>Superstructure component that holds a large amount of kinetic energy at a high velocity. Typically part of a subsystem oriented at launching game pieces.<br><br>
<br>Create a Flywheel system
<br>Tune with appropriate FeedForwards + PID to hit and maintain target RPMs 
<br>


<br><br>In some senses, none: A "Flywheel" is technically a spinning mass that provides inertial power to linked systems. We often add flywheels to our shooter rollers to add mass and make shots more consistent. <br> In FRC, we often use the term "flywheel subsystem" to help disambiguate the "spinning mass" part of a shooter from the "angular adjustment" part of a shooter. Otherwise, without good nomencalture, both parts get called "shooter", which is relatively unhelpful and can make things a bit confusing.<br>However, there's also physical differences in control and intent. The extra mass requires significantly more energy, resulting in either slower spinup, or much more power draw that can brown out your robot. We're also adding this inertia to stabilize shots, implying a desire for accuracy, precision, and consistency. In other words, this is very deep in the zone of performance tuning.<br><br>When spinning up a high-inertia system, the power draw can be incredible, typically pulling the full allotted power for all motors involved. <br>If we consider a brand new FRC battery, they have a rated capacity of 300A; A single FRC motor will pull 80-100A of that. If we have two motors, we'll pull 160A-200A. Keeping in mind we  have  other motors doing other things, especially 4 motors doing driving, you can easily sag the system voltage, causing loss of power and browning out one or more critical components. <br>Because of this, it's often a strategic choice on how how to handle power. Some teams (1540) advise just removing all power constraints: The reasoning is that by giving unlimited power to your flywheels, you get them up to speed quickly, trusting that the voltage sag is short enough that the various power regulation systems can recover properly.<br>
Other teams implement dynamic voltage constraints; Polling the various robot systems, and allocating power according to current system draw, and subsystem needs. <br>Both methods are worth considering, and both have been done on Stormbots in various seasons.<br><br>When operating with flywheels, the ideal behavior is simply to never have to change velocity. Theoretically, if the velocity doesn't change, you don't use power. <br>In reality, this is impossible ; Air resistance, bearing friction, motor internal resistance, and precession all work to sap flywheel energy and speed.  And of course, every time we change speed, we're using power from our battery. <br>It's also kind of unsafe to keep flywheels spinning at extremely high velocities all the time, and we often need to change velocity for different shots anyway.<br>As such, it's good practice to consider what to do when not shooting. This will change each season and each robot, and might change based on how a game involves. But, good considerations include:<br>
<br>Can we idle to a slower, safer speed instead of stopping? 
<br>Coasting to slow down rather than using brake or active PIDs
<br>When a shot is abandoned, can we maintain shooting speed for a time to prevent a need for significant adjustment a short time later?
<br>Can we give drivers options to boost RPM in advance?
<br>The goal is to maximize safety, minimize lag between driver + action, and minimize total speed adjustments. <br><br>For precision velocity control, the <a data-tooltip-position="top" aria-label="FeedForwards" data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForward</a> model, <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> tunings, and <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profile</a> are all very important. You mostly need to get and maintain the target RPM extremely quickly, while  minimizing overall settle time. <br>In some cases, you might actually find that minor PID overshoot doesn't cause problems, and can result in quicker time-to-target and overall settling.<br>Sometimes, using SysID can help you; This is a program that runs some test procedures, using the resulting physical measurements to analyze system response, and thus generate PID and FF values. If set up correctly, these values can be fed back into your robot config, helping you quickly account for hardware changes, wheel wear, and other factors that might have impacted your system performance.<br>Instead of painful precision tuning via graphs, implementing SysID into your java code can let you run these similar to an Auto sequence, letting you respond quickly to emergency repairs during competition. <br>Title
See Crescendo's robot code for examples on automated flywheel tuning procedures
<br>Note, that the recommended approach is still to do good feed-forward modelling and motion profiles before PID tuning. With this setup, it's likely that you can use relatively large PI values for getting up to target speeds, and PD terms and flywheel inertia will resolve in good disturbance rejections.<br><br>Drivers need to know when they can utilize an on-target flywheel. When in performance mode, they will be cutting every corner for performance, and their trust in robot feedback is crucial. Unfortunately, RPM is largely invisible to drivers in competitions. <br>In these cases, the robot's best feedback source is a <a data-tooltip-position="top" aria-label="Subsystem Lighting" data-href="Subsystem Lighting" href="https://stormbots.github.io/KnowledgeBase/Subsystem Lighting" class="internal-link" target="_self" rel="noopener nofollow">LED Subsystem</a> ; Simply have the bot  lighting give the all-clear to fire. In practice, this helps the drivers get a "feel" for spinup time, and in competitions gives them certainty that a shot will work as expected. <br>Note, that the feedback itself can be challenging: Remember, the goal is "will our shot make it" more than "Is the shooter at the target RPM". Some notable considerations:<br>
<br>Sometimes far-away shots at higher velocities only succeed with a lower RPM error than closer, nearby ones going at a slower speed. 
<br>Overshoot/undershoot might fall within an permissible, but cause missed shots due to how the acceleration affects the physics.
<br>Flywheel speed is only one aspect; You also have robot ground speed, rotational speed, and (possibly) the angle of your shooter configuration. Drivers must know what is and isn't accounted for.
<br>At the end of the day, your system might simply green-light a good RPM range and be good enough. Or, you might need to create a complex state machine to track and count system stability and settle time, or chain boolean logic for other conditions. <br>Whatever you do, your efforts put toward driver indicators will always be in vain if your drivers don't trust it. These systems require good communication with drivers to establish the trust boundaries for indicators, and to maintain that trust with accurate signals.<br><br>When working with a fixed-angle shooter, your system will always have to account for shot distance by adjusting RPM continuously. If RPM adjustment won't work, you simply can't make make a shot. <br>However, when given an adjustable angle shooter (see 2024 robot), programmers have 2 control axes to resolve shot distance. This allows a great amount of freedom in what a shot looks like. This lets us apply our design criteria, and consider our options:<br>
<br>Fix the angle, and have dynamic RPM adjustment
<br>Fix the RPM, and adjust the angle
<br>Adjust both at once all the time. 
<br>With the last one ruled out, you probably  want to consider which parameter to lock in place to optimize shots for a given area. In most cases, the best approach is to use an interpolating <a data-tooltip-position="top" aria-label="Lookup Tables" data-href="Lookup Tables" href="https://stormbots.github.io/KnowledgeBase/level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Table</a> (LUT). This allows you to convert a given known value (usually distance) into a tested combination of angle and distance. <br>Such a table can be very quickly generated using practice field elements, and provides very robust performance. With good distance spacing, you can quickly fix problem zones, and then nature of a LUT allows you to seamlessly switch between which output is fixed..<br><br>This is an ongoing advanced topic, and in early stages: <a data-href="Flight Trajectory Calculations" href="https://stormbots.github.io/KnowledgeBase/level-2/flight-trajectory-calculations.html" class="internal-link" target="_self" rel="noopener nofollow">Flight Trajectory Calculations</a><br><br><a data-href="System Identification" href="https://stormbots.github.io/KnowledgeBase/level-2/system-identification.html" class="internal-link" target="_self" rel="noopener nofollow">System Identification</a><br>
<a data-href="Lookup Tables" href="https://stormbots.github.io/KnowledgeBase/level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html</link><guid isPermaLink="false">Level 2/SuperStructure Flywheel.md</guid><pubDate>Sun, 21 Sep 2025 05:03:37 GMT</pubDate></item><item><title><![CDATA[Closed Loop Controller]]></title><description><![CDATA[ 
 <br><br>Often in robotics, we care a lot about the final state of a system: The position it's at, the rate it's going, the height of an elevator, etc. <br>However, the process of getting and maintaining this target state might not be trivial. It might require a variety of motor outputs to get there, change over time,  or be unpredictable due to external factors like game piece weight.<br>A closed loop controller is designed to manage exactly this. Instead of simply setting the output directly (a motor speed), we can instead provide a setpoint, representing the target state of our system. This can be a position, rate, temperature, brightness, or any other  measurable quantity. It's sometimes considered the "goal state".<br>A closed loop controller's job is to then manage the measured quantity and adjust the output to maintain that setpoint. In technical terms, we "feed back" the output as an input to this controller, forming a "closed loop" in our process diagram.<br><img alt="open-loop-closed-loop-diagram.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/open-loop-closed-loop-diagram.png"><br><br>Every controller style will have tradeoffs between many factors. Often times, these are <br>
<br>Precision: How well the controller tracks the setpoint
<br>Speed: How quickly the controller can get to the desired setpoint from typical states
<br>Stability: How well the controller reacts to unexpected situations. Some controllers completely break down and fail in certain conditions.
<br>Computational Efficiency: This affects resources used for maintaining control, and in some cases how fast you can run your closed loop system. In real world cases, faster is usually better.
<br>Tuning Difficulty: How hard it is to get the controller into a working, stable state. Some start working effectively in a few minutes; Others can 
<br>Conceptual Difficulty: Some controllers are easy to understand in an afternoon; Others require expert level understanding of complex mathematics to be able to work with effectively.
<br>Output capability: Some controllers are designed for output mechanisms that may not be available.
<br><br>A <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> is a general purpose, flexible, and powerful closed loop structure, that can "model" a wide variety of systems.<br>This is a most likely the closed loop option you want for typical FRC systems. <br><br>as derived on the <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> lecture, a Bang Bang controller looks at the error, and emits full output power depending on whether it's above or below. <br>class BangBang(){
	double max=1;
	double min=0;

	double calculate(double sensor, double setpoint){
		if(sensor &lt; setpoint){ return max ; }
		else if(sensor &gt;= setpoint){ return min; }
	}
}
<br>This kind of controller tends to be sub-optimal on most systems, but is useful in situations where you have <br>
<br>Analog inputs
<br>Binary outputs
<br>Comparatively large inertia relative to system power. 
<br><br>Hysteresis is a resistance to state changes, with numerous applications in physics and control theory, both advantageous and otherwise.<br>In control theory, hysteresis is often utilized intentionally to prevent rapid switching when a system is at setpoint, as shown in this modified bang-bang controller.<br>class BangBangWithHysterisis(){
	double threshhold=1;
	double max=1;
	double min=0;
	double currentValue=0
	
	double calculate sensor, double setpoint){
		if(sensor &lt; setpoint-threshhold){ currentValue=max;}
		else if(sensor &gt;= setpoint+threshhold){ currentvalue=min;}
		return currentValue;
	}
}
<br>In this code, you can see that if a setpoint is within 1 of the setpoint, it doesn't turn off or turn on; It simply does what it was already doing.<br>This creates both slight overshoot and slight undershoot, but creates a range of acceptable values, which is often suitable for applications where a standard BangBang controller would be used.<br>This is something you'll commonly see on automatic heaters: As the room cools, they turn on when you're too cold, and only turn off once you're a bit too warm, and the cycle repeats. You're never quite at the temperature you want, but generally pretty close to it. The hysteresis ensures that the heater always changes the temp by several degrees at once.<br>Hysteresis is also seen in automatic shifting algorithms in both cars and robots; This avoids unnecessary gear changes within ranges where either gearing is equally effective.<br><br>Similar to a Bang Bang (formally known as a two-point controller), a three-point controller has three states. Usually on/off/reverse, or off/low/high.<br>class ThreePointController(){
	double threshhold=1;
	double max=1;
	double min=-1;
	double off=0
	double currentValue=0
	
	double calculate sensor, double setpoint){
		if(sensor &lt; setpoint-threshhold){ currentValue=max;}
		else if(sensor &gt;= setpoint+threshhold){ currentvalue=min;}
		return off;
	}
}
<br>This looks a lot like the hysterisis control, but instead of overshooting through the middle zone, it simply turns off.<br>While not common in modern FRC, this control mode is very common in many real world applications due to the simple, cheap electronics needed to operate it.<br>In past FRC seasons, this type of control was used for relay controlled motors. It can also be used alongside two-pole pnuematic systems for somewhat analog control in air positioned systems. <br><br>This is an odd, but useful technique, as much as a specific algorithm. By taking the square root of the error, then applying a gain, you get a sharp, aggressive response for small errors, but decreasingly aggressive as the error increases further.<br>class SquareRootError(){
	double gain = 0.1;
	
	double calculate(double sensor, double setpoint,){
		var error = setpoint-sensor;
		output = gain * Math.signOf(error) * Math.sqrt(Math.abs(Error));
		return output;
	}
}
<br>This simple algorithm tends to generate a "springy" response to disturbances, is simple to tune, and typically can hit the setpoint reliably under a wider variety of disturbance conditions.<br>This algorithm tends to work well for velocity systems like <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a>, <a data-tooltip-position="top" aria-label="Superstructure Shooter" data-href="Superstructure Shooter" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Shooters</a>, or Drivetrain wheel speeds. When tuned effectively, disturbances will tend to generate the right amount of output to add momentum to the system, quickly getting things back to the velocity target.<br>It's best when performing continuous tracking of a setpoint, such as ones generated by position mapping from a joystick slider, or position/velocity targets generated by <a data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>. <br>It can also provide satisfactory results for point-to-point motion using Swerve or Mechanum drivetrains using odometry-oriented control.<br>A notable flaw is that it has no meaningful compensation setpoint changes, and simply causes output spikes.<br>The major flaw of this algorithm stems from the tendency to result in high frequency oscillation at the setpoint, especially for systems with notable <a data-tooltip-position="top" aria-label="Mechanical Backlash" data-href="Mechanical Backlash" href="https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html" class="internal-link" target="_self" rel="noopener nofollow">Backlash</a>. Using a <a data-tooltip-position="top" aria-label="Slew Rate Limiting" data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiter</a> on the output can improve response in these cases, often reducing the oscillation to negligible amounts. Allowing sharp oscillations make it sub-optimal for holding position in steady state conditions where there's no force or friction to keep it from mechanically thrashing gearing across backlash.<br><br>An integrator-oriented control loop with an output back-off when the error changes to prevent overshoot and simplify tuning. In FRC, potentially useful for velocity control.<br>Detailed explanation + plots<br>
<a rel="noopener nofollow" class="external-link" href="https://wiki.purduesigbots.com/software/control-algorithms/take-back-half-tbh-controller" target="_blank">https://wiki.purduesigbots.com/software/control-algorithms/take-back-half-tbh-controller</a><br>Reference implementation<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/team751/2013RobotCode/blob/master/src/org/team751/speedcontrol/TakeBackHalfSpeedController.java#L98" target="_blank">https://github.com/team751/2013RobotCode/blob/master/src/org/team751/speedcontrol/TakeBackHalfSpeedController.java#L98</a><br><br>This is a more mathematically complex differential-equation based control system, but with many advantages in real-world applications.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/state-space/state-space-intro.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/advanced-controls/state-space/state-space-intro.html</a><br>These can model physical systems extremely accurately, and actually are what is used internally when using <a data-tooltip-position="top" aria-label="Physics Simulation" data-href="Physics Simulation" href="https://stormbots.github.io/KnowledgeBase/level-2/physics-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">Simulation</a> .]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html</link><guid isPermaLink="false">Misc/Closed Loop Controller.md</guid><pubDate>Sat, 20 Sep 2025 23:31:23 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/open-loop-closed-loop-diagram.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/open-loop-closed-loop-diagram.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Code Patterns]]></title><description><![CDATA[ 
 <br>A "Pattern" describes a code technique to manage code complexity. Patterns are as much a communication tool as a coding one. Having a few patterns in your head might help you reason through complex problems. Similarly, if your code does follow a well known pattern, it's easy to communicate to others. <br>There exist dozens of universally helpful patterns, and even more patterns exist for specific programming domains (web, robotics, data analysis, etc). This is just a few we'll reference through our documentation.<br><br>The Factory pattern is one that bundles new item creation into a helper function call. It's called this because every time you call a factory, it spits out a new item for you. Just like factory-made objects in the real world, you don't have to know how it's made to get one and use it.<br>Factories provide a few useful properties<br>
<br>It provides a place to deal with a log of syntax once
<br>You can easily parameterize creation with function arguments
<br>The factory's scope can be different than the caller, letting the factory access functions you wouldn't be able to otherwise.
<br>In FRC, we'll commonly use Factories to generate <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> and Command Sequences within <a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>, and we'll often have a few stray functions for assisting in Autos or button handling.<br>This example showcases how this is often used. <br>ExampleSubsystem extends SubsystemBase{
	//This factory builds a command that sets a height
	//This hides a lot of logic in one place
	public Command setHeight(double height){
		return new RunCommand(
			/* motor logic goes here, not relevant for example */
			,this
		);
	}
	
	//This factory builds a command that builds 4 setHeight
	//This one is more about parameterizing and reducing extra
	//syntax and typing for this process
	public Command UpDownTwice(double height,double timeout){
		return new SequentialCommandGroup(
			//We use the previous factory to build 
			setHeight(height).withTimeout(timeout),
			setHeight(0).withTimeout(timeout),
			setHeight(height).withTimeout(timeout),
			setHeight(0).withTimeout(timeout),
		);
	}
}

<br>Many common functions in FRC already use factories like this behind the scenes! As a result, you might not see new .... too often in some of our documentation.<br><br>This is a code pattern commonly used to pass sensor or subsystem information into subsystems. This allows one class to access other objects in a parent scope it couldn't normally access. <br>In this example, both Chassis and Vision need to access our Odometry, so it can't be a child of either one. Instead, we make it a sibling, and pass a reference to create a dependency injection.<br>RobotContainer(){
	SwervePosteEstimator odometry = new SwervePosteEstimator(/*...*/);
	Chassis chassis = new Chassis(odometry);
	Vision Vision = new Vision(odometry);
}
<br>Dependency injection has a paired bit of code within each function. By java rules, the provided reference only lives through the constructor call. So, we need to save the reference within our class scope.<br>public class Vision extends SubsystemBase(){
	//This is a place to hold the reference within the Vision system scope.
	//Note, this has no initialization or = sign.
	SwervePosteEstimator odometry;
	
	Vision(SwervePosteEstimator odometry){
		//  :luc_arrow_down_left:Directly specify the class scope 
		this.odometry=odometry;
		//            :luc_arrow_up_right: unspecified, uses closest scope;
		//               in this case, that's the function scope
	}
	
	public void update(){
		// Within other class functions, the only valid scope 
		// is the class instance; We no longer need to specify with this.
		odometry./*do stuff with the object*/
	}
}
<br>In FRC code, we will use this a lot for subsystems and other shared, modifiable data. Dependency injection makes it easier and clearer which parts of your code will be working with a specific item, improving ease of debugging. <br><br>Singletons are a way to ensure one, and only one instance of a class exists. This pattern is typically used to protect unique resources that require shared access.<br>In technical terms, in Java, a "static" reference is one that is known at compile time, and exists as a property of the "abstract class" rather than an "instance". Singletons use this to store a reference to a single instance of the object, and then share that reference.<br>public class SingletonExample{
	//We create a static reference to a new 
	public static SingletonExample self;

	//Note the constructor is private! You cannot use `new ...`
	private SingletonExample(){/*initialization logic*/}

	public static SingletonExample getInstance(){
		if(self==null){self=new SingletonExample()};
		return self;
	}

	// ... Normal methods go here
}
<br>Since the singleton runs the constructor, it allows code to run to initialize the singleton object, making  this pattern very useful. <br>There's lots of use cases in FRC, with a common one being DriverStation.getInstance(), which provides access to the controlling laptop's Driver Station software.<br>Singletons also streamline scope access and initialization order: You simply run the static getInstance method, and it always works.  This use case makes it useful in FRC for sensor systems, avoiding the modification of class signatures required for Dependency Injection. <br>In many applications Dependency Injection and Singletons can resolve similar scope and access issues; However, for mutable systems that maintain internal state, dependency injection is usually preferred due to the explicit, more easily traceable nature.<br><br>State machines are coding patterns that help manage sequencing, transitions, and constraints of a system.<br>This is a complicated topic with a lot of useful applications, so it actually has it's own page here: <a data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machines</a><br>While state machines do have code, in general state machines are communicated using the state diagram. When the state logic is broken down well, the actual code often becomes trivial.<br><br><br><br>This example demonstrates a small video game character and how you might handle their Jump logic<br>]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html</link><guid isPermaLink="false">Misc/Code Patterns.md</guid><pubDate>Mon, 22 Sep 2025 05:11:19 GMT</pubDate></item><item><title><![CDATA[Driver Station]]></title><description><![CDATA[ 
 <br>The DriverStation software handles communication between your laptop and the FRC robot. <br><img alt="driverstation.jpg" src="https://stormbots.github.io/KnowledgeBase/lib/media/driverstation.jpg"><br>Official documentation is here:<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/driverstation/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/driverstation/index.html</a><br><br>The first tab is the Driver interface. This handles <br>
<br>Enabling the robot: When enabled, motors can actually spin, and the robot can be used
<br>Disabling the robot: This halts all output, and stops some running code processes.
<br>Mode selection (Teleop, Autonomous, Test, and Practice)
<br>Displays basic diagnostics (battery states, status, and communication status)
<br><br>This provides some network  and version info. Sometimes helpful for troubleshooting.<br><br>???<br><br>This tab lists connected controllers and joysticks, and allows you to rearrange them.<br>Connected joysticks are given a "Port" from 0 to 5; The connected controller needs to match the Port expected by the code, and this is done here. <br>This will also allow you to select devices, and see the <br><br>???<br><br>The right side of the DriverStation always shows printed messages, warnings, and errors. These messages can also be seen in the RioLog inside VSCode.<br>Clicking  the ⚙️ Icon above the text display can let you filter this display; Unfortunately several libraries and built-in functions are still very spammy, making this small interface mostly useless for debugging.<br>With a bit of hunting, you can access the Log Viewer; This allows you to read logs saved from prior matches or practice sessions. These can be very useful for some diagnostic faults, especially during matches where replicating or identifying conditions in other ways can be difficult.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station-log-viewer.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station-log-viewer.html</a><br><br>If you click the USB Tab, you can interact and view configured controllers. <br><img alt="driverstation-usb-tab.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/driverstation-usb-tab.png"><br>When working with a new controller, it's helpful to verify that it's detected in the right port, and that the joystick axes and buttons are numbered the way you expect.<br>The button and joystick numbering differ between similar looking controllers, so it's typically best to use CommandXboxController , which offer a way to access buttons by name; This makes them more robust and easier to identify without counting on this interface. This lets you access axes as stick.getLeftX(), stick.getRightY(), stick.getLeftTrigger(), stick.a(), etc.<br>When you do use numbers, just double check on the interface before deployment. <br>Team Controller Conventions
Because we're often sharing the same code and laptops across many teammates and projects, one thing we really want to avoid is having controllers not work or worse, start launching unexpected actions.<br>
Due to this, we have a convention:

<br>Driver Xbox/Playstation controller on Port 0 
<br>Operator/secondary driver controller on Port 1
<br>If you need to add a third, separate controller for special cases, use 2-5. This is rare.

This ensures everyone's DriverStation and joystick ports are the same.
<br>Xinput and DInput modes
Many controllers have two different modes, indicated with a slider on the back.<br>
One is X-input, following the X-box Controller numbering order.<br>
The other is D-input, following the HID Joystick standards.
These modes are often similar, but not guaranteed to be identical. The subtle  differences in button order can be very confusing. A common difference is the Left/Right Triggers changing from Analog (showing up as a Joystick Axis) to Digital (show up as a button).
Make sure you select the appropriate mode (usually Xinput mode) early, make a comment, and double check if something seems off.
]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/driver-station.html</link><guid isPermaLink="false">Misc/Driver Station.md</guid><pubDate>Sun, 21 Sep 2025 19:57:02 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/driverstation.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/driverstation.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Lambdas]]></title><description><![CDATA[ 
 <br><br>A "Lambda" is also known as an "anonymous function" . In a general sense, lambda's are just a quirky syntax to create "on the fly" functions, and otherwise work basically like any other function. <br>In WPILib code, it's common to want to pass procedures and code blocks to  <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> and <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a>, allowing those functions to know "how to get new values", rather than just what the values are when you first try to set them up. This is critical for real-time decisions, like "is a game piece loaded?" which you won't know when creating the command. <br>WPILib has good further reading that might assist with understanding.<br>
<a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/basic-programming/functions-as-data.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/basic-programming/functions-as-data.html</a><br><br>Functions should be common to most programmers. Let's take a look at the obvious properties of a function to make sure we're well set. <br>
<br>A name of the function
<br>A list of parameters
<br>And a returned value
<br>associated code to run
<br>For something like <br>public void sayHello(String name){print("hello "+name);}; 
<br>we can see that <br>
<br>the name is sayHello
<br>There is one parameter, named name
<br>There is code that prints a greeting and the name
<br>The return type is void, or has no return value. 
<br>However, another sneaky property is the function's scope. Scope represents variables and functions that the function has access to that are not strictly part of the function itself.  For Java, this often indicates files in the same class. This too should look familiar:<br>public class ExampleClass{
	String greeting="sup ";
	public void sayHello(String name){print(greeting+name);}; 
}
<br>Here, greeting is part of sayHello's scope, but not part of the function itself. This is a property of the function, even if it's not an apparent one. <br><br>This example takes uses Commands.run(), which takes a Runnable object, and executes once per robot loop. A Runnable simply describes "a function that takes no argument, and returns no values". We'll come back to this. <br>We can pass this to a command in two different ways<br>//Create a named function like we're used to
// and then pass a reference to it
void printSomething(){System.out.println("something");}	
Commands.run(this::printSomething);

//Or, just create it directly.
Commands.run(()-&gt;{System.out.println("something");});
}
<br>We can see that a lambda looks very similar to a function, with effectively the same structure. <br>// return type | function name | parameter list | the code block
void             printSomething   ()           {System.out.println("something");}
                                  ()       -&gt;  {System.out.println("something");}
<br>The primary difference is the missing function name, and lack of explicit return type. We don't need a name because it's anonymous. We don't need a return type, because it's declared by the Command's argument type: Runnable.<br>
The main difference is the -&gt; ; This is just the special lambda syntax. It might help to consider it as "goes to" or "yields" ; as in the parameter list (...) yields a value {block of code}.<br><br>Just as "Runnable" defines "A function that accepts no arguments and returns nothing", there's a whole bunch of standard references for functions that "Take X" and "Return X". <br>These are generally broken down into Suppliers (returns a value) and Consumers (accepts a value). Here's a few.<br>Runnable // takes nothing, and returns nothing. Just a pure code block.
BooleanSupplier // A function that takes nothing, and returns a boolean
DoubleSupplier // A function that accepts nothing, and returns a double

BooleanConsumer // Function that takes a boolean and returns nothing.
<br>That's about it! These helper classes are only necessary as type indicators for function arguments. The functions you're passing in will just be normal functions.<br><br>A great reference is the FunctionalCommand class. This class takes 4 lambdas, replacing each of the core parts of a <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> with a simple code. It looks like this. <br>FunctionalCommand(
	Runnable, //initialize
	Runnable, //execute
	BooleanSupplier, //isFinished ; returns a boolean
	BooleanConsumer // end; takes a boolean that indicates if it was cancelled.
);
<br>Let's say we want to create a command that <br>
<br>Print the time it starts
<br>how long it ran, and if it was successful
<br>End 5 seconds after it starts
<br>double startTime=0;
new FunctionalCommand(
	()-&gt;{//initialize by recording the time
		startTime=Timer.getFPGATimestamp();
		System.out.println(startTime);
	},
	()-&gt;{}, //execute: do nothing
	()-&gt;{return Timer.getFPGATimestamp()-startTime&gt;=5}, //isFinished
	(cancelled)-&gt;{ //our end block
		System.out.println(Timer.getFPGATimestamp()-startTime);
		System.out.println(cancelled);
	}
<br>Hooray! This works, and leads us to a useful confirmation: Like any other function, you can access any variable in the current scope in which it was created.<br>When we combine this feature with <a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> and the Factory pattern for commands, we can have variables with a "function scope" serve as data between the components of the command. <br>This scope access also is a large value add when creating <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> inside of <a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>. We can just access useful constants, motors, encoders, and helper functions without any extra setup.<br><br>It's often helpful to take functions as arguments. This allows you to isolate the code you're writing from objects that create that data. <br>Let's create a function that takes two lambdas, and returns the value of the larger one. You <br>Double myFunction(DoubleSupplier left, DoubleSupplier right){
	var letfvalue = left.getAsDouble();
	var rightvalue = right.getAsDouble();
	if(letfvalue &gt; rightvalue) return left;
	return right;
}
<br>This command doesn't do much in practice, but demonstrates the process. A more utilitarian practice is something like a "Drive" command on the robot; Sure, you could take a Joystick object, and then read from that. But, what if you want to feed it values from a Vision process? Vision doesn't have a joystick, so, you need a new entire Drive command for it. If you want to use a rangefinder? Another whole  drive command.<br>Instead, creating a DoubleSupplier interface means your drive command can get values from arbitrary functions, making them much more generic and helpful.<br><br>The other important detail: What if we're trying to run the above myFunction, but we just want a constant value on one side? Well, lambdas work here too. We just create a new, lambda that returns a value. Just because it's boring, doesn't mean  it's not helpful!<br>//Somewhere in our code where we want to do a check
myFunction(()-&gt;0.1,joystick::getLeftX)
<br>One supplier just evaluates to 0.1 every time it's ran. The other side does something on the human input side. In a realistic sense, this could make some intake idle at a low value to hold a game piece, with a human operator maybe running it with more power to do something useful.<br>The flexibility of accepting functions vs simply doubles is significant, and will streamline your code development for many advanced features.]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/lambdas.html</link><guid isPermaLink="false">Misc/Lambdas.md</guid><pubDate>Sun, 21 Sep 2025 21:51:08 GMT</pubDate></item><item><title><![CDATA[Encoder Basics]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Robot Code Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/robot-code-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Robot Code Basics</a><br><br>
<br>Configure a Spark motor encoder
<br>Read an encoder position
<br>Configure encoder range/units through gearing
<br>Enable/Disable Soft Limits
<br><br>An Encoder is a sensor that provides information about a mechanism's rotation. <br>Since motors generally apply power through rotation, clever use of encoders allows you to infer a significant amount of system information. <br>Encoders wind up being one of our primary sensors on FRC bots, due to their prevalence and flexibility.<br><br><br>The simplest version of an encoder is simple sensor that switches between one and zero during a rotation.<br><img alt="Incremental_encoder.gif" src="https://stormbots.github.io/KnowledgeBase/lib/media/incremental_encoder.gif"><br>This simplified encoder is often called a "gear tooth" sensor, since it's commonly associated with sensors that directly measure the one or more teeth on a gear directly. This generates a single pulse train like this:<br>
<img alt="Digital_Gear_Tooth_Sensor.gif" src="https://stormbots.github.io/KnowledgeBase/lib/media/digital_gear_tooth_sensor.gif"><br>This pulse train switching between 0 and 1 provides some information about the rotation of the shaft: By counting the time between changes you can calculate the speed of the system. By counting the number of cycles, you can also tell how many teeth have passed.<br>However, this sensor is limited: The pulse train looks exactly the same whether you're going forward or backward! So you can't know what direction you're going, just how fast or how far. <br>As a result, this sensor type is mostly used for measuring velocity where the direction is known by some other mean: Often the output of a motor itself. <br><br>An effective way to add the direction back in is to just track a different position. By carefully selecting a location that triggers slightly off from the first one, you get some interesting effects.<br><img alt="Incremental_directional_encoder.gif" src="https://stormbots.github.io/KnowledgeBase/lib/media/incremental_directional_encoder.gif"><br>Tracking the signals (from left to right), you get signal values that look like this:<br><img alt="quad-encoder-waveform-output.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/quad-encoder-waveform-output.png"><br>Because of the way the two signals overlap, you now have 4 signal states: 00, 01, 11, and 00. And importantly, you from any particular state, you can only go to 2 of other 3 states! For example, you cannot go directly from 11 to 00 : You must go to either 10 or 01. <br>Because of this, you always know what way a rotation is happening: If you're at 11, and go to 10, you're going clockwise. <br>This property means that quadrature encoders are much more capable than GearTooth encoders. It can still track velocity, but can measure velocities at low speeds, or with external inputs where you wouldn't know the direction. <br>In addition, since you always know the direction, you can also just count the pulses as they come by. This lets you know precisely how far something has rotated, effectively indefinitely. <br>It's important to note that another name for these is a "Relative encoder", since it only tells you a rotation relative to when it started counting! This means where your system is when the sensor starts is an important consideration!<br><br><br>The Rio can directly handle external quadrature encoders using the <a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/hardware-apis/sensors/encoders-software.html" target="_blank">WPI Lib Encoders</a> classes. While uncommon in modern FRC, they show up on occasion. <br><br>Modern FRC uses brushless motors for most operations, and have built in encoders that are ready to use! As a result, this is the most common interaction with encoders.<br>These are accessed by interfacing with a Spark Motor controller, like so. <br>ExampleSubsystem extends SubsystemBase{
	//Note: Your motor ID will probably be something different!
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	RelativeEncoder encoder = motor.getEncoder();

	// ... other stuff this way
}
<br>Rookie Coder notes
If you're still getting the hang of code structure, you can work in the ExampleSubsystem.java file for now! It's all set up on new Command Based Robot templates, and will work like you're expecting.
<br>Finding Motor IDs
If you're unsure about the motor ID, you can do get it using the <a data-href="Rev Hardware Client#Identifying a motor ID" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html#Identifying_a_motor_ID" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client &gt; Identifying a motor ID</a>
<br>We now have an encoder.... but it's not doing anything. Let's make it do something. Encoders are good at telling you how far they rotated, so let's print that. <br>ExampleSubsystem extends SubsystemBase{
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	RelativeEncoder encoder = motor.getEncoder();
	
	// ... other stuff
	
	public void periodic (){
		System.out.println(encoder.getPosition());
	}
}
<br>Deploy this to the robot, and you should pop up with the Riolog tab in VSCode. If not, hit CTRL+Shift+P to bring up the VS Code Command Pallete. Type "Start Riolog" to select the option, then hit enter.<br>You should now see a screen full of numbers. So... try rotating your motor. It should change, but it's unclear how much. We haven't configured it to any sort of a known state.<br>To get better diagnostic information such as graphs, or multiple values at once, you might check out <a data-href="Basic Telemetry" href="https://stormbots.github.io/KnowledgeBase/level-1/basic-telemetry.html" class="internal-link" target="_self" rel="noopener nofollow">Basic Telemetry</a><br><br>The <a data-href="Rev Hardware Client" href="https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html" class="internal-link" target="_self" rel="noopener nofollow">Rev Hardware Client</a> page can assist with adjusting parameters, which is useful for quick diagnostics and testing. <br>To configure it in code, we need to do a few things. First, is set up a config object, and clear factory defaults. This means we have a lot of potential quirks cleaned up instantly.<br>ExampleSubsystem extends SubsystemBase{
	SparkMax motor = new SparkMax(10, MotorType.kBrushless);
	RelativeEncoder encoder = motor.getEncoder();
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		armMotor.configure(
			//The configuration settings to apply
			config,
			//Whether or not to reset all unspecivied values
			ResetMode.kResetSafeParameters,
			//Whether or not to keep the new values after 
			//power cycling the motor controller
			PersistMode.kPersistParameters
		);
	}	
	// ... other stuff
}
<br>If you run this on your test bench, you'll probably see the numbers change differently than they did prior. By default, the encoder is configured to provide "Rotations" from the getPosition() method. If you rotate the motor shaft exactly once, the encoder will return 1. <br>If your testbench has some gearing involved, you'll get a different number multiplied by the gearing. For example, if you're on a Kit Of Parts drivetrain, it might have a gear ratio of 12.75:1. This means it takes 12.75 motor rotations to rotate the output wheel once. Or, put the opposite way: If you rotate drivetrain wheel exactly once, you should get an encoder reading of 12.75. <br>However, we generally care more about the output of the system than the motor, so we want to apply a conversion factor so we can "read" the output directly. <br>To get this, we need to take that logic above, and rotate our system's output exactly once. Record the number of "motor rotations" as your conversion factor, and we'll add it to the code.<br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		var conversionfactor=12.75; //1 divided by whatever number you determined
		config.encoder.positionConversionFactor(1/conversionfactor);
		armMotor.configure(
			config,
			ResetMode.kResetSafeParameters,
			PersistMode.kPersistParameters
		);
	}	
	// ... other stuff
}
<br>The "conversion factor" is just a multiplier from the base unit (1 rotation). Since we know that 1 output rotation generates 12.75 motor rotations, we want to divide by 12.75. <br>And, after we deploy this, we'll see that we can rotate our wheel once, and get an "encoder" reading of 1. <br><br>We've been glossing over velocity, but it's time! This is helpful too. The process from this point is actually pretty easy, and we can get it with just a few minor changes. <br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		SparkBaseConfig config = new SparkMaxConfig();
		var conversionfactor=12.75; //1 divided by whatever number you determined
		config.encoder.positionConversionFactor(1/conversionfactor);
		//Configure the velocity conversion factor too
		config.encoder.velocityConversionFactor(1/conversionfactor/60);
		armMotor.configure(
			config,
			ResetMode.kResetSafeParameters,
			PersistMode.kPersistParameters
		);
	}	
	// ... other stuff
	public void periodic (){
		//Change to velocity
		System.out.println(encoder.getVelocity());
	}
}

<br>The main detail of note is that we use the same conversion factor to account for gearing.<br>
We also have two ways of doing velocity conversion, depending on our desired Rate unit. <br>By default, 1/conversionfactor will give us Rotations Per Minute. In this case, the extra /60 is to convert from rev's default Velocity unit of Rotations Per Minute to Rotations Per Second. For many of our tasks, having the unit in "per second" winds up being more useful since it's easier to visualize.<br>Generally, we'll calculate the conversion factor using Position since it removes the aspect of time; This makes it much, much simpler to get accurate results. <br><br>Now that we can convert motor rotations to output shaft rotation, we can go a step further and convert that output rotation to a linear motion. This is pretty straightforward: Over 1 rotation, you cover 1 circumference of distance. So, just divide your conversion factor by your wheel diameter. Since we're calculating "x distance per rotation", so you would expect a division here.<br>
The final configuration will look something like this:<br>// ... stuff
	var circumference = Math::PI * 4; // 4 inch wheel
	//1 divided by whatever number you determined
	var conversionfactor=12.75/circumference;
// ... the rest of the stuff
<br><br>If the units to configure your encoder is overwhelming, consider <a data-href="Factor Label" href="https://stormbots.github.io/KnowledgeBase/misc/factor-label.html" class="internal-link" target="_self" rel="noopener nofollow">Factor Label</a> methods to help you step through it. This is a useful method of tabulating units to keep track of conversions like this. <br>As a sample calculation, this is what it looks to set up the conversion for a KOP bot's drivetrain from motor rotations to inches per second.<br><br><br>Another way we'll commonly handle encoder configuration is through a simple empirical process:<br>
<br>Set the encoder conversion to 1 , putting the units as "motor rotations"
<br>Put the system to known physical condition that's easy to measure. (zero feet traveled, arm at horizontal, etc)
<br>Zero the encoder (either a power cycle or a code reset)
<br>Move the system to a new physical condition that's also easy to measure. (10 feet traveled, arm at vertical, etc)
<br>Keeping with our Kitbot example, in factor label form it would look something like this:<br><br>Doing the math, we get  inches/motor rotations, and our conversion factor is decided!<br>An advantage of this method is that it requires no knowledge about how a system is geared. This is great for getting a system running and validating calculations. It can also help with systems that have difficult to calculate ratios, such as winding ropes or straps. <br>One big disadvantage is precision: Every time you repeat this calculation, the results are slightly different. This may or may not be a problem, depending on the mechanism. <br>Competition Consideration
It's not advised to use empirical analysis for drivetrains! During competition, wheel wear will often force constant re-calibration. However, in pit environment it's very challenging to get space to push a drivetrain. This makes corrections time consuming and inaccurate, making your drivetrain and autos inconsistent.
<br><br>Having insight into the robot provides a ton of value, especially when combined with  <a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a> and <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> . This makes it easy to do things like <br>
<br>See if a shooter is near a desired RPM before feeding a game piece into it
<br>See how far you've driven and stop
<br>Check a system's speed to see if it jammed.
<br>We're not quite ready to do things like precisely control RPM, speed, or distance. For that, we need a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a>.<br><br>Quadrature encoders are powerful, but not without flaws. The main thing is fundamental to position tracking with this type of encoder:<br>
<br>You need to already know where you are when you you start counting pulses to have a meaningful knowledge of the system's position
<br>If something causes it to lose count (such as loss of power or a code reset), then you've lost the connection to the reference, and now don't know where you are.
<br>There's a couple ways to avoid this. The easiest way is to start at your reference, and not lose count! As you might expect, this places some constraints on how you as humans boot up the robot. It also carries a small (but non-zero) risk for the second case. <br>For fully mitigating this, you need to make use of <a data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a> , which allow you to fully recapture your reference from an unknown starting state.<br>Other options include simply using different sensors! For example, <a data-href="Absolute Encoders" href="https://stormbots.github.io/KnowledgeBase/hardware/absolute-encoders.html" class="internal-link" target="_self" rel="noopener nofollow">Absolute Encoders</a> can capture rotation data. <br><br>Encoders all have functions to set or zero the current encoder value value. For our example, we could do this using the following code<br>ExampleSubsystem extends SubsystemBase{
	// ... other stuff
	public void ExampleSubsystem(){
		//Reset encoder on boot ?
		encoder.setPosition(0);
	}
	// Other stuff
<br>But should we? We need to consider both the mechanisms physical state and the code state carefully, since we expect them to correlate. Let's examine the typical points at which one or both of these can change<br>
<br>When power is applied, the mechanism is in an unknown position, the encoder is at zero, and the code runs initialization.
<br>When you deploy new code after running it, the mechanism can be in any state, the encoder is unchanged (by default) , and our code re-runs initialization
<br>This leads to the following cases: <br>
<br>If we power on the bot in an known reference state, the encoder will match it for the first run of code.
<br>If we do not reset position in initialization, we can always assert that the encoder still matches the physical position, even if we re-run or restart code.
<br>If we do reset position, we do so without being able to assert that we're at the hardware reference!  This means we have to physically check that we're at the hardware each time manually. 
<br>Because of this, for now we probably do not want to zero the encoder, which allows us to set the physical state once on boot, and re-use it indefinitely. <br>If needed, you can generate <a data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing Sequences</a>, which are ways for the bot to physically assert a known system state and do the reset encoders safely. These are usually optional (at least initially), but are critical for robust high-torque systems or high precision ones.]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html</link><guid isPermaLink="false">Level 1/Encoder Basics.md</guid><pubDate>Sun, 24 Aug 2025 01:04:03 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/incremental_encoder.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/incremental_encoder.gif"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Hard Stops]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:stub" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stub</a> 
 <br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> ]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/hard-stops.html</link><guid isPermaLink="false">Level 1/Hard Stops.md</guid><pubDate>Tue, 16 Sep 2025 21:15:28 GMT</pubDate></item><item><title><![CDATA[Robot Design Analysis]]></title><description><![CDATA[ 
 <br><br>
<br>Examine a robot design
<br>Generate a design plan indicating the breakdown
<br>Recommended: <br>
<br><a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a>
<br><a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a>
<br><a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a>
<br>Cursory check of the available subsystem types
<br><br>This guide runs through how to examine a robot design, analyze the mechanics, game piece path, and form a plan to generate a code structure to control the system.<br><br>For an FRC bot, "move the game piece" is the fundamental design objective, and serves as a great way to step through the bot from a design process. <br>If you start at "need to obtain a game piece" and then proceed through game play cycles, you'll naturally follow a good analysis process, and observe the various handoffs and subsystem interactions. <br>The game piece flow often gives an intuitive sense for "forward" direction in many systems where it might be ambiguous. "intake -&gt; score" as positive often provides a streamlined notation to make testing and bringup of systems a bit more consistent.<br><br>Being able to identify basic mechanisms is key to being able to model a robot in code. This non-exhaustive list should help provide some vocabulary for the analysis on typical bots.<br><a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a> The simplest mechanical system: A motor and a shaft that spins.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Flywheel" data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">Flywheel</a> A specialized Roller system with extra weight, intended to maintain a speed when launching objects.<br>
<a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexer</a> A mechanism to precisely align, prepare, or track game pieces internally in the robot. Often a Roller, but can be very complex.<br>
<a data-tooltip-position="top" aria-label="Superstructure Shooter" data-href="Superstructure Shooter" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Shooter</a> A compound system, usually consisting of at least a Flywheel and an Indexer, and sometimes an Arm or other aiming structure.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Intake" data-href="SuperStructure Intake" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-intake.html" class="internal-link" target="_self" rel="noopener nofollow">Intake</a> A specialized compound system intended for getting new game pieces into the robot. Generally consists of a Roller, often with another positioning mechanism like an Arm.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> A system that rotates around a pivot point. Usually positions another subsystem.<br>
<a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> A system that travels along a linear track of some sort. Typically up/down, hence the name.<br>
<a data-tooltip-position="top" aria-label="Swerve Basics" data-href="Swerve Basics" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Drive</a> or <a data-href="Differential Drive" href="https://stormbots.github.io/KnowledgeBase/level-1/differential-drive.html" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive</a>: Makes robot go whee along the ground.<br>The systems in your robot will often take these basic archetypes and rename them to something else, and in some cases combine them into compound mechanisms.<br>Step 1 is break down the robot into component mechanisms, and follow up how they link to eachother. <br><br>As you're breaking down your system, it's necessary to define what values correlate to a "positive" motion. This is not as trivial as it sounds for some bots, but is necessary to ensure the team can refer to the motions and directions with the same language.<br>
<br>Elevator style systems go up, so up -&gt; Positive
<br>Arms should follow math convention of anti-clockwise-&gt; Positive. It's easiest to pair 0 and "horizontal" 
<br>Drivetrains seem obvious: Positive means forwards. However, this assumes you know "what side is the front": If you have intakes and scoring on different sides, this usually requires discussing it with the designers to get everyone in agreement. 
<br>Intake,  Indexer, and scoring mechanisms can be trickier. Often, the simplest route is to consider "intaking direction positive", which often defines all systems at once. 
<br>By doing all this, it becomes much easier for hop between subsystem bringups and diagnose motor and encoder configurations later.<br><br>As you track game piece flow, you will see natural states where the robot has inventory change (acquiring/losing game pieces), or changes posture (extending/retracting intakes, raising/lowering elevators, etc).<br>As the robot moves between states (such as unloaded, loading, loaded, preparing to score, scoring), keep an eye on both the states and the transitions to ensure that things go smoothly.<br><br>In a few places, you'll probably see certain state transitions that are a bit less clear, or rely on information the robot may not have. <br>The classic example is the intake: If your robot transitions from unloaded-&gt;loaded , you may need to shut off the intake right away to prevent intaking excess game pieces, getting fouls and jams. However, if there's no good detection method, you may not be able to quickly trigger a shutoff.  This often requires a supplemental sensor, and additional handling logic.<br>Watch your state transitions for places where a sensor provides significant benefits in robustness, efficiency, or aiding driver control. If so, consider adding sensors, and working with mechanical teams to facilitate placement.<br><br>Most FRC mechanisms have physical limits that must be coded. These are often trivial to document, but notable.<br>While often avoided in bot designs,in some cases multiple systems will attempt to occupy the same physical space. This is clearly a problem, and one that needs careful consideration. In some cases these can be trivial handled, but in other cases the entire robot code base must plan around it.<br>A simple collision fix is a lockout: Say a grabber is mounted on the elevator, and when extended, it collides with the intake. Therefore, we define 2 lockouts: If elevator is below X, the grabber cannot extend. If the grabber is extended, then it cannot go below X. The two systems are intertwined, but have a lockout system that helps manage their motions.<br>For more complex cases, simple lockouts don't work, and systems must follow a more complex series of state transitions, forming a <a data-tooltip-position="top" aria-label="State Machines" data-href="State Machines" href="https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html" class="internal-link" target="_self" rel="noopener nofollow">State Machine</a>. We often avoid programming our robots with explicit super-structure state machines, but it's a common <a data-tooltip-position="top" aria-label="Code Patterns" data-href="Code Patterns" href="https://stormbots.github.io/KnowledgeBase/misc/code-patterns.html" class="internal-link" target="_self" rel="noopener nofollow">pattern</a> in FRC for designs with significant collision potential or complex motion patterns.<br>Identifying these issues early helps you plan your overall code structure.<br><br>Based on the above, you can identify certain code features that the robot must have to accomplish game tasks, do self-management, and otherwise hit your goals. These are general things like "Aim at the goal", "shoot a game piece", "extend up to scoring position", etc. High level overviews of the primary things you're doing.<br>For an example of this stage, see the case study below.<br>There's also few standard house-keeping tasks due to system constraints or evergreen rules:<br>
<br>The robot must have suitable methods to home or acquire correct internal system states
<br>Robots typically have an initial starting in-frame configuration, which may require special handling
<br>Manage the disable/re-enable transition (which may or may not be trivial depending on bot) 
<br><br>With the mechanics, code, and game piece flow understood, it's worth considering what the driver interface will resemble. Once again iterate through the full game piece flow from floor to score, as well as any endgame or alignment tasks.<br>As you do this, look for button sequences that seem problematic: Notably button sequences that always have to go in a fixed sequence, buttons that might misbehave when loaded/unloaded or in certain bot states, or "combo" multi-button presses that put undue stress on the driver. Your goal is to have each input be unambiguous and safe.<br>In practice, each button will likely control a small sequence of robot actions and safety checks; This particular analysis step is intended to facilitate identifying any missing features, sensors, or processes that would make robust control challenging. <br>In some cases, we also need to consider the amount of available buttons: It may need to be the cases that buttons are "modal", and do two different things depending on what "mode" the robot is in. Common modal states are "which game piece is loaded", or "if X is deployed we're doing Y now". Be careful here: Any mode switches need to be very obvious to drivers, and we want to facilitate muscle memory as much as possible.<br>Remember to leave buttons for "error correction actions"! You'll always need at least one button to "reset" the robot, clear jams, or eject badly loaded game pieces. <br>The gold standard of inputs is a "win button"; The driver starts the match, hits a button, then wins. While this is not attainable in practice, we can split a complex game into smaller tasks that can be accomplished and managed by a single button; This lets the drivers focus on the higher level match strategy rather than manage the robot's interactions.<br>Note that your initial input analysis will not be final! Drivers will have their own preferences, and later considerations will pop up. This step is a sanity check.<br><br>Next is to work toward a relatively complex auto. This is typically one that at scores one game piece, and acquires+scores a second. <br>Unlike a Tier 1 "get the robot on the field" auto which is "score a piece and stop", a Tier 2 auto requires consideration for re-alignment, odometry, and re-acquisition.  Even if we never build this auto, putting these details in our roadmap early on can help guide our code toward a solution that will work. If we do not do this, it's easy to lock ourselves into a Tier 1 auto that we cannot extend easily. When given a choice on how to code our autos, we want to ensure that a useful auto can be the foundation for a more complex one.<br>Note that implementing the auto indicated here is not a requirement: Considering how we can make it happen and what supporting infrastructure is needed is the valuable part at this stage.<br><br>We're now good to code! At this time you can <br>
<br>Plan out your subsystems, knowing how they interact and should be split.
<br>Plan out your subsystem APIs and interfaces
<br>Plan any lockout management
<br>rough out what your button sequences should be
<br>Get a rudimentary auto to serve as a starting point for more complex ones
<br>The final step of analysis and prep is to "stub" your subsystems: EG, writing all the functions and signatures (parameters+return values) , but not actually putting in the code that makes them work. <br>The goal of this step is to ensure that higher level work (like buttons and autos) can be scripted out in advance. This means  code like intake.intake() might not work, but it can still be put into code and left in place until it does.<br><br><br><a data-tooltip-position="top" aria-label="https://github.com/stormbots/Crescendo/" rel="noopener nofollow" class="external-link" href="https://github.com/stormbots/Crescendo/" target="_blank">Crescendo Bot Code</a><br>
Note The actual code for this bot may differ from this breakdown; This is based on the initial design provided, not the final version after testing. <br>Game info
The game piece for this game is an 2" tall, 14" diameter orange donut called a "note", and will be  referenced throughout this breakdown.<br>
There are two note scoring objectives: Shooting into an open "speaker" slot about 8' high, or placing into an "amp", which is a 2" wide slot about 24" off the ground.<br>
Lastly, climbing  is an end game challenge, with an additional challenge of the "trap", which is effectively score an amp while performing a climb. 
<br><br>For this, we'll start with the game piece (note) path, and just take note of what control opportunities we have along this path. <br>The note starts on the floor, and hits the under-bumper intake. This is a winding set of linked rollers driven by a single motor. This system has rigid control of the note, ensuring a "touch it own it" control path.<br>Indexer: The  game piece is then handed off to an indexer (or "passthrough"). This system is two rollers + motors above and below the note path, and have a light hold on the note; Just enough to move it, but not enough to fight other systems for physical control.<br>Flywheel: The next in line is a Flywheel system responsible for shooting. This consists of two motors (above and below the note's travel path), and the rollers that make physical contact. When shooting, this is the end of game piece path. This has a firm grip to impart significant momentum quickly.<br>Dunkarm + DunkarmRollers: When amp scoring/placing notes, we instead hand off to the rollers in front of the shooter. These rollers are mounted on an arm, which move the rollers out of the way of the shooter, or can move it upward. <br>Shooter: The Indexer and Shooter are mounted on a pivoting arm, which we denote as the shooter. This allows us to set the note angle.<br>Climber: The final mechanism is the climber. There's two climber arms, each with their own motor.<br><br>The indexer has a single <a data-href="LaserCan" href="https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html" class="internal-link" target="_self" rel="noopener nofollow">LaserCan</a> rangefinder, located a just before the shooter. This will allow detection of a game piece being loaded or not, and with some math, the precise positioning of the game piece.<br><br>Again let's follow the standard game piece and flow path. <br>
<br>Intake+Indexer interaction: A note can be held by both Intake and Indexer simultaneously. In this case, the intake exerts control.
<br>Intake + Shooter : If the shooter angle is too high, note transfer to the indexer will fail. 
<br>Indexer + Flywheel: A note can be held by both intake and indexer simultaneously. Again, the shooter wins, but fighting the indexer would impact accuracy/momentum.
<br>Flywheel + Dunkarms: A note getting passed into the dunkarm rollers is held more strongly by the shooter than the dunkarm rollers. This can only be done at a fixed angle combination.
<br>Climber + Dunkarms. When climbing without trap scoring, the chain will come down on the dunkarms. The climber will win with catastrophic damage. 
<br>Climber + Shooter: When trap scoring, the dunk arms are out  of the way, but the chains will come down on the shooter.
<br>Dunkarm and shooter: The rollers can potentially be in the way of the shot path. This can occur at low shot angles, or if the dunkarm is moving down after other scoring.
<br>This seems to be about it for conflicts between control systems<br>We should  also do a quick check of the hard stops; These serve as reference points and physical constraints.<br>
<br>Dunkarms have a lower hard stop. It has no upper hard stop, but eventually rotates too far and breaks wiring.
<br>Shooter has a bottom hard stop. It has a upper end of travel, but no physical stop.
<br>Climber has a bottom hard stop, and a upper end of travel. In both cases, high torque movement will cause damage when ran into.
<br>All other systems are rollers, with no hard or soft stops. 
<br><br>Before getting into how the code is structured, let's decide what the code should be doing during normal gameplay cycles<br>
<br>Intake note: This will be running the intake, feeding the note into the indexer. Since running too far will feed it into the shooter, we can use our indexer sensor to end the process. 
<br>Shot preparation: Before shooting a note, we need to make sure the note is not pushed into the flywheels. Once that's done, we need to get to the target angle and speed. 
<br>Shooting: The indexer needs to feed the note into the flywheel.
<br>Score amp: This takes a note held in the dunk arm rollers, rotate up, and then rotate the rollers to score it. 
<br>Load dunkarm rollers: This requires the dunkarm + shooter to be in the desired lineup, then the indexer feeds the note into the shooter, which in turn feeds it into the dunk arm rollers. The rollers must be capable of stopping/managing the note to prevent it from falling out during this process.
<br>Climbing,  no trap: Climber goes up, climber comes down, and doesn't crush the dunkarms.
<br>Scoring Trap: This requires maneuvering around the chain to get the dunkarms in position. From there, it's just climbing, then amp scoring. 
<br><br>We can now start looking at how to structure the code to make this robot happen. Having a good understanding of <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> flow helps here, but is not required.<br>We'll start with subsystems breakdowns. Based on the prior work, we know there's lots of loose coupling: Several subsystems are needed for multiple different actions, but nothing is strongly linked.  The easy ones are:<br>
<br>Intake (1 motor)
<br>Indexer (2 motors, the top and bottom)
<br>Shooter (the pivot motor)
<br>Flywheels (the two motors, top and bottom)
<br>Climber (two motors, left and right)<br>
This allows commands to  pair/link actions, or allow independent responses. 
<br>The Dunkarm + Dunkarm rollers is less clear. From an automation perspective, we could probably combine these. But the humans will want to have separate buttons for "put arm in position" and "score the note". To avoid command sequence conflicts, we'd want these separate.<br>
<br>Dunkarm (1 motor, the pivot)
<br>Dunkarm Rollers (1 motor for the roller pair)
<br>Next we define what the external Command API for each subsystem should look like so we can manipulate them.<br>
<br>Intake:

<br>Intake command to pull in a note. 
<br>Eject: In case we have to get rid of a note


<br>Flywheel:

<br>Shoot note. Would need the appropriate RPM, which may be constant, or vary based on vision/sensor data. 
<br>Pass to dunk arm. This is likely just running at a target RPM, but may use other logic/control routines.
<br>Retract note: In case something goes wrong, perhaps we want to pull the note in and clear the shooter for a reset.
<br>isAtTargetRPM check, which is critical for sequencing


<br>Shooter Pivot

<br>SetAngle 
<br>isAtTargetPosition for sequencing


<br>Dunkarm:

<br>Set Angle. Would just need an angle reference.
<br>isAtTargetAngle check for sequencing
<br>Manual positioning: The human may  control this directly for trap score line up


<br>Dunkarm Rollers:

<br>Load, which is likely just a speed/power suitable for controlled intaking from the robot
<br>Score Amp, another speed/power appropriate for this task
<br>Score Trap, Another speed/power for the task
<br>drop/eject, just get rid of a note if something went wrong.
<br>getPosition, since certain tasks might require specific positions


<br>Climber: 

<br>set height: Basically the only job of this system is go up/go down
<br>Is At Target Height check. Maybe useful for sequencing


<br>Indexer

<br>load/intake: For working with the intake to load notes
<br>hasNote check; This is required for "end of intake"
<br>feedShooter: Feed a held note into the flywheels as part of the shooting process


<br>With this, we now have the structures in place to start asserting how we'd define more complex actions and sequencing.<br><br>Before we really dive into writing all our robot code it's now, it's helpful to walk through a basic game piece structure, and make a couple "high level code" sequences to verify that you can in fact do the things you want to do. Often you'll catch missing details this way. <br> This will use the <a data-tooltip-position="top" aria-label="Commands" data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Command</a> and <a data-tooltip-position="top" aria-label="Triggers" data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Trigger</a> syntax, but it should be fairly readable without specific knowledge.<br>We know from prior analysis what our intake process looks like: Run the intake, feed it into the indexer, then stop when it hits the indexer's sensor. This should look something like this:<br>Commands.parallel(
	intake.intake(),
	indexer.intake()
).until(indexer.hasNote());
<br>Once we have a note, we then have to score it. For now, we'll simply assume a fixed position on the field (which is what we did at this bot's first competition!)<br>Commands.sequence(
	Commands.parallel(
		flywheel.setRPM(3000),
		pivot.setAngle(60)
	).until(pivot.isAtTarget().and(flywheel.isAtTargetRPM())),
	
	Commands.parallel(
		flywheel.setRPM(3000),
		pivot.setAngle(60),
		indexer.feedShooter(),
	).withTimeout(500)
)
<br>And, now we can actually score. This code isn't ideal (we have duplicated sections and magic numbers), but that comes later. We're in proof of concept stage.<br>If we followed through with this exercise for the other <a data-href="#Critical code tasks" href="https://stormbots.github.io/KnowledgeBase/about:blank#Critical_code_tasks" class="internal-link" target="_self" rel="noopener nofollow">Critical code tasks</a> noted above, we could fully validate all parts of our system to make sure we've covered all necessary command and trigger interfaces.<br><br>With this, we've somewhat defined have confirmed our game plan for the bot code breakdown works, and provides us with the work Subsystem program<br>Be aware that "simple" routines like this might sometimes have surprising interactions mechanically. Indexers (or Passthroughs) are full of these. In this bot, the actual code's shoot sequence actually uses the intake too, since the note would often snag there, causing shot failures.<br>
Similarly, intaking initially required running the flywheels; We had to stop them or the note would catch, going from an intake process to an intake-and-immediately-shoot process!]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/robot-design-analysis.html</link><guid isPermaLink="false">Level 1/Robot Design Analysis.md</guid><pubDate>Mon, 15 Sep 2025 19:49:27 GMT</pubDate></item><item><title><![CDATA[Git Basics]]></title><description><![CDATA[ 
 <br><br>Understand the typical Git operations most helpful for day-to-day programming<br><br>This module is intended to be completed alongside other tasks: Learning Git is best done by doing, and doing requires having code to commit.<br>
<br>Read through the <a data-href="#Git Fundamentals" href="https://stormbots.github.io/KnowledgeBase/about:blank#Git_Fundamentals" class="internal-link" target="_self" rel="noopener nofollow">Git Fundamentals</a> section
<br>Initialize a git repository in your project
<br>Create an initial commit
<br>Create several commits representing simple milestones in your project
<br>When moving to a new skill card, create a new branch to represent it. Create as many commits on the new branch as necessary to track your work for this card. 
<br>When working on a skill card that does not rely on the previous branch, switch to your main branch, and create a new branch to  represent that card.
<br>On completion of that card (or card sequence), merge the results of both branches back into Main.
<br>Upon resolving the merge, ensure both features work as intended.
<br><br>
<br>Understanding git
<br>workspace, staging, remotes
<br>fetching
<br>Branches + commits
<br>Pushing and pulling
<br>Switching branches
<br>Merging
<br>Merge conflicts and resolution
<br>Terminals vs integrated UI tools
<br><br>Git is a "source control" tool intended to help you manage source code and other text data.<br>Git has a lot of utility, but the core concept is that git allows you to easily capture your files at a specific point in time. This allows you to see how your code changes over time, do some time travel to see how it used to look, or just see what stuff you've added since your last snapshot.<br>Git does this by specifically managing the changes to your code, known as "commits". These build on each other, forming a chain from the start of project to the current code. <br>At the simplest, your project's history something like the following<br><br>Git is very powerful and flexible, but don't be intimidated! The most valuable parts of git are hidden behind just a few simple commands, and the complicated parts you'll rarely run into. Bug understanding how it works in concept lets you leverage it's value better.<br><br>Fundamental to Git is the concept of a "difference", or a diff for short. Rather than just duplicating your entire project each time you want to make a commit snapshot, Git actually just keeps track of only what you've changed.<br>In a simplified view, updating this simple subsystem<br>/**Example class that does a thing*/
class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
	ExampleSubsystem(){}
	public void runMotor(){
		motor.run(1);
	}
	public void stop(){/*bat country*/}
	public void go(){/*fish*/}
	public void reverse(){/*shows uno card*/}
}
<br>to this<br>/**Example class that does a thing*/
class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
	private Encoder encoder = new Encoder();
	ExampleSubsystem(){}
	public void runMotor(double power){
		motor.run(power);
	}
	public void stop(){/*bat country*/}
	public void go(){/*fish*/}
	public void reverse(){/*shows uno card*/}
}
<br>would be stored in Git as <br>class ExampleSubsystem extends SubsystemBase{
	private SparkMax motor = new SparkMax(1);
+	private Encoder encoder = new Encoder();
	ExampleSubsystem(){}
-	public void runMotor(1){
-		motor.run(1);
+	public void runMotor(double power){
+		motor.run(power);
	}
	public void stop(){/*bat country*/}
<br>With this difference, the changes we made are a bit more obvious. We can see precisely what we changed, and where we changed it.<br>
We also see that some stuff is missing in our diff: the first comment is gone, and we don't see go(), reverse() or our closing brace. Those didn't change, so we don't need them in the commit. <br>However, there are some unchanged lines, near the changed lines. Git refers to these as "context". These help Git figure out what to do in some complex operations later. It's also helpful for us humans just taking a casual peek at things. As the name implies, it helps you figure out the context of that change.<br>We also see something interesting: When we "change" a line, Git actually <br>
<br>Marks it as deleted
<br>adds a new line that's almost the same<br>
Simply put, just removing a line and then adding the new one is just easier most of the time. However, some tools detect this, and will bold or highlight the specific bits of the line that changed.
<br>When dealing with whole files, it's basically the same! The "change" is the addition of the file contents, or a line-by-line deletion of them!<br><br>Now that we have some changes in place, we want to "Commit" that change to Git, adding it to our project's history. <br>A commit in git is a just a collection of smaller changes, along with some extra data for keeping track. The most relevant is  <br>
<br>A commit "hash", which is a unique key representing that specific change set
<br>The "parent" commit, which these changes are based on
<br>The actual changes + files they belong to.
<br>Date, time, and author information
<br>A short human readable "description" of the commit. 
<br>These commits form a sequence, building on top from the earliest state of the project. We generally assign a name to these sequences, called "branches". <br>A typical project starts on the "main" branch, after a few commits, you'll end up with a nice, simple history like this. <br><br>It's worth noting that a branch really is just a name that points to a commit, and is mostly a helpful book-keeping feature. The commits and commit chain do all the heavy lifting. Basically anything you can do with a branch can be done with a commit's hash instead if you need to! <br><br>We're now starting to get into Git's superpowers. You're not limited to just one branch. You can create new branches, switch to them, and then commit, to create commit chains that look like this:<br><br>Here we can see that mess for qual 4  and mess for qual 8  are built off the main branch, but kept as part of the competition branch. This means our main branch is untouched. We can now switch back and forth using  git switch main  and git switch competition to access the different states of our codebase. <br>We can, in fact, even continue working on main adding commits like normal. <br><br>Being able to have multiple branches like this is a foundational part of how Git's utility, and a key detail of it's collaborative model. This is more traditionally referred to as a "git tree", since we can see it starts from a single trunk and then branches out into all these other branches.<br>However, you might notice the problem: We currently can access the changes in competition or main, but not both at once.  <br><br>Merging is what allows us to do that. It's helpful to think of merging the commits+changes from another branch into your current branch.<br>If we merge competition into main, we get this. Both changes ready to go! Now main can access the competition branch's changes. <br><br>However, we can equally do main into competition, granting competition access to the changes from main. <br><br>Now that merging is a tool, we have unlocked the true power of git. Any set of changes is built on top of each other, and we can grab changes without interrupting our existing code and any other changes we've been making! <br>This feature powers git's collaborative nature: You can pull in changes made by other people just as easily as you can your own. They just have to have the same parent somewhere up the chain so git can figure out how to step through the sequence of changes.<br><br>When managing changes, there's a couple places where they actually live. <br>The most apparent one is your actual code visible on your computer, forming the "Workspace". As far as you're concerned, this is just the files in the directory, or as seen by VSCode. However, Git sees them as the end result of all changes committed in the current branch, plus any additional, uncommitted changes.<br>The next one is "staging": This is just the next commit, but in an incomplete state. When setting up a commit, staging is where things are held in the meantime. Once you complete a commit, the staging area is cleared, and the changes are moved to a proper commit in your git tree.<br>
Staging is not quite a commit, as the changes represented here can be easily over-written by staging new changes from your Workspace. But, it's not quite the workspace either, and doesn't automatically follow modifications to your code.<br>
Because of this, Staging is extremely useful for code review! Staging a specific change is a great way to assert that that part is working and tested, even if you're not ready to make a commit yet.<br>In terms of our usual git tree, Staging and Workspace fit in right at the end, like so.<br><br>Lastly, is the actual commits that form your history. We generally won't deal with them individually, and instead just bundle them up in "branch". A branch is is just a helpful shorthand that names a specific commit, but in practice is used to refer to all prior changes leading up to that current commit.<br><br>Git is a distributed system, and intentionally designed so that code can be split up and live in a lot of different places at once, but interact with each other in sensible ways for managing the code.<br>The most obvious place it lives is your computer. You have a full copy of the git tree, plus your own staging and workspace. This is often called the "local" repository.<br>Next is a "remote" repository, representing a remote git server. Often this is Github, using the default remote name of "origin".<br>The important consideration is that your computer operates totally independently of the remote unless you intend to interact with it! This means you can do almost any Git task offline, and don't even need a remote to make use of Git. <br>Of course, being set up this way means that if you're not paying attention, you might not catch differences between Remote and Local git states. It's rarely an actual problem, but can be confusing and result in extra work. It's good practice to be aware of where your code is relative to origin, and make sure you push your code up to it  when appropriate.<br>When the origin is indicated specifically, you'll see it shown before the branch name: Main would go from main -&gt; origin/main, like you see here in <a data-tooltip-position="top" aria-label="Git from VSCode" data-href="#Git from VSCode" href="https://stormbots.github.io/KnowledgeBase/about:blank#Git_from_VSCode" class="internal-link" target="_self" rel="noopener nofollow">Git Graph</a>, showing that we have 1 commit locally that doesn't exist on the origin. Or, we're ahead by one commit.<br><img alt="git-graph-commit-history.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-graph-commit-history.png"><br><br>Often when doing merges, you'll run into a "merge conflict", and some parts of your code get replaced with massive compiler errors and weird syntax. Don't panic! <br>Merge conflicts happen when two branches change the same code. Git can't figure out what the "right answer" is, and so it needs a helping hand. To facilitate this, it has some special syntax so that you can see all information at a glance, but it's not always obvious that it's just being helpful! <br>Let's look at the simplest possible merge conflict: Being in main, and merging dessert<br><br>From an original file containing <br>Best food is pizza
<br>The commit in main has the following change<br>-Best food is pizza
+Best food is salad
<br>with dessert having this change<br>-Best food is pizza
+Best food is cheesecake
<br>The merge is then making Git decide what's the optimal food. Git is not equipped for this debate, so it's up to us humans. Git prepares the file in question using "merge markers" around the issue, which provide some useful info to resolve it<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  
Best food is salad  
=======  
Best food is cheesecake  
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dessert
<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD -&gt; indicates the start of a merge conflict. HEAD just means "last commit on current branch". Since we're on main, that means this code is just the result of following the code along the Main branch. VSCode will add additional information above this to help clarify.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dessert -&gt; is the end of merge conflict. dessert is the branch you're merging from; In other words, it's the result of following the proposed changes along the cheesecake branch. Again, VSCode will add additional info  to help. <br>======= -&gt; is the separator between the two branches'  code.<br>It's helpful to remember the goal of a merge: To put the two codebases together in a way that makes sense and is correct! So a merge conflict is resolved by making code that works, meaning there's several different ways to fix it!<br>One option is just accepting the change in your current branch, yielding<br>Best food is salad
<br>This just means you've ignored the proposed change from the other branch (dessert in this case)<br>The other option is accept the incoming change, and ignore what your branch had.<br>Best food is cheesecake  
<br>In some cases it's both! Maybe you're just fine with two best foods. <br>Best food is salad
Best food is cheesecake  
<br>Of course, you're after correctness. It's possible that after the update neither branch is quite right, and you have to adjust both.<br>Best side dish is salad
Best dessert is cheesecake  
<br>Or, it could be neither! Maybe the right solution has become something else entirely. <br>Best food is breakfast burritos
<br>Most of the time, a merge conflict should be very easy to deal with if you know the parts of the code you're working with.<br>
Just move the code around until it works like both branches expected, then delete the merge marker, separator, and any unnecessary code, and you're good to go!<br>And, don't worry if you missed one! Git will spot these conflict markers if you try to commit one without sorting it out. <br>If you get lost, ask for help! When dealing with code someone else wrote, you simply might not know what the best option is when coming out of it. That's fine! No tool can replace good communication.<br><br>Merge conflicts aside, just because a merge didn't have a conflict, doesn't mean the code works. A sometimes surprising result stems from the fact that Git doesn't understand code, it just understands changes! <br>The most likely reason you'll see this is someone changing a function name in one branch, while the other branch adds a new occurrence of it. Let's consider adding this code in our current branch<br>@@ MainBranch: RobotContainer.java @@
   //filecontext
+  exampleSubsystem.callSomeFunction();
   //filecontext
<br>and merging in this change from another branch.<br>@@ CleanupBranch: ExampleSubsystem.java @@
   //filecontext
-  public void callSomeFunction(){
+  public void betterNamedFunction(){
   //filecontext
<br>In this case, main doesn't know about the name change, and CleanupBranch doesn't know that you added a new call to it. This means callSomeFunction() no longer exists, leading to an error.<br>As with merge conflicts, it's up to you to figure out what's correct. In cases like this, you just want to adjust your new code to use the new name. But it sometimes happens that the other branch did something that needs to be changed back, such as deleting a function no one was using... until now you're using it.<br>Again, the purpose of the merge is to make it work! You're not done with a merge until everything works together as intended.<br><br>A lot of Git's power boils down to just using the simple usage of a few basic commands. <br>Git via command line vs Graphical tools 
While using the command line is optional, most good Git tools retain the name of these operations in graphical interfaces. After all, they're using the same operations behind the scenes.<br>
Because of this, a bit of command line knowledge can help clarify what the more user-friendly tools are trying to do, and show you exactly why they're helpful. 
<br><br>git init will creates a new git repository for your current project. It sets the "project root" as the current folder, so you'll want to double-check to make sure you're in the right spot! <br>VSCode's built in terminal will default to the right folder, so generally if your code compiles, you should be in the right spot. Once the repository is created, git commands will work just fine from anywhere inside your project.<br><br>Knowing what your code is up to is step 1 of git. These commands<br>git status just prints out the current repo status, highlighting what files are staged, and what have unstaged changes, and where you are relative to your remote. If you've used other git commands, the effects will show up in git status. Run it all the time!<br>git log will open a small terminal dialogue walking you through changes in your branch (hit q to exit). However, it's often unhelpful; It contains a lot of data you don't care about, and is missing clarity on ones you do.<br>git log --oneline tends to be more helpful ; This just prints a one-line version of relevant commits, making it much more useful. <br><br>git add &lt;files&gt; is all that's needed in most cases: This will add all changes present in a specific file. <br>git add &lt;directories&gt; works too! This adds all changes below the specified folder path. Be mindful to not add stuff you don't want to commit though! Depending on the project and setup, you may or may not want to add all files this way.<br>git add .  is a special case you'll often see in git documentation; . is just a shorthand for "the current folder" . Most documentation uses this to indicate "Stage the entire project", and is mostly helpful for your very first commit. Afterwards, we'd recommend a more careful workflow.<br>git reset &lt;staged file/dir&gt; will will remove a file's changes from Staging and put them back in the Workspace ; Meaning, the change itself is preserved, but it won't be changed.  In practice, you probably won't  do this much, as it's easier to use a GUI for this. <br><br>git commit -m "describe changes here" tends to be the beginner friendly approach. This makes a new commit with any staged changes.<br>git commit will usually open a small terminal editor called Vim with commit information and let you type a commit message. However, this editor is famous for it's "modal" interface, which is often surprising to work with at first. We'll generally avoid using it in favor of VSCode's commit tooling.<br>Quick Vim tutorial
If you get caught using the Vim editor for a commit, this is a quick rundown of the critical interaction.<br>
escape key-&gt; undo whatever command you're doing, and and exit any modes. Mash if you're panicking.<br>
i -&gt; When not in any mode, enter Insert mode (INSERT will be shown at the bottom). You can then type normally. Hit escape to go back to "command mode"<br>
: -&gt; start a command string; Letters following it are part of an editor command.<br>
:w -&gt; Run a write command (this saves your document)<br>
:q -&gt; Run a quit command (exit the file). This will throw an error if you have unsaved changes.<br>
:q! -&gt; The ! will tell Vim to just ignore warnings and leave. This is also the "panic quit" option.<br>
:wq -&gt; Runs "save" and then "quit" using a single command<br>
This means the typical interaction is i (to enter insert mode), type the message, escape, then :wq to save and quit.<br>
You can also abandon a commit by escape + :q!, since an empty commit message is not allowed by default. 
<br><br>git branch NameOfNewBranch: This just makes a new branch with the current name. Note, it does not switch to it! You'd want to do that before trying to do any commits!<br>Note, the parent node is the last commit of your current branch; This is not usually surprising if you're working solo, but for group projects you probably want to make sure your local branch is up to date with the remote!<br><br>git switch NameOfBranch: This one's pretty simple! It switches to the target branch. <br>git switch --detach &lt;commithash&gt; : This lets you see the code at a particular point in time. Sometimes this can be useful for diagnosing issues, or if you want to change where you're starting a new branch (maybe right before a merge or something). --detach just means you're not at the most recent commit of a branch. <br>You might see git checkout NameOfBranch in some documentation; This is a common convention to "check out" a branch. However, the git checkout command can do a lot of other stuff too. For what we need, git switch tends to be less error prone.<br>Switching + uncommitted changes
Note, Git will sometimes block you from changing branches! This happens if you have uncommitted changes that will conflict with the changes in the new branch. It's a special kind of merge conflict.<br>
Git has a number of tools to work around this, but generally, there's a few simpler options, depending on the code in question

<br>Delete/undo the changes: This is a good option if the changes are inconsequential such as accidental whitespace changes, temporarily commented out code for testing, or "junk" changes. Just tidy up and get rid of stuff that shouldn't be there. 
<br>Clean up and commit the changes: This is ideal if the changes belong to the current branch, and you just forgot them previously
<br>"Work in progress" commit: If you can't delete something, and it's not ready for a proper commit, just create a commit with message beginning with  "WIP"; This way, it's clear to you and others that the work wasn't done, and to not use this code. 
<br>use "git stash" the changes: This is git's "proper" resolution for this, but the workflow can be complicated, easy to mess up, and it's out of scope for this document. We won't use it often.

<br><br>git merge otherBranchName : This grabs the commits from another branch, and starts applying them to your current branch. Think of it as merging those changes into yours. If successful, it creates a merge commit for you.<br>git merge otherBranchName --no-commit : This does the merge, but doesn't automatically make a commit even when successful! This is often preferable, and makes checking and cleanup a bit easier. Once you've ran it, you can finish the commit in the usual way with git commit<br>git merge --abort is a useful tool too! If your merge is going wrong for whatever reason, this puts you  back to where you were before running it! <br>git merge (note no branch name) merges in new commits on the same branch; This is useful for  collaborate projects, where someone else might update a branch. <br><br>git fetch connects to your remote (Github), and makes a local copy of everything the remote system has! This is one of the few commands that actually needs internet to function. <br>Note, this does not change anything on your system. It does as the name implies, and just fetches it. Your local copies of branches remain at the commit you left them, so git fetch is always safe to run, and some tools run it automatically.<br><br>git pull will contact the remote system, and apply changes from the remote branch to your local branch.<br>Behind the scenes, this is just running git fetch and then git merge. So, if you run git fetch and then try to work without internet, you can still get things done! Just use git merge with no branch name.<br><br>git push does this. By default it uses the same name, making this a short and simple one. <br>Success not guaranteed
 git push will fail if the push would cause a merge conflict on the remote system. This can happen if the remote branch has been modified since you branched off of it.<br>
If this happens, you'll need to update your repository with git fetch or  git pull , resolve the conflict, and try again
<br><br>Handling Git operations from VS Code is normally a very streamlined operation, and it has good interfaces to do otherwise tricky operations. <br><br>This plugin provides some notable visualization tools that further improves Git handling in VS Code. We'll assume this is installed for the remainder of the tutorial here.<br>
<a rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" target="_blank">https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph</a><br>Install that first!<br><br>The  icon on left side will open the git sidebar, which is the starting point for many git operations. <br>Opening it will provide some at a glance stuff to review.<br><img alt="git-window+sidbar.png.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-window+sidbar.png.png"><br>We can see a lot of useful things:<br>At the top we can see any uncommitted changes, and the file they belong to. We'll deal with this when reviewing changes and making new commits.<br>
<img alt="git-commit-interface.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-commit-interface.png"><br>At the bottom (which might be folded down and labelled &gt; Outline or &gt; Graph), we can see our commit history for the current branch. The @main represents the current branch state, and  icon represents the Origin (Github). If we're ahead or behind the origin, we can see it at a glance here.  <br><img alt="git-sidebar-commit-log.png.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-sidebar-commit-log.png.png"><br>Note, we also see main at the very bottom; That's always there, giving us our current branch at a glance. <br><br>The easiest way to review changes is through the Git Sidebar: Just click the file,and you'll see a split view. <br>Changes will be shown in one of two ways. "Additions" are shown as a green highlight on the right side. On the left, you can see a ///////////////// placeholder; This helps align the code so that you can easily keep track of where stuff gets inserted!<br><img alt="git-diffview-addition.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-diffview-addition.png"><br>Deletions look similar, but reversed. Left gets a red, right gets a placeholder.<br>
<img alt="git-diffview-deletion.png.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-diffview-deletion.png.png"><br>Changes to part of a line are either an addition and removal, or a small highlighted change of the particular bits. <br>Note, you can actually type here! The right hand side is editable, allowing you to revise things if you see a change that's concerning. That side just represents the current state of the file in the workspace.<br>
The left side is locked; This represents the prior state of the file, which can only be changed by adding more commits. <br>You can approve/confirm changes in a couple ways. The easiest is to simply use the "Stage Changes" button by the filename in the sidebar; This stages all changes in a particular file.<br>
<img alt="git-sidebar-state-changes.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-sidebar-state-changes.png"><br>In many cases, it's helpful to handle them one by one: If you right click on a change (or selected text that includes one or more changes), you'll see some options besides the normal text editing ones<br>
<img alt="git-diffview-rightclick-stage.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-diffview-rightclick-stage.png"><br>As the name implies, you can Stage changes if you want them, Unstage them (if you want to remove it from the commit you're putting together).<br>
Note, you can also Revert it. In this case, reverting means that the change is gone! Added lines vanish, changed numbers go back to what they were, and reverting a deletion puts all the lines back! Be very careful here to not undo your work!<br>Note, that there's also a Revert/Discard Changes button too! Fortunately, this one checks with you. We'll rarely use it, but make sure to not hit it accidentally!<br>
<img alt="git-sidebar-discard-changes.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-sidebar-discard-changes.png"><br>Once we've staged some changes, we'll any staged changes separate from any unstaged changes<br><img alt="git-sidebar-staging-field.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-sidebar-staging-field.png"><br>
You can commit with un-staged changes just fine, just be mindful! We'll touch on best practices later. <br>Once you've added all changes you want to include in the commit, just enter the message and click "Commit". Done! <br><br>VS Code has some useful built in operations to push or pull branches! These will typically pop up automatically, with the helpful options being <br>
<br>Push -&gt; Does a standard push
<br>Pull -&gt; Does a standard pull
<br>Publish Branch -&gt; This is a normal Push, but applies to newly created local branches. This normally requires a couple other small steps, which this handles automatically
<br>Sync -&gt; Don't use this one!
<br>The "Sync" button
Be careful about the "Sync" button! Unlike other VSCode options, "Sync" will try to push and pull at the same time; However, in case of a merge conflict, it might try to resolve it using esoteric git operations behind the scenes. While this sometimes works, when something goes wrong fixing it properly is extremely challenging!<br>
In almost all cases, using a git pull , verifying the merge, and then a git push is a better workflow!
<br><br>We're now looking at the <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph" target="_blank">Git Graph</a> specific stuff, so make sure that's installed!<br>There's two ways to launch it. One is using VS Code's Command Palette, activated by CTRL+Shift+P then typing "View Git Graph" or "git log" to pull up this particular one.<br>
<img alt="git-gitgraph-command-palette.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-gitgraph-command-palette.png"><br>The other is by clicking "Git Graph" along the bottom toolbar.<br>
<img alt="git-gitgraph-bottom-bar.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-gitgraph-bottom-bar.png"><br>Both of these will take you to a good review interface, where you can see the status of many branches, the commit log, and how things merged and diverted! This is from our 2025 season code.<br><img alt="git-gitgraph-interface.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-gitgraph-interface.png"><br>Just this interface provides a lot of value: You can easily see the commit history, how branches have diverged and been merged, and check to see what branches are ahead or behind of the  origin. <br>If you click a commit, you get a more detailed status, but most notably what files were altered.<br>
<img alt="git-gitgraph-diff-detail.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-gitgraph-diff-detail.png"><br>
And, if you click the file in the commit details, it'll show you what that commit changed!<br>
<img alt="git-gitgraph-diffview.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-gitgraph-diffview.png"><br>
This is a very fast and effective way to look through your project and catch up on what's happening. <br>There's a lot of other value here if you click around, including being able to right click and checkout or switch to various branches!<br><br>VS Code's terminal often pops up during many other operations, but if you don't see it, you can access it through the menu.<br>
<img alt="git-terminal-new.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-terminal-new.png"><br>Since we usually work on Windows, this will often open up a Powershell, which is usually sub-optimal for what we want to use a terminal for. Git Bash is usually nicer. You can change this with the Command Pallete (CTRL+Shift+P), and selecting Terminal: Select Default Profile. <br><img alt="git-terminal-change-default.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/git-terminal-change-default.png"><br>If Bash is available, click it! Any new terminals will use the Git bash, which will have color, some at-a-glance git info, and generally more helpful all around. <br><br>There's a lot of tools that interact with your Git repository, but it's worth being mindful about which ones you pick! A lot of tools wind up changing normal git operations into renamed or altered versions that do a lot of things at once. This can make learning it harder, and if something goes wrong, fixing the results can be extremely difficult. Stick to the basics until you know what's happening and you can properly judge if a new tool is worth using.<br><br><br>Creating the initial project setup:<br>
<br>git init to set up our new project.
<br>git add .   to stage all the files in their blank, default state
<br>Commit the code, using VSCode's interface or with the terminal git commit -m "initial commit" 
<br>Doing the code work:<br>
<br>git branch featurebeingadded to set up a new branch for your task
<br>git switch featurebeingadded to select your new branch
<br>Add the code
<br>Review the new code using VSCode, staging parts that are confirmed to work
<br>Commit the code (via Code or terminal)
<br>Repeat commits until done
<br>Handling review and merging. Be mindful of local and remote branch states for this!<br>
<br>Test and review your  code! Make sure it works in the final state.
<br>git fetch to ensure your git repo is aware of any changes.
<br>git merge origin/main --no-commit -&gt; Bring in all new changes
<br>Fix, test, review your code with all the new base project code.
<br>git commit to finalize the merge.
<br>git push to push your branch with the merge completed.
<br>Work with your maintainer (a mentor or veteran) to pull your new, validated changes back into main! 
<br><br>Branches are best when they're small, focused, and well defined. <br>A great workflow is using so called "topic branches" or "feature branches": In this workflow, a branch represents a feature you're adding, or a bug you're fixing. Once the feature is added and working, the branch is Done. You merge your branch back into the Main branch, and you can move onto another feature in a new branch!<br>By doing this, you keep each branch simple, easy to test, and easy to merge. It also helps prevent the issue of long-running branches; Where your code is isolated from a long time, and drifts apart from everyone else's code in main. That ends up with you not working on quite the same code base as other people, and you'll miss out on features, fixes that everyone else has, and they'll miss out on yours. <br>A good feature branch name also helps keep you as a programmer constrained to the task at hand.<br><br>To facilitate "feature branch" convention, name your branches after feature itself, rather than the part of code it's affecting. Make sure that the branch name implies an "end state" at which point you can consider it Done and stop working on it. <br>As an example, some good initial branch names are add-far-shots, add-climb-routine, or fix-intake-stalling-issue. Since we're usually adding or fixing things, we can often omit that in the actual name leaving us with far-shots, climb-routine, intake-stall-issue), but it's helpful to always pretend it's there unless a clearer verb exists (like remove or adjust. <br>Early on, you might be tempted to name your branches after robot systems, like intake, shooter, or the like. But don't do this! The intake will always exist on the robot, so your branch has no clear end state!<br>
Instead, name it something like  intake-bringup. This provides an end-condition: Once the intake is brought up, functioning, and tested, the branch is done, and you can merge it back into main. <br>In some cases, it's helpful to indicate which part of the robot you're working on though: The optimal method is using subsystemname/feature. This is especially true of features relevant to various subsystems like bringup, which just yields intake/bringup, elevator/bringup, etc. <br><br>Merging is more useful than just sending your changes back to Main. You can use merging to keep up with other features that interact with the code you're working with.<br>As an example, let's say you're trying to bring up an Indexer system, which interacts with a Intake and a Shooter. During early development, you might see some branches like this<br><br>Intake and Shooter aren't done enough to merge back into main, but the indexer can't really be tested because you need to move it through the intake and shooter. But, you also don't want to actually do all that work yourself. <br>So, just merge the intake/bringup and shooter/bringup branches! <br><br>There you go! Now you can continue your work, using the preliminary work from the other branches. As they adjust and fix things, you can merge their code, and they could also merge yours into their branches before finally verifying 2 or 3 of these subsystems work properly.<br>There's a catch here: The branches in question might not be fully ready for you to pull them! It's always a good idea to talk to whoever's working on that code to make sure that it's in a state that's good to go. Sometimes they'll just need to adjust up one or two things, fix a variable/method name, or other times they might suggest you wait for some bigger cleanup or process fixes.<br><br>Similar in concept to the above in some ways! By our process definitions, Main should always be in a good state, meaning you can pull it at any time. So, before declaring your branch Done and getting it in Main, go ahead and pull Main and test things first!<br><br>Now you can test the indexer in the full codebase without any risk of accidentally putting a bug in main, and any adjustments are part of the indexer/bringup branch like shown here<br><br>At long last, with everything fully integrated, we can finally get our changes back into main, knowing with confidence it works as expected.<br>]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/git-basics.html</link><guid isPermaLink="false">Misc/Git Basics.md</guid><pubDate>Sun, 24 Aug 2025 00:00:53 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/git-graph-commit-history.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/git-graph-commit-history.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Optionals]]></title><description><![CDATA[ 
 <br>Optionals are used to represent data that may or may not exist, and does so in a consistent, type safe way. This is often a convenient way to package data from sensors without extra functions involved. <br>Let's look at a simple sensor example<br>    VisionSystem vision = new Vision();
    var distance = vision.getDistanceToTarget();
    if(distance&lt;5){
	    //Do something
    }else{
	    //Do something else
    }
<br>The problem is that what if a target does not exist? What happens when you call vision.getDistanceToTarget() anyway? What should that function return when data is invalid?<br>One option, common in java, is to return null. Unfortunately, null is not part of the type system, and Java will not tell you when something could be null, and when performing basically any object on a null... your code crashes. As a result, we never return a null from our functions. <br>So, now we have to figure out what getDistanceToTarget() should return when called on invalid data. Should it return -1? 0? Arbitrarily large value? The last valid value? What if there was no prior valid value? There's no really good answer; Any of these return schemes require special handling, and likely will cause bugs somewhere<br>Optionals provide the answer here. This is an explicit, type controlled way to say "Hey, this data may not be valid", and provides helper functions to deal with it. <br>public VisionSystem(){
    public Optional&lt;double&gt; getDistanceToTarget(){
        if(/*target exists*/) return Optional.of(1.4);
        else( Optional.empty());
    }
}
<br>    VisionSystem vision = new Vision;
	
	//Var is an Optional that may contain a double
    var target = vision.getDistanceToTarget();
    //First, check to see if the optional contains data
    if(target.isPresent()){
	    //And, we can read it!
        target.get() //do something with the contained value
    }
    else{
        //do something else
    }
<br>Cool! We're using optionals. While we solved the above issues, so far, we haven't gained anything in ease or convenience. Rather, we've just used the type system to prevent improper, unchecked code, and communicate this ambiguity. <br>But now we can deploy helper functions to simplify things based on our needs. <br>target.isPresent() //true if we have a target; Maybe we don't even care about the distance. 
target.isEmpty() // true if no target

double distance = vision.getDistanceToTarget().orElseGet(0) //Assume zero if no target ; No need to explicitly check if a value exists
double distance = vision.getDistanceToTarget().orElseGet(99999) //Assume big value if no target; Again, no check needed.
<br>These extra helper functions let us assign our own defaults based on our expectations, without having to complicate the library or API.]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/optionals.html</link><guid isPermaLink="false">Misc/Optionals.md</guid><pubDate>Fri, 12 Sep 2025 21:37:19 GMT</pubDate></item><item><title><![CDATA[Threading]]></title><description><![CDATA[ 
 <br>A Future is a simplified, and much more user friendly application of threading<br><br>
<br>???
<br><br>A "thread" normally refers to a single chain of code being executed. Most code is "single threaded", meaning everything happens in order; For something to be done, it has to wait its turn.<br>With proper code setup, you can make it appear that code is doing multiple things at once. There's a few terms for this, but usually "concurrency" or "time sharing" come up here. However, you're still fundamentally waiting for other code to finish, and a slow part of code holds up everything. This might be a complex computation, or a slow IO transfer across a network or data bus.<br>
Tasks like these don't take computational time, but do take real world time in which we could be doing other things. <br>Threads, on the other hand, can utilize additional processor cores to run code completely isolated and independently. Which is where the trouble starts.<br><br>Threads come with a bit of inherent risk: Because things are happening asynchronously (as in, not in sync with each other), you can develop issues if things are not done when  you expect them to be <br>//Set up two variables
var x;
var y;
//These two tasks are slow, so make a thrad for it!
Thread.spawn(()-&gt; x=/*long computation for X*/)
Thread.spawn(()-&gt; y=/*long computation for y*/)
//Sum things up!
var z = x+y
<br>This will completely crash; It's unlikely that both threads A and B will have finished by the time the main thread tries to use their values. This example is obvious, but in practice, this can be very sneaky and difficult to pin down. <br>Keep in mind anything running a co-processor is inherently a separate thread! These are usually wrapped by helpful containers to streamline interactions, but there's times where this distinction is important.<br><br>In 2024, we had code managing Limelight data, which would <br>
<br>Check tv, the target valid data: This value means everything else is valid
<br>Get tx and ty, along with getBotPose
<br>Try to computer our pose
<br>.... and data is wrong?
<br>What happened was simply that in some cases, after checking tv to assert valid data, the data changed, causing our calculations to break. The remote system (effectively a different thread) changed the data underneath us.<br>In some cases, we'd get values that should be valid, but instead they resulted in crashes. <br><br>There's lots of strategies to manage threads, most with notable downsides. <br>
<br>Avoiding threads: The easiest strategy, but you don't improve performance
<br>Mutexes: Short for "mutually exclusive", and represents a lock. When using data shared with threads, you lock it, and unlock it when you're done. Notably, this means you spend a good amount of effort and time trying to deal with these locks, and make sure they're where they should be. 
<br>Splits and joins: If a thread ends, you don't have problems! So, you can just check a thread state and see if it's done with your value. Don't forget to restart it if needed.
<br>Message passing: Simply don't share data. Instead, just throw it in a queue, and let stuff handle it when it needs to. 
<br>There's other strategies as well, but this brings us to...<br><br>A Future combines several of those into one, very user friendly package. Conceptually, it represents a "future value" that has not yet been calculated, while actually containing the code to get that value.<br>Because it's oriented with this expectation, they're easy to think about and use. They're almost as straightforward as any other variable.<br>//create a future and pass it some work.
CompletableFuture&lt;double&gt; future = new CompletableFuture.supplyAsync( ()-&gt; {Timer.delay(5); /*some long running calculaton*/ return 4;} );
System.out.println("waiting....");
System.out.println( future.get() )
<br>That's it. For the simplicity involved, it doesn't feel like you're using threads.... but you are. Notice that waiting prints out instantly; about 5 seconds before the number, in fact.<br>Futures handle most of the "busywork" for you; Managing thread operation, checking to see if it's done, and what the return value is. The thread runs in the background, but if it's not done by the time you get to future.get(), it'll automatically stop the main thread, wait until the future thread is done, get the value, and then resume the main thread. This will demonstrate it clearly. However, if the future is done, you just race on ahead. <br>//create a future and pass it some work.
CompletableFuture&lt;double&gt; future = new CompletableFuture.supplyAsync( ()-&gt; {Timer.delay(5); /*some long running calculaton*/ return 4;} );
System.out.println("waiting....");
Timer.delay(6); // do some busywork on the main thread too
System.out.println("Done with main thread!");
System.out.println( future.get() ); //will print instantly; The thread finished during main thread's work!
<br><br>Threads would be really nice in a few places, but in particular, building autos. Autos take a very long time to build, and you have a lot of them. And you don't want them wasting time if you're not actually running an auto. <br>But remember that Futures represent a "future value", and "contain the code to build it". A Command is a future value, and has a process to build it.... so it's a perfect fit. But you also have to select one of several autos. This is easily done: <br>CompletableFuture&lt;Command&gt; selectedAutoFuture = CompletableFuture.supplyAsync(this::doNothing);
SendableChooser&lt;Supplier&lt;Command&gt;&gt; autoChooser = new SendableChooser&lt;&gt;();
<br>A full example is in <a data-href="/Programmer Guidance/auto-selection" href="https://stormbots.github.io/KnowledgeBase/Programmer Guidance/auto-selection" class="internal-link" target="_self" rel="noopener nofollow">/Programmer Guidance/auto-selection</a>, but the gist is that <br>
<br>A Future takes a Supplier&lt;Command&gt;: A function that returns a command
<br>The AutoChooser then has a list of functions that build and return an auto command. 
<br>When you change the chooser, you start a new future, and start building it. 
<br>If and when the auto process should start.... the code just waits for the process to finish as needed, and runs it. 
<br>Conveniently, you don't need to return values. You can, if needed, run the void version, using a Runnable or non-returning lambda.<br>CompletableFuture&lt;?&gt; voidedFuture = CompletableFuture.supplyAsync(()-&gt;{}); 
if(voidedFuture.isDone()) /* do a thing */ ;
<br>While not exactly the intended use case, this allows you to easily run and monitor background code without worry. <br><br>Be aware, that as with all threads you generally should not <br>
<br>Write to data accessible by other threads; You don't know when something is trying to read that value. Do writes in the main thread. 
<br>Read data being written to by other threads; This should be easy to reason about. Constants and fixed values are fine, but don't trust state variables.
<br>Additionally, Futures are most effective when your code starts a computation, and then reacts to the completion of that computation afterward. They're intended for run-once use cases. <br>For long-running background threads, you'd want to use something else better suited to it. <br><br>Psuedo-threads are "thread-like" code structures that look and feel like threads, but aren't really. <br>WPILib offers a convenient way to run psuedo-threads through the use of addPeriodic(). This registers a Runnable at a designated loop interval, but it's still within the thread safety of normal robot code. <br>For many cases, this can certain time-sensitive features, while mitigating the hazards of real threads. <br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/convenience-features/scheduling-functions.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/convenience-features/scheduling-functions.html</a><br><br>Native Java Threads are a suitable way to continuously run background tasks that need to truly operate independent of the main thread. However, any time they interface with normal threads, you expose the hazard of data races or data corruption; Effectively, data changes underneath you, causing weird numerical glitches, or outright crashes.<br>In these cases, you need to meticulously manage access to the threaded data. Java has numerous built in helpers, but there's no shortcut for responsible coding. <br><br>The easiest way is use of the synchronized keyword in java; This is a function decorator (like public or static), which declares that a function <br>private double number=0;

public synchronized double increment(){
    number+=1;
}
public synchronized double double_increment(){
    number+=2;
}
// do some threads and run our code
public periodicThreadA(){ increment(); }
public periodicThreadB(){ double_increment(); }
<br>This is it; If both A and B try to run increment simultaneously, it's thread will block until increment is accessable. Because of how we structure FRC code, this is often a perfectly suitable strategy; Any function trying to run a synchronized call has to wait until the other synchronized functions are done. <br>However, this comes with potential performance issues: The lock is actually protecting the base object (this, or the whole class object), rather than the more narrow value of number. So all synchronized objects share one mutex; Meaning if you have multiple, independently updating values, they're blocking each other needlessly. <br>We can get finer-grain control by use of structures like this: <br>private double number=0;
private Object numberLock = new Object(); 

public double increment(){
    synchronized (numberLock){
        number+=1;
    }
}

public double double_increment(){
    synchronized (numberLock){
        number+=2;
    }
}

// do some threads and run our code
public periodicThreadA(){ increment(); }
public periodicThreadB(){ double_increment(); }
<br>This structure is identical, but now we've explicitly stated the mutex; We can see it's locking on the function increment, rather than the data we care about, which is number.<br>Note that in both cases, any access to number needs to go through a synchronized item.<br>Helpfully, you can clean this up for many common cases, as shown in the following example: Any Object class (any class or data structure; effectively everything but Int, Float, and boolean), can be locked directly; Avoiding a separate mutex. However, we may want to develop a notation to demarcate thread-accessed objects like this.<br>private Pose2D currentPose = new Pose2D(); 

public double do_pose_things(){
    synchronized (currentPose){ //item can hold it's own thread mutex
        currentPose = new Pose2d();
    }
}
<br><br>Message passing is another threading technique that allows threads to interact safely. You simply take your data, and toss it to another thread, where it can pick it up as it needs to.<br>SynchronousQueue is a useful and simple case; This is a queue optimized to interface handoffs between threads. Instead of suppliers adding values indirectly, this queue allows functions to directly block until the other thread arrives with the data it wants. This is useful when one side is significantly faster than the other, making the time spent waiting non-critical. There's methods for both fast suppliers with slow consumers, and fast consumers with slow suppliers.<br>SynchronousQueue&lt;integer&gt; queue = new SynchronousQueue&lt;integer&gt;;

public void fastSupplier(){ //ran at high speeds
    int value = 0; /*some value, such as quickly running sensor read*/
    queue.offer(value); //will not block; Will simply see there's no one listening, and give up
}
public void slowConsumer(){ //ran at low speeds
    int value = queue.take(); //will block this thread, waiting until fastSupplier tries to make another offer.
    //do something with the value
}
<br>In most cases though, you want to keep track of all reported data, but the rate at which it's supplied doesn't always match the rate at which it's consumed. A good example is vision data for odometry. It might be coming in at 120FPS, or 0FPS. Even if it's coming in at the robot's 50hz, it's probably not exactly timed with the function.<br>Depending on the requirements, a ArrayBlockingQueue (First in First Out) or LinkedBlockingDeque (Last in First Out). These both have different uses, depending on the desired order.<br>ArrayBlockingQueue&lt;Pose2d&gt; queue = new ArrayBlockingQueue&lt;Pose2d&gt;();

public void VisionSupplier(){
    Optional&lt;Pose2d&gt; value = vision.getPoseFromAprilTags();
    if(value.isPresent(){
        if(queue.remainingCapacity() &lt; 1) queue.poll() // delete the oldest item if we don't have space
        queue.offer(value); //add the newest value.
    }
}

public void VisionConsumer(){ //ran at low speeds
    var value = queue.take(); //grab the oldest value from the queue or block to wait for it
    odometry.update(value);
}
<br>Message passing helps you manage big bursts of data, have threads block/wait for new data, but do introduce one problem: You have to make sure your code behaves well when your queue is full or empty. <br>In this case, it's sensible to just throw away the oldest value in our queue; We'll replace it with a more up-to-date one anyway.<br>
We also block when trying to retrieve new data. This is fine for a dedicated thread, but when ran on our main thread this would cause our bot to halt if we drive away from a vision target. In that case, we'd want to check to see if there's a value first, or use poll() which returns null instead of waiting. The java docs can help you find the desired behavior for various operations.<br>Also be wary about the default sizes: By default, both queues can be infinitely large, meaning if your supplier is faster, you'll quickly run out of memory. Setting a maximum (reasonable) size is the best course of action. ]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/threading.html</link><guid isPermaLink="false">Misc/Threading.md</guid><pubDate>Fri, 12 Sep 2025 21:45:09 GMT</pubDate></item><item><title><![CDATA[LaserCan]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:hardware" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#hardware</a> <a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:stub" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stub</a> 
 <br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:hardware" class="tag" target="_blank" rel="noopener nofollow">#hardware</a> <a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> <br><br>
<br>Connect to the LaserCan using GrappleHook
<br>Create a new Lasercan sensor subsystem
<br>Create a Trigger that returns true while an object is within X" of the sensor
]]></description><link>https://stormbots.github.io/KnowledgeBase/hardware/lasercan.html</link><guid isPermaLink="false">Hardware/LaserCan.md</guid><pubDate>Sat, 02 Aug 2025 18:17:17 GMT</pubDate></item><item><title><![CDATA[Rev Hardware Client]]></title><description><![CDATA[ 
 <br><br>
<br>Run a motor using
<br>Plot the motor's position over time
<br>Configure a motor's ID and basic settings
<br>View an absolute encoder's output
<br><br><a rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/rev-hardware-client/gs/navigation" target="_blank">https://docs.revrobotics.com/rev-hardware-client/gs/navigation</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.revrobotics.com/rev-hardware-client/ion/spark-max" target="_blank">https://docs.revrobotics.com/rev-hardware-client/ion/spark-max</a><br><br>
<br>Plug in your computer into any available Spark controller. The one you're interested is easier.
<br>If you don't see anything useful, click "Scan For Devices" down in the bottom left
<br>You should see one (or more!) devices in the left side.
<br>Select the device that looks like your motor
<br>Click the "Blink" button, and look at your physical hardware. The light should be flickering
<br>If not, repeat this process until you find it.
<br>You can see the Device ID in the device settings, and put that in your code. 
<br><br>Config import warning!
Watch your imports when setting up Spark Configs. If you're not mindful, VSCode will pull in<br>
import com.revrobotics.servohub.ServoHub.ResetMode;<br>
instead of the desired<br>
import com.revrobotics.spark.SparkBase.ResetMode;<br>
This shows up as a error on your line for<br>
motor.config(....);
<br><br>motor.configure(
	config, 
	//This determines if we reset all existing parameters. 
	//Generally, we always want this on initialization, and then 
	//Manually set the values we expect to see for the robot.
	//The typical case for kNoResetSafeParameters is when we
	//change configuration after bootup. Changing Coast/Brake mode
	//is a common example.
	ResetMode.kResetSafeParameters, 
	
	//This option determines whether this config's settings
	//are saved on the Spark when it reboots.
	//In most cases, this doesn't matter, since the robot code
	//and Spark usually boot at the same time. However, in competition,
	//there's cases where a spark might lose power and reboot by itself!
	//Because of this, you usually want to set it to kPersistParameters,
	//but there's certain cases where kNoPersistParameters is preferable,
	//typically when it relates to increasing output power after validating
	//the system state.
	PersistMode.kPersistParameters
);
]]></description><link>https://stormbots.github.io/KnowledgeBase/hardware/rev-hardware-client.html</link><guid isPermaLink="false">Hardware/Rev Hardware Client.md</guid><pubDate>Thu, 07 Aug 2025 05:27:12 GMT</pubDate></item><item><title><![CDATA[State Machines]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Sensing Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Sensing Basics</a><br><br>
<br>
??? 

<br>
Covering system "state" is very useful, especially in subsystems

<br>
ConditionalCommand + SelectCommand can be useful for attributing actions and states on simple systems

<br>
Need to find a sensible formal way to cover it; It's easy to make "custom" state machines for simple systems, but hard to scale up in complexity with consistent patterns.

<br><br>
<br>States of Unloaded, unaligned, loaded, scoring
<br>Consideration: Explain state machines here, as an explanation of how they're used and what they represent<br>Actually make it a workshop later.<br><br>This example demonstrates a small video game character and how you might handle their Jump logic<br>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/state-machines.html</link><guid isPermaLink="false">Level 1/State Machines.md</guid><pubDate>Sun, 03 Aug 2025 00:28:58 GMT</pubDate></item><item><title><![CDATA[Factor Label]]></title><description><![CDATA[ 
 <br>Factor Label is an analytic of using units to help guide conversion between different unit types. <br><br>First, just start with your initial units. In this example, let's start with 1 day, and try to get to seconds. <br><br>We multiply by 24 hours per day:<br><br>Here we cancel out the unit "day", so we cancel it out, leaving us with a unit of Hours. But that's not seconds, so let's keep going.<br><br><br>Awesome! We've now cancelled out all our units except the intended ones, and we just have a lot of numbers left over. Let's actually crunch the numbers and figure this out:<br>
a helpful property comes from doing PEMDAS too: You can just multiply out the top, and divide out by the bottom. This is not helpful for code (you lose the relationships), but saves a lot of hassle if you're plugging things into calculators!<br>
<br><br>We'll have a lot of conversions and transformations between units in our code! This includes motor rotation -&gt; other real world units, converting between unit types or proportions. If there's a conversion between A-&gt;B then this can be helpful. Arbitrary units like "input rotation" and "output rotation" are common ones, as is things like Gear A-&gt;Gear B.<br>The important part of Factor Label is that by being able to step through the dimensions, you can easily catch several common errors, such as multiplying instead of dividing, or having a "1/unit" error. <br><br><br><br>Let's assume we tried the above computation, and got the gearing and wheel conversions backwards.  <br><br>If we do our unit analysis,,,,<br><br>We can clearly see it's not right. Bug caught!]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/factor-label.html</link><guid isPermaLink="false">Misc/Factor Label.md</guid><pubDate>Sat, 02 Aug 2025 18:15:05 GMT</pubDate></item><item><title><![CDATA[Contributing]]></title><description><![CDATA[ 
 <br><br><br>Documents should generally be structured with the consideration that they're a small part of a whole; Each document is a little workshop, and intended to both provide some education, and provide a small task for the reader. <br>Every document will likely be first encountered through the skill trees, so making sure that the first few lines are useful in the progression context will help those skill trees read better. <br>Document Title - 
A short synopsis or summary helping clarify the topic for at-a-glance reminders on the skill tree.


<br>Checkbox list of items that individually demonstrate a partial understanding of the document's goals
<br>Items can be breadcrumbs of smaller steps toward the larger goal, in cases where reader background might not make it obvious otherwise
<br>Items can also be generic requests to handle something a particular way, if the way to do so should be well understood
<br>Items can also simply request variations


A summary of what this the reader should understand after understanding the article's success criteria. This is not always required, but can be useful for more abstract or difficult topics.

Currently, no additional guidelines exist. Just add things
<br><br>The core details we want to document:<br>
<br>What something is
<br>How it works
<br>Why we want to use it
<br>When to use it
<br>Where it goes in your code
<br>When writing documentation, follow the graphs! You can expect that your reader has <br>
<br>Understood all documents leading up to this one
<br>Not read documents after this one.<br>
If you're trying to write documentation and find that you cannot follow the graph, start a discussion about it. It may help to break up the topic at hand, or adjust the graph to better suit it. 
<br>Good things to document<br>
<br>Hard earned lessons, especially if they're non-obvious when understanding a topic. A good example is that feed-forwards make PIDs much easier to work with, even if they're not required for systems to work.   
<br>Custom idioms that we as a team like to use, or alterations to the existing documentation. 
<br>Documenting the "why" is often forgotten, but very valuable. 
<br>Documentation considerations: <br>
<br>If there's good existing documentation, consider just linking it and building on top of it! This is especially true of concepts at [docs.wpilib.org]. This means we can provide guidance and workflow, without having additional upkeep on our own documentation. 
<br>However, consider offline use and reader flow. If something is quick and easy to explain, and unlikely to change season to season, it's may be worth adding just to make things easy. 
<br>Avoid duplicating information in multiple documents here. If we explain it elsewhere, just link to it. This prevents conflicting information and excessive work maintaining the notebook. 
<br>
<br><br><br>Some of the basic markdown features are critical to being effective in adding and extending the notebook:<br>
<a rel="noopener nofollow" class="external-link" href="https://help.obsidian.md/syntax" target="_blank">https://help.obsidian.md/syntax</a><br>On occasion, we'll need other stuff from here:  <a rel="noopener nofollow" class="external-link" href="https://help.obsidian.md/advanced-syntax" target="_blank">https://help.obsidian.md/advanced-syntax</a><br><br>We can embed pictures! Drag and drop or copy and paste is probably the easiest way.<br>
When doing so, it'll default to storing the file in the project root directly. In general, just shove pictures in the assets/ folder so they're out of the way. Renaming them to be vaguely descriptive is recommended though. <br><br>A callout is a useful structure for little inline sidebars with various appearances<br>
<a rel="noopener nofollow" class="external-link" href="https://help.obsidian.md/callouts" target="_blank">https://help.obsidian.md/callouts</a><br>Info
This is what a callout looks like
<br>Caution
Use caution and warn callouts when something is easy to get wrong and result in surprises.<br>
If something going wrong provides a safety risk, consider the danger tag.
<br>Bug
Bug-type callout. Useful for indicating when something is actively broken, or works unexpectedly
<br><br>Basic table format is <br>|col name 1| colname 2| etc |
|----------|----------|-----|
| row one  | stuff    |     |
<br>But you'll probably just want to use CTRL+P and select Insert Table<br>This use a plugin to enable excel-like math operations should it prove useful for helping in explaining concepts.<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/klaudyu/CalcCraft" target="_blank">https://github.com/klaudyu/CalcCraft</a><br><br>note: these are only evaluated in "reader" mode (click the book icon on the top right of this page window)<br><br>Beyond the Canvas utilities, you can embed a variety of diagrams generated by Mermaid. This utility can assist in learning and configuring diagrams efficiently.<br>
<a rel="noopener nofollow" class="external-link" href="https://mermaid.live/edit" target="_blank">https://mermaid.live/edit</a><br><br>If you forget how to set up some syntax detail, just select some text, and hit CTRL+P to open the command bar. Enter whatever it is you're after, and obsidian will help you out. <br>When all else fails, just write it! We can always tidy up later. <br><br><br>For early learning plans, "where to put code" is a notable struggle for students. To facilitate getting things in the right place, a document should always provide context in the form of <br>
<br>The file being referenced 
<br>The class being referenced
<br>The method you're working in
<br>a comment indicating nearby code, or code omitted within the relevant code block.<br>
This will help new coders navigate to the right place.<br>
New coders will have a tendency to copy and paste chunks of code, so indicating that you expect code to be present but isn't relevant will help curb copy-&gt;paste tendencies without forcing every example to be a complete, functional file.
<br>For example, if adding a method, this should be sufficient<br>//ExampleSubsystem.java
public class ExampleSubsystem extends SubsystemBase(){
	// ... other code here ...
	
	public Command doAFlip(){
		return Commands.idle(this);
	}
}
<br>If you're working within existing commands like a constructor, it's helpful to reference the example code. This helps indicate if the new code should go before or after existing stuff, which often makes a difference, depending on what you're looking to do.<br>//ExampleSubsystem.java
public class ExampleSubsystem extends SubsystemBase(){
	SparkMax motor = new SparkMax(10,kBrushless);
	// ... other code here ...
	public ExampleSubsystem(){
		var config = new SparkBaseConfig();
		//Change the config file as needed here
		motor.config(config);
		// ... other code here ...
	}
}
<br>Whenever possible, try to make sure early examples would compile if copy-pasted into files, assuming the "other code" hints are given proper attention.<br>Early, generic code examples should aim to utilize ExampleSubsystem as the default code container, and in particular ExampleSubsystem's Periodic function to generate simple code output and execution. This allows many code to run in a stock Command Robot template with no additional configuration, while avoiding teaching bad habits such as working inside Robot.java, or complex command/defaults to make code run in RobotContainer.java.<br><br>Once students should be expected to have gone through <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> and <a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> , examples can use free-form custom classes and files to suit the topic. In general, they should aim to either<br>
<br>Build off the previous concepts/code examples with similar, simple naming schemes
<br>Work from a blank slate in a new file<br>
in a manner that provides the clearest examples with least amount of duplication. Advanced users will not be copy-pasting large chunks of code, allowing a bit more freedom to streamline unnecessary code
<br>For more experienced concepts, referencing existing, irrelevant code  is less critical, since students will understand the placement, and are less likely to copy-paste over existing code. However, relevant code should still be referenced, but you can simplify much of it with a comment.<br>For example, an example adding a  "setPosition" function that references an existing motor might look this, referencing only the objects needed, even though the file likely has a lot more going on. Similarly, the filenames for advanced users can be inferred by the base class name, unless you're doing something unusual.<br>public class ExampleSubsystem extends SubsystemBase(){
	SparkMax motor = // exists

	public ExampleSubsystem(){
		var config = /* Existing config stuff*/
		config.getClosedLoopController().p(1);
		motor.config(config);
	}

	Command setPosition(double setpoint){
		run(()-&gt;motor.setReference(setpoint,kPosition));
	}
}
<br>This should facilitate students building a single project from start to finish, and including increasingly more complex code snippets and concepts without having to write them all in every example.]]></description><link>https://stormbots.github.io/KnowledgeBase/contributing.html</link><guid isPermaLink="false">CONTRIBUTING.md</guid><pubDate>Thu, 31 Jul 2025 22:01:42 GMT</pubDate></item><item><title><![CDATA[Safety]]></title><description><![CDATA[ 
 <br><br>FRC robots, fundamentally, are fast, powerful machines that are built with insufficient time, by students of mixed experience. Which is to say, even at their their best, there's potential for a lot of things to go wrong.<br>Being safe around the bot doesn't just involve preparing for likely faults, but always acting on could possibly go wrong.<br><br>While there's a few safety concerns when the robot is powered up, the majority of programmer work and concern <br>
<br>HANDS OUT. The robot should never be enabled while people are actively engaging with the robot.
<br>Watch the space: Be aware of the robot's travel potential and work envelope
<br>Be assertive: While you own the robot, you own the space around the robot.
<br><br>
<br>Operator : The person in charge of the bot at any given time
<br>Driver : The person manning the controller and triggering actions
<br>Spotter: Someone who's sole responsibility is ensuring the bot is disabled in case of potential harm or unexpected events.
<br>Participants : People actively engaged with the robot in some level, and paying attention to what it's doing.
<br><br>
<br>Check controller configurations for the computer, and make sure controllers are in the right ports on the driverstation
<br>Make sure you know what code is going to be running on the robot.
<br><br>
<br>Make sure you have your safety glasses on
<br>Make sure people around the robot have safety glasses on
<br>Actively check to make sure hands are clear of the robot, and people are clear of all mechanisms, including drive train.
<br>If people are working on the robot, establish functionality and ownership and make sure it's clear to enable.
<br>Make sure people around the robot are attentive to the robot.
<br>If there are inattentive people, clear them away from the robot. 
<br>Check battery voltage, and avoid running the bot battery too low
<br>Make sure controllers are clear, and no buttons/joysticks are pressed accidentally. 
<br>Make sure the enter button is easily hit to disable the robot, or a spotter is handling the enter button.
<br>Announce intent to enable the robot, by saying "ENABLING!" at a volume sufficient for anyone surrounding the robot to hear.
<br>Wait for people around the robot to acknowledge your enabling intent.
<br>Actively check to make sure your people + hands are clear of the robot again
<br>If everything is clear, you may now enable the robot.
<br><br>
<br>Shout "ENABLING!" while enabling the robot. Do it before with time to check that it was acknowledged.
<br>Surprise anyone by shouting "ENABLING!" while they're working in the robot. Anyone near the robot should know what you're doing, and that you're about to enable it, or they should not be near the robot.
<br>
<br><br>This is an additional set of procedures when testing code with high uncertainty, or with high risk in case of error. A few examples where this is needed<br>
<br>Initial subsystem bringup
<br>The build teams have had disassembled or modified the system in any way
<br>Changing sensor configurations, feedback loops, or other motion control code beyond small tuning adjustments.
<br>Changing code that handles collision constraints
<br>The bot has bugs/faults that cause loss of control at random
<br>In such cases, the following steps should be used to ensure that the robot behaves as anticipated, and brings the system<br>
<br>Dedicated a spotter. This person's sole job is watching the robot, and being ready to hit the Enter key to disable it. 
<br>The Operator's job is to announce what specific action is to be performed, and what the expected motion of the robot should be for any given test. 
<br>If the robot does anything else, the Spotter should disable the robot immediately.
<br>If the robot does anything in a way that might cause damage to itself or others, the Spotter should also disable the robot immediately.
<br>In case of a disable, the Spotter + Operator may re-negotiate the expected response of the robot robot for testing.
<br>Once code is known to work repeatedly, and under normal operating conditions, you can consider it operating in a known good state. 
<br><br>
<br>A spotter is recommended if available in general.
<br>A spotter is required when operating near other people for testing, diagnostics, or demonstration.
<br>When driving, define an area in which the bot is allowed to be. Spotters should disable the bot if leaves the area, or approaches the edge at uncontrolled speeds..
<br>
<br><br>The way your code is written, and how well it performs can contribute to the safety or danger of the robot . <br>
<br>Predictable, controlled motion is safer. 
<br>Bugs can result in unexpected motion and loss of control, causing direct damage to people or the bot. 
<br>Unexpected motion can launch game pieces or bot parts.
<br>
<br><br>Programmers also act as drivers of the robot, simulating gameplay tasks, but in different conditions.<br>
Unlike drivers, where the tasks are performed in an open field, programmers are often running it in smaller spaces, with less physical spacing, and may have people assisting within close contact of the bot. <br>This brings in several other key concerns such as <br>
<br>Knowing the controllers and actions, at least to the degree you can safely operate the robot in the state you're testing in. 
<br>Unplugging controllers that are not relevant to your testing to avoid accidental presses or motion.
<br>Good communication with your teammates 
<br>Paying close attention to speed, and making sure to retain control
<br>Paying close attention to the robot Enable state.
<br>Paying close attention to which code version is running.
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-0/safety.html</link><guid isPermaLink="false">Level 0/Safety.md</guid><pubDate>Wed, 09 Jul 2025 19:51:59 GMT</pubDate></item><item><title><![CDATA[Physics Simulation]]></title><description><![CDATA[ 
 <br><br>
<br>Create a standard Arm or Elevator
<br>Model the system as a Mechanism2D
<br>Create a Physics model class
<br>Configure the physics model
<br>Tune the model to react in a sensible way. It does not need to match a real world model
<br><br><a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/autonomous-programming/504795/18?u=tekdemo" target="_blank">https://www.chiefdelphi.com/t/autonomous-programming/504795/18?u=tekdemo</a><br><img alt="moment-of-inertia-equations.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/moment-of-inertia-equations.png">]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/physics-simulation.html</link><guid isPermaLink="false">Level 2/Physics Simulation.md</guid><pubDate>Thu, 31 Jul 2025 05:32:02 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/moment-of-inertia-equations.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/moment-of-inertia-equations.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PathPlanning Tools]]></title><description><![CDATA[ 
 <br><br>
<br>Choose a PathPlanning tool
<br>Implement the Java framework for the selected tool
<br>Model the robot's physical parameters for your tool
<br>Drive a robot along a target trajectory using one of these tools
<br>Followup to:<br>
<a data-href="Auto Differential" href="https://stormbots.github.io/KnowledgeBase/level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Swerve Motion" href="https://stormbots.github.io/KnowledgeBase/level-2/swerve-motion.html" class="internal-link" target="_self" rel="noopener nofollow">Swerve Motion</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/index.html</a><br>
<a rel="noopener nofollow" class="external-link" href="https://choreo.autos/" target="_blank">https://choreo.autos/</a><br>
<a rel="noopener nofollow" class="external-link" href="https://pathplanner.dev/home.html" target="_blank">https://pathplanner.dev/home.html</a><br><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html" target="_blank">https://docs.wpilib.org/en/stable/docs/software/pathplanning/trajectory-tutorial/trajectory-tutorial-overview.html</a><br><br>Do you need path planning to make great autos? Maybe! But not always.<br>PathPlanning can give you extremely fast, optimized autos, allowing you to squeeze every fraction of a second from your auto. However, it can be challenging to set up, and has a long list of requirements to get even moderate performance.<br><br><br>Unlike "path planning" algorithms that attempt to define and predict robot motion, Pure Pursuit simply acts as a reactive path follower, as the name somewhat implies.<br><a rel="noopener nofollow" class="external-link" href="https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html" target="_blank">https://www.mathworks.com/help/nav/ug/pure-pursuit-controller.html</a><br><a rel="noopener nofollow" class="external-link" href="https://wiki.purduesigbots.com/software/control-algorithms/basic-pure-pursuit" target="_blank">https://wiki.purduesigbots.com/software/control-algorithms/basic-pure-pursuit</a><br><img alt="pathfinding-pure-pursuit.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/pathfinding-pure-pursuit.png"><br>This algorithm is fairly simple and conceptually straightforward, but with some notable limitations. However, the concept is very useful for advancing simpler autos<br><br><a rel="noopener nofollow" class="external-link" href="https://therekrab.github.io/autopilot/technical.html" target="_blank">https://therekrab.github.io/autopilot/technical.html</a><br>
<a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/introducing-autopilot-a-novel-solution-to-holonomic-motion-control/504244/21" target="_blank">https://www.chiefdelphi.com/t/introducing-autopilot-a-novel-solution-to-holonomic-motion-control/504244/21</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/pathplanning-tools.html</link><guid isPermaLink="false">Misc/PathPlanning Tools.md</guid><pubDate>Wed, 30 Jul 2025 21:54:15 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/pathfinding-pure-pursuit.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/pathfinding-pure-pursuit.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Sensing Basics]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Triggers" href="https://stormbots.github.io/KnowledgeBase/level-1/triggers.html" class="internal-link" target="_self" rel="noopener nofollow">Triggers</a><br>Hardware: <br>
<br>Switches
<br>Encoder
<br>LaserCan
<br><br>
<br>Create a Trigger that represents a sensor condition
<br>Create a Joystick command that runs indefinitely, but stops when the Trigger is in a true condition. 
<br>Repeat with a different sensor type
<br>Create a Trigger that performs a Command automatically when triggered
<br><br>Sensing is interacting with physical objects, and changing robot behaviour based on it.<br>
This can use a variety of sensors and methods, and will change from system to system<br><br>Often simple sensors like break beams or switches can tell you something very useful about the system state, which can help you set up a different, more precise sensor. <br>The most common application is in <a data-tooltip-position="top" aria-label="Homing Sequences" data-href="Homing Sequences" href="https://stormbots.github.io/KnowledgeBase/level-1/homing-sequences.html" class="internal-link" target="_self" rel="noopener nofollow">Homing</a> such as a <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> type systems. On boot, your your <a data-tooltip-position="top" aria-label="Encoder Basics" data-href="Encoder Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/encoder-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Encoder</a> may not properly reflect the system state, and thus the elevator position is invalid. But, if you you have a switch at the end of travel you can use this to re-initialize your encoder, as the simple switch.]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/sensing-basics.html</link><guid isPermaLink="false">Level 1/Sensing Basics.md</guid><pubDate>Sun, 29 Jun 2025 20:59:07 GMT</pubDate></item><item><title><![CDATA[Superstructure Indexer]]></title><description><![CDATA[ 
 <br><br>Superstructure component that adds additional control axes between intakes and scoring mechanisms. In practice, indexers often temporarily act as part of those systems at different points in time, as well performing it's own specialized tasks.<br> Common when handling multiple game pieces for storage and alignment, game pieces require re-orientation, adjustment or temporary storage, and for flywheel systems which need to isolate game piece motion from spinup.<br><br>
<br>???
<br><br>Setting up an indexer is often a challenging process. It will naturally inherit several design goals and challenges from the systems it's connected to. This means it will often have a more complex API than most systems, often adopting notation from the connected systems. <br>The Indexer is often sensitive to hardware design quirks and changes from those adjacent systems, which can change their behavior, and thus the interfacing code. <br>Additionally, game piece handoffs can be mechanically complex, and imperfect. Often Indexers absorb special handling and fault detection, or at least bring such issues to light. Nominally, any such quirks are identified and hardware solutions implemented, or additional sensing is provided to facilitate code resolutions.<br><br>Indexers typically require some specific information about the system state, and tend to be a place where some sort of sensor ends up as a core operational component. The exact type and placement can vary by archtype, but often involve <br>
<br>Break beam sensors: These provide a non-contact, robust way to check game piece 
<br>Current/speed sensing: Many game pieces can be felt by the 
<br>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html</link><guid isPermaLink="false">Level 2/Superstructure Indexer.md</guid><pubDate>Sun, 29 Jun 2025 20:36:30 GMT</pubDate></item><item><title><![CDATA[Coding Basics]]></title><description><![CDATA[<a class="tag" href="https://stormbots.github.io/KnowledgeBase/?query=tag:stub" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stub</a> 
 <br><a href="https://stormbots.github.io/KnowledgeBase?query=tag:stub" class="tag" target="_blank" rel="noopener nofollow">#stub</a> <br><br>
<br>variables
<br>classes
<br>Functions
<br>"structs" or data classes
<br>Introduce enums (don't need to impliment)
<br>Explaining inherited classes as interfaces (because we deal with them).
<br>"null" objects -&gt; initialization (mostly avoided by minimizing indefinite declarations)
<br><br>
<br>Complex stuff involving inheritence or extending classes. Aside from creating new commands or triggers (which mostly act as an interface), we don't do anything with this, and the few places we could it creates confusion because of hidden, unexpected behaviors.
<br>Implimenting/using Arrays/Lists: Not especially common in simpler tasks, and java makes interacting messy. Handle as needed later.
<br>Error handling. Super gross in java, and we mostly need basics. Cover if necessary (mostly Lasercan), but prefer converting errors to Optionals and doing type checking instead of bubbling up (which lasercan also does).
<br><br>
<br>
Teach the "command/robotcontainer/subsystem" model early. If you do a ton of bot development before getting to "typical bot structure", code structure becomes a mess and it becomes harder to use any advanced features and reason through more complex tasks. It also gets the wrong habits engrained, which becomes an unlearning process later. It's OK to say "We'll get into the details of why this is" later, they'll figure things out.

<br>
Putting complex logic into a command is a great way to prototype all sorts of bot ideas, and should help them when doing "upgrades" to older code.

<br>
Consider one "trial project" for subsystems to house a single, simple system, and learn the basic java education. No need to get too deep beyond helping set up. Then, once they have it after a project or two, move into modelling "complex work" with commands.

<br>
It's helpful when "prototyping" complex things using "commands" because you can cycle through different ways of prototyping it easily by swapping out commands being selected.

<br>Subsystems

<br>Robot nouns.
<br>Containers for a single actuator or "resource"
<br>Allows "locks" and requires
<br>Organized place to keep associated code.


<br>Commands

<br>The robot "verbs", and actions systems can take.
<br>Can be basic and stil be useful when decorated
<br>Typical commands shouldn't end; Decorate or make shortcuts for ones that do




]]></description><link>https://stormbots.github.io/KnowledgeBase/level-0/coding-basics.html</link><guid isPermaLink="false">Level 0/Coding Basics.md</guid><pubDate>Sat, 28 Jun 2025 19:06:48 GMT</pubDate></item><item><title><![CDATA[Auto Differential]]></title><description><![CDATA[ 
 <br><br>
<br>Create a simple autonomous that drives forward and stops
<br>Create a two-step autonomous that drives forward and backward
<br>Create a four step autonomous that drives forward, runs a mock "place object" command, backs up, then turns around.
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/auto-differential.html</link><guid isPermaLink="false">Level 1/Auto Differential.md</guid><pubDate>Sat, 28 Jun 2025 19:17:54 GMT</pubDate></item><item><title><![CDATA[Differential Drive]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a><br>
<a data-href="Motor Control" href="https://stormbots.github.io/KnowledgeBase/level-1/motor-control.html" class="internal-link" target="_self" rel="noopener nofollow">Motor Control</a><br><br>
<br>Create a Differential Drivetrain
<br>Configure a Command to operate the drive using joysticks
<br>??? Add rate limiting to joysticks to make the system control better 
<br>??? Add  constraints to rotation to make robot drive better
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/differential-drive.html</link><guid isPermaLink="false">Level 1/Differential Drive.md</guid><pubDate>Sat, 28 Jun 2025 19:18:40 GMT</pubDate></item><item><title><![CDATA[Gyro Driving]]></title><description><![CDATA[ 
 <br>Requires<br>
<a data-href="Auto Differential" href="https://stormbots.github.io/KnowledgeBase/level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Gyro Sensing" href="https://stormbots.github.io/KnowledgeBase/level-1/gyro-sensing.html" class="internal-link" target="_self" rel="noopener nofollow">Gyro Sensing</a><br><br>
<br>Create a button that causes the robot to face a bearing of 0 degrees
<br>Create 3 additional buttons to face 90, 180, and 270. 
<br>Ensure that the drivers can hold those buttons and use the throttle to drive in the indicated direction
<br>Create an 4 step auto that traverses a predefined path using gyro headings and encoder distances
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/gyro-driving.html</link><guid isPermaLink="false">Level 1/Gyro Driving.md</guid><pubDate>Sat, 28 Jun 2025 19:19:00 GMT</pubDate></item><item><title><![CDATA[Gyro Sensing]]></title><description><![CDATA[ 
 <br><br>
<br>
Configure a NavX or gyro on the robot

<br>
Find a way to zero the sensor when the robot is enabled in auto

<br>
Create a command that tells you when the robot is pointed the same way as when it started

<br>
Print the difference between the robot's starting angle and current angle

<br>
TODO

<br>
what's an mxp

<br>
what port/interface to use, usb

<br>
which axis are you reading

<br>
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/gyro-sensing.html</link><guid isPermaLink="false">Level 1/Gyro Sensing.md</guid><pubDate>Sat, 28 Jun 2025 19:19:08 GMT</pubDate></item><item><title><![CDATA[Limelight Assist Driving]]></title><description><![CDATA[ 
 <br>requires<br>
<a data-href="Auto Differential" href="https://stormbots.github.io/KnowledgeBase/level-1/auto-differential.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Differential</a><br>
<a data-href="Limelight Basics" href="https://stormbots.github.io/KnowledgeBase/level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight Basics</a><br><br>
<br>Create a button that aims your chassis at a target
<br>Ensure the above button allows drivers to move toward and away from target while it's held
<br>Create a pipeline that allows you to drive to the left/right of the target instead of directly at it
<br>Create a button that aligns you with a game piece, and allows drivers to drive at it
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/limelight-assist-driving.html</link><guid isPermaLink="false">Level 1/Limelight Assist Driving.md</guid><pubDate>Sat, 28 Jun 2025 19:23:36 GMT</pubDate></item><item><title><![CDATA[SuperStructure Arm]]></title><description><![CDATA[ 
 <br>Requires:<br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br>
<a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a><br><br>
<br>Create an Arm subsystem
<br>Set Encoders

<br>find the encoder range and conversion to have real-world angle values
<br>Find the system range, apply soft limits


<br>Get control

<br>Determine the system Gravity feed-forward value
<br>Create a PID controller
<br>Tune the PID to an acceptable level for control


<br>Create a default command that holds the system at the current angle
<br>Create a setAngle function that takes a angle, and returns a command that runs indefinitely to the target angle
<br>Create a Trigger that indicates if the system is within a suitable tolerance of the commanded height.
<br>Bind several target positions to a controller
<br>Create a small auto sequence that moves to multiple positions in sequence.
]]></description><link>https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html</link><guid isPermaLink="false">Level 1/SuperStructure Arm.md</guid><pubDate>Sat, 28 Jun 2025 19:27:04 GMT</pubDate></item><item><title><![CDATA[Singletons]]></title><description><![CDATA[ 
 <br><br>
<br>Create a Singleton class
<br>Use it in multiple places in your code
<br><br>Singletons are a coding structure (or "pattern") that represents a unique entity. It's designed to allow one, and only one instance of a class.<br>This tends to be useful for controlling access to unique items like physical hardware, IO channels, and other such items. <br>The techniques used in this pattern are also helpful for cases where you might be fine with multiple instances, but you need to restrict the total number, or keep track in some way.<br><br>public ExampleSingleton{
    private static ExampleSingleton instance;

	//note private constructor
    private ExampleSingleton(){}
    
    public static ExampleSingleton getInstance(){
        //Check to see if we have an instance; If not, create it. 
        if(instance==null) instance = new ExampleSingleton();
        //If so, return it. 
        return instance;
    }
    
	// Methods just work normally.
	public double exampleMethod(){
        return 0; 
    }
}
<br>There's a few key details here: <br>
<br>private ExampleSingleton(){} The constructor is private, meaning you cannot create objects using new ExampleSingleton(). If you could do that, then you would create a second instance of the class! So, this is private, meaning only an instance of the class itself can create an instance.
<br>public static ExampleSingleton getInstance() ; This does the heavy lifting: It sees if we have an instance, and if not, it actually creates one. If we have an instance, it just returns a reference to it. This is how we ensure we only ever create one instance of the class. This is static, which allows us to call it on the base class (since we won't have an instance until we do).
<br>private static ExampleSingleton instance; This is the reference for the created instance. Notice that it's static, meaning that the instance is "owned" by the base class itself. 
<br><br>public ExampleSensorSystem{
    private static ExampleSensorSystem instance;
    
    //Example object representing a physical object, belonging to
    //an instance of this class.
    //If we create more than one, our code will crash!
    //Fortunately, singletons prevent this. 
    private Ultrasonic sensor = new Ultrasonic(0,1);

    private ExampleSensorSystem(){} //note private constructor
    
    public static ExampleSensorSystem getInstance(){
        //Check to see if we have an instance; If not, create it. 
        if(instance==null) instance = new ExampleSensorSystem();
        //If so, return it. 
        return instance;
    }
    
    public double getDistance(){
        return sensor.getRangeInches();
    }
}
<br>Elsewhere, these are all valid ways to interface with this sensor, and get the data we need<br>ExampleSensorSystem.getInstance().getDistance();


var sensor = ExampleSensorSystem.getInstance();
// do other things
sensor.getDistance();
<br><br>Rarely is often the right answer. While Singletons are useful in streamlining code in some circumstances, they also can obscure where you use it, and how you're using it. Here's the general considerations<br>
<br>You have something that is necessarily "unique"
<br>It will be accessed by several other classes, or have complicated scope.
<br>it is immutable: Once created, it won't be changed, altered or re-configured.
<br>You will not have any code re-use
<br>In cases where it's less obvious, the "dependency injection" pattern makes more sense. You'll see the Dependency pattern used in a lot of FRC code for subsystems. Even though these are unique, they're highly mutable, and we want to track access due to the Requires and lockouts. <br>Similarly, for sensors we probably one multiple of the same type. This means if we use a Singleton, we would have to re-write the code several times! (or get creative with class abstractions). <br>Dependency Injection
This pattern consists of passing a reference to items in a direct, explicit way, like so. 
//We create an item
ExampleSubsystem example = new ExampleSubsystem();

ExampleCommand example = new ExampleCommand(exampleSubsystem);

class ExampleCommand(){
	ExampleSubsystem example;
	ExampleCommand(ExampleSubsystem example){
			this.example = example;
	}
	public void exampleMethod(){
		//has access to example subsystem
	}	
}

]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/singletons.html</link><guid isPermaLink="false">Level 2/Singletons.md</guid><pubDate>Tue, 24 Jun 2025 07:09:55 GMT</pubDate></item><item><title><![CDATA[System Identification]]></title><description><![CDATA[ 
 <br>Part of:<br>
<a data-href="SuperStructure Flywheel" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a><br>
<a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a><br><br>
<br>Write the tuning functions for a system
<br>Get the system ID values
<br>Update the system with the values
<br>


<br><br><a rel="noopener nofollow" class="external-link" href="https://www.chiefdelphi.com/t/hardware-testers-needed-optimal-pid-gain-estimation-in-recalc/503535/4" target="_blank">https://www.chiefdelphi.com/t/hardware-testers-needed-optimal-pid-gain-estimation-in-recalc/503535/4</a>]]></description><link>https://stormbots.github.io/KnowledgeBase/level-2/system-identification.html</link><guid isPermaLink="false">Level 2/System Identification.md</guid><pubDate>Sat, 28 Jun 2025 19:26:01 GMT</pubDate></item><item><title><![CDATA[clamping]]></title><description><![CDATA[ 
 ]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/clamping.html</link><guid isPermaLink="false">Misc/clamping.md</guid><pubDate>Sat, 28 Jun 2025 19:11:50 GMT</pubDate></item><item><title><![CDATA[Maintenance Checklist]]></title><description><![CDATA[ 
 <br>During competition season, things are busy. Everything is stressful, the days are long, and students and bots are put through the wringer. Students may not always be present at every critical moment, and it's both unreasonable and unwise to expect this to be the case.<br>During these times, proper upkeep of the robot is both critical and challenging. So, to ensure effective, efficient upkeep, we create a solid process to validate the bot, and prevent errors.<br><br>While everyone initially pushes back on rigid methodology here, there's a reason it's done! It's not busywork: it actually greatly simplifies and streamlines the season.<br>There's a lot of benefits to good procedure<br>
<br>Peace of mind: Everyone involved knows that whatever does goes wrong was unavoidable, as every possible preventative measure had been taken. There's no "blame" or frustration.
<br>A well documented procedure can be easily handed off to others, meaning no "critical students" get stuck not being able to take breaks when they need it.
<br>A well practiced procedure can be executed very quickly, reducing time being stuck in the pit.
<br>A well maintained bot is less likely to break.
<br>A bot that's not broken doesn't require a lot of effort to fix.
<br>A bot that's not broken is more likely to do well
<br>A bot that's doing well makes for an exciting competition experience.
<br>If you aren't convinced though, ask a build team veteran. Good upkeep is all positives. <br><br>The critical structure of robust maintenance is solid, robust checklists. These come in two major flavors<br>
<br>Documented procedures: These simply explain how to apply the checklists, expectations for the team, and special considerations that may come up. These are likely to be ordered, step by step walkthroughs.
<br>Task lists: A specific set of things to mark off. These are typically grouped rather than ordered, allowing multiple people to claim a specific group, and check items in parallel.<br>
However, these blur together very quickly, so don't get too tied up on this. 
<br>Each season will demand it's own list of various detail and size. However, year to year, there's a few evergreen lists to consider:<br>
<br>Daily upkeep: A list of items that should be checked once a day when the bot is in use. This can cover less frequent wear and tear, or more invasive, detailed inspections. 
<br>Post-Repair validation: This usually involves additional validation of the affected systems to ensure correct re-assembly, and making sure nearby systems were not affected.
<br>Pre-match validation: This list should cover any last-minute checks to ensure that the robot gets on the field in the best possible state, and make sure nothing got disrupted since the post-match checked.
<br>Post-match validation: This list should be checking for any unseen damage or major wear. Catching problems after a match ensures the greatest chance to fix potential issues before the next one. This is likely to be the biggest, most exhaustive list. 
<br>Damaged Bot process: The bot will break. When it does, having a clear path to to assess the damage, mitigate further damage, and prepare for the next match is crucial. This is likely to be the most stressful part of the day, and will put your preparation to the test. 
<br>Operation Confirmation process: This is a full system + code check, basically just doing all game tasks to the amount you can inside the pit. This ensures that mechanical aspects of the bot work, and that the code is working nominally.
<br>During practice, you generally want to consider a "match" a change of the battery. <br><br>A critical maintenance detail is that the build related teams will mark properly tightened bolts, nuts, and rivits with marks similar to the ones shown here. If the marks are mismatched, you know that it's loose and needs tightening or adjustment.<br>
This allows for rapid, precise inspection of the robot, and will be referenced several times in the checklist. <br><img alt="bolt alignment marks.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/bolt-alignment-marks.png"><br><br>Many issues are persistent across all bots; Damaged gears, loose bolts, damaged gears, cracked rollers, etc. A lot of checklist items can be started without any specialized bot-specific knowledge.<br>However, as the robot undergoes programming and drive practice, you'll notice additional wear, unexpected failure modes, and quirks. Things like unexpected contact, frame bends, or specific bolts being particularly prone to loosening. Make note of these quirks, and add them to your various checklists.<br>Whenever possible, work to design out these various failure modes. This can be as simple as changing a gear ratio, or as complex as reworking a mechanism to move motors around.<br>For items that cannot be designed out, consider the severity and frequency. If a failure mode is severe or frequent, it should go on a per-match checklist. If something minor and infrequent, just check it daily.<br><br>These lists should be living documents, reflecting the robot's current physical state. As additional failures are identified, they should be added.<br>If a design change is proven to resolve an issue, the check frequency can be reduced or even removed entirely in some cases. However, never remove an item that simply "hasn't occurred recently", unless there's been a fundamental change to the system.<br><br>General Procedures

<br>When flipping robot make sure shooter is held to prevent slamming

<br> Pre-Match Procedure

<br>Complete pre-match checklist
<br>Assign person to walk in front of cart
<br>Deliver robot to drivers
<br>Deliver driver station to drivers
<br>Report any issues or changes to drivers
<br>Return to stands unless doing ongoing repairs in pit

<br> Standard Match Procedure

<br>Watch match for potential issues
<br>If issue is detected, watch for repeatability/consistency and identify likely causes

<br>Technician Prematch Checklist
(the technician had a 5-10 item list on a lanyard, but was not recorded with the others. It mostly was validating completion of the others, and a few critical items worth having double-checked, or relating to on-field setup Robot Team could not do)

<br>Confirm checklist completion
<br>Make sure rollers are clean
<br>???

<br> Operation Confirmation Procedure
(typically handled by programmers, but anyone who knows the controller can do this)

<br>Put Robot on blocks
<br>Let climber home.
<br>Intake note
<br>Set shooter RPM + angle. Let drop. 
<br>Load Note into dunkarm.
<br>Dunkarm to speaker.
<br>Move climbers to climb position. 
<br>Dunkarm manual/trap mode up
<br>Score note.
<br>Drive forward OK
<br>Translate left OK
<br>All wheels spin all the way around

<br> Damaged Robot Post-Match Procedure

<br>Standard post-match mostly applies
<br>Make sure code changes are tested early ie: not with 5 minutes before queue
<br>Identify primary cause of failure 
<br>Identify secondary failures and additional damage caused by primary failure
<br>If needed, send person to pits to prepare equipment/spares
<br>If needed, summon assistance/specialists for damaged systems. 
<br>Repair bot
<br>Apply post-repair checklist for affected systems (if applicable)
<br>Apply robot off-field checklist
<br>2 additional people also apply post-repair + off field checklist for the system(s) for completeness.
<br>Apply operating confirmation procedure
<br>Evaluate checklist/processes: Can something be added to help prevent this failure going forward

<br><br>Robot Team Beginning of the Day Checklist
This is the time of day robot team should be working on major non critical tweaks to the function of the robot. Examples: brand new autos, new april tag stuff
Pit Setup

<br>Make sure battery cart is plugged in and batteries are charging

Frameworks

<br>Check Frame Bolts (Paint Pen Lines), starting with top and then flipping robot to check bottom
<br>Check Wheels/Tread and replace as needed
<br>Check Belly Pan Rivets
<br>Check Frame square-ness
<br>Check swerve modules for crunchyness

Functions

<br>Check Climber bearings
<br>Check Functions Bolts (Intake first, then flip robot upright and move on to shooter, then climber, and finally dunk arm), also using paint pen lines to verify tightness
<br>Check Shooter Wheels for wear
<br>Check Rollers for bends or cracks
<br>Check Belts and printed roller pulleys
<br>Check Shooter Pivot Tubes and Bolts
<br>Check Baby NEO on dunk arm (pinion engagement/slipping)
<br>Check Shooter Pivot sector gear and pinion
<br>Check Shooter pivot vp engagement

Controls

<br>Check CAN Wire Connections
<br>Check SparkMAX absolute encoder attachment
<br>Check Zip ties near Climber Hooks
<br>Check Power distribution wires/connector tightness
<br>Check Plugins to RIO

Programming

<br>Check Wheel Alignment
<br>Check Dunk Arm Soft Limits
<br>Check Note Intaking
<br>Auto Note Align Checks

<br>Robot Team Post Match Checklist
Drivetrain

<br>tread not unevenly worn or damaged
<br>Tread within wear limits
<br>swerve module mounting bolts
<br>swerve module fork bolts
<br>belly pan rivets
<br>Motor temps OK (post-match only)

Shooter Pivot

<br>Full range of motion OK
<br>Sector Gear bolts securely mounted
<br>Versa gearbox bolts securely mounted
<br>Gear meshing OK
<br>Sector gear not worn/damaged
<br>Drive gear not worn/damaged
<br>550 motor pinion transmits torque
<br>Motor temps OK (post-match only)

Flywheels

<br>Shafts not bent
<br>Wheel wear OK
<br>Bearings OK / not crunchy
<br>Bolts OK/ not backed out
<br>Free spin/friction OK

Dunk Arm

<br>Full range of motion OK
<br>Gears mesh OK and no chipped/broken teeth
<br>Chain tension OK
<br>LEDs secured OK

Dunk Arm Rollers

<br>Bearings OK
<br>Rollers OK + not cracked
<br>Rollers Cleaned
<br>550 transmitting torque OK
<br>Bolts OK
<br>Side plates not cracked or damaged
<br>Alignment belt clocked correctly

Climber

<br>Full range of motion with no binding
<br>Chain tension OK
<br>mounting rivets on the frame
<br>Mounting bolts on polycarb
<br>Polycarb hooks not damaged

Intake

<br>rollers not bent or cracked
<br>roller bolts not backed out
<br>Intake frame aligned correctly/square
<br>Intake towers bolted down completely

Passthrough

<br>rollers not bent or cracked
<br>roller bolts not backed out
<br>550 pinion OK and transmits torque

Controls

<br>Battery leads OK
<br>Spark max encoder cables checked
<br>Dunk arm + dunkarm roller
<br> Intake
<br>drivetrain
<br>Shooter + flywheels
<br>Wires near climber secured
<br>Wires on back plate secured
<br>Wires below shooter secured.
<br>Network wires OK
<br>LEDS OK

<br> Pre-match Checklist

<br>post-match checklist was completed since robot was last driven
<br>Correct battery selected
<br>Battery leads OK
<br>Battery secured correctly, leads clear of passthrough
<br>Correct bumpers secured
<br>Rollers cleaned
<br>Dunkarm
<br>Intake
<br>Passthrough
<br>Do Operation Confirmation Procedure
<br>Report unfixable problems to drive team ASAP
<br>Square placed on robot cart
<br>Drive station ready for handoff (controllers, charger, laptop)

<br>Post Repair Checklist 
Swerve Modules

<br>Rezero module offset
<br>Make sure all bolts are tight
<br>Make sure can ids are correct
<br>Make sure right gear ratio in module

Intake

<br>Run intake to test performance
<br>Make sure can ids are correct

Dunk Arm

<br>Verify end effector clocking
<br>Verify press on pinion goodness
<br>Run dunk arm to test performance
<br>Make sure can ids are correct

Shooter

<br>Run shooter to test performance
<br>Check axial shaft slop
<br>Make sure can ids are correct

Passthrough

<br>Run passthrough to test performance
<br>Make sure can ids are correct

Climber

<br>Run passthrough to test performance
<br>Make sure can ids are correct
<br>Make sure no binding on internal bearing block
<br>Make sure chain and belt are appropriately tightened

]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/maintenance-checklist.html</link><guid isPermaLink="false">Misc/Maintenance Checklist.md</guid><pubDate>Sat, 28 Jun 2025 19:08:23 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/bolt-alignment-marks.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/bolt-alignment-marks.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Mechanical Backlash]]></title><description><![CDATA[ 
 <br>Backlash refers to the small loss of mechanical control induced by small gaps in gears, belts, or other attachment points. This is also referred to as "Slop" or "play".<br>A small amount of backlash will always be present in systems. However, severe backlash can stem from poor mechanical build or design, or from excessive system wear. For systems in motion, backlash also causes significant wear, leading to even more backlash. <br><img alt="gear-backlash.gif" src="https://stormbots.github.io/KnowledgeBase/lib/media/gear-backlash.gif"><br><br>For many FRC systems, small amounts of backlash can be mostly ignored on the code side. The standard equipment and precision requirements generally handle it.<br>If backlash gets to be severe, it can start impacting the bot in different ways<br>
<br>Reduced performance and precision
<br>Increased wear + worsening backlash
<br>Increased risk of severe damage due to high forces in the gear train
<br>Difficulty in controlling systems
<br>Potential for dropped game pieces due to bouncing.
<br><br>Backlash can be built up in any system, but it's only a problem when the system changes loading directions; Either when going from accelerating and decelerating, changing directions, or colliding with the environment.<br>As such, it's mostly a concern for systems where you care about the position or precise rotation, rather than rate of motion. <br>The most notable backlash-heavy system is <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> or other pivoting systems. By their nature, these magnify the small angular difference along their length, making it far more visible. These systems also handle significant torque, resulting high wear and a mechanical challenge to minimize backlash, and have range of motions that show backlash in several different loading states.<br><img alt="backlash-arm-deviation.png" src="https://stormbots.github.io/KnowledgeBase/lib/media/backlash-arm-deviation.png"><br><a data-href="Differential Drive" href="https://stormbots.github.io/KnowledgeBase/level-1/differential-drive.html" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive</a> systems also often have notable backlash due to the heavy wear in the gearboxes. In the case where you need precision movement (mostly autos or assisted sequences), this can result in struggles. <br><a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Rollers</a> and <a data-tooltip-position="top" aria-label="Superstructure Indexer" data-href="Superstructure Indexer" href="https://stormbots.github.io/KnowledgeBase/level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Indexers</a> used for game piece alignment sometimes encounter backlash due to construction details and precision requirements. <br><br>
<br><a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="https://stormbots.github.io/KnowledgeBase/level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiling</a> helps reduce the impact of backlash by controlling and reducing the torque applied to your geartrain. This reduces wear, meaning your system is simply less prone to developing and worsening backlash.
<br><a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> by their nature do not consider the effects of backlash in their output. This does not help with precision loss, but prevents 
<br><a data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiting</a> on the output can reduce high-frequency changes to the output. This helps reduce system wear, and fixes system response to such wear.
<br><a data-tooltip-position="top" aria-label="PID" data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PIDs</a> and other <a data-tooltip-position="top" aria-label="Closed Loop Controller" data-href="Closed Loop Controller" href="https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controllers</a>, can be used to help recapture precision, but typically require measurement of the system output (height, arm rotation, etc).
<br>If this sounds suspiciously similar to "just having good motion code", you'd be correct! Good motion is robust against backlash errors, and also helps prevent it. <br><br>Mechanical Problem, mechanical solution
Like all mechanical faults, backlash is best resolved on the mechanical side at the source.<br>
Code fixes should generally aim to reduce wear caused by the small amount of unavoidable backlash.<br>
Code handling more significant backlash should be considered a temporary measure until the hardware can be fixed.
<br><br>This refers to high-speed "rattling" of the motor. This is commonly seen on systems that can rest in an "unloaded" state, when controlled by a <a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> or other <a data-href="Closed Loop Controller" href="https://stormbots.github.io/KnowledgeBase/misc/closed-loop-controller.html" class="internal-link" target="_self" rel="noopener nofollow">Closed Loop Controller</a>. It's most common on <a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Roller</a> or Drivetrain systems, but can be present on others. <br>This issue occurs because the PID will be tuned for a "loaded" condition: The controller is expecting a specific amount of resistance to motion (weight of bot, air resistance, inertia, etc). However, in the backlash region, there is effectively no resistance to motion. In this scenario, the PID is effectively "overtuned", resulting in sharp P oscillation. The greater the backlash, the more likely you are to end up with your system settling in a state that allows such oscillations.<br>The simplest resolution tends to be the application of a ClosedLoopRampRate on the Rev motor controller configuration. This applies a <a data-tooltip-position="top" aria-label="Slew Rate Limiting" data-href="Slew Rate Limiting" href="https://stormbots.github.io/KnowledgeBase/misc/slew-rate-limiting.html" class="internal-link" target="_self" rel="noopener nofollow">Slew Rate Limiter</a> on the output, which a very good job of preventing high-frequency output changes like this, without constraining typical operation.<br>It's also possible to observe this in <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> or <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> systems in some cases. Notably if the resting against a hard stop.<br><br>When an <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arm</a> or <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevator</a> visibly has significant backlash, it will often "bounce" without any effective motor control effort. This is especially visible when driving, ending a motion, or making small quick motions.<br><a data-href="FeedForwards" href="https://stormbots.github.io/KnowledgeBase/level-1/feedforwards.html" class="internal-link" target="_self" rel="noopener nofollow">FeedForwards</a> can play a big role in improving system stability. The stable output helps reduce PID output in general, and are stable regardless of the system's physical state.<br><a data-href="PID" href="https://stormbots.github.io/KnowledgeBase/level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> systems can behave poorly when the system slams across the backlash gap, providing a sharp P and D output back toward the main system, which is an undesirable response. Output ramp rates can help make this gentler.<br><br>This shows up as an inability to declare precise control near the setpoint. The backlash amounts to losing a small amount of motion any time you reverse direction, meaning you cannot correct for slight overshoots, or lag slightly behind the calibrated position targets as wear sets in.<br>In FRC systems, you'll generally see this in <br>
<br><a data-href="Differential Drive" href="https://stormbots.github.io/KnowledgeBase/level-1/differential-drive.html" class="internal-link" target="_self" rel="noopener nofollow">Differential Drive</a> systems, due to the heavy wear of those gearboxes
<br><a data-tooltip-position="top" aria-label="SuperStructure Rollers" data-href="SuperStructure Rollers" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-rollers.html" class="internal-link" target="_self" rel="noopener nofollow">Roller</a> systems being used for linear travel as a passthrough/indexer, particularly when driven by a belt or chain system. 
<br>Arm systems that travel over or under the pivot point. This changes the gravity loading from one side of the backlash to the other
<br>It generally does not show up on systems that <br>
<br>Are gravity loaded in a consistent way, such as <a data-tooltip-position="top" aria-label="SuperStructure Elevator" data-href="SuperStructure Elevator" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-elevator.html" class="internal-link" target="_self" rel="noopener nofollow">Elevators</a> or <a data-tooltip-position="top" aria-label="SuperStructure Arm" data-href="SuperStructure Arm" href="https://stormbots.github.io/KnowledgeBase/level-1/superstructure-arm.html" class="internal-link" target="_self" rel="noopener nofollow">Arms</a> that don't go over/under the pivot point
<br>Using encoders measuring the output directly is the most straightforward solution; This allows a simple PID to handle any unexpected position quirks.<br>If an output encoder is not available, or extra precision is demanded, you can model the backlash as part of your system. This means measuring the magnitude of the backlash, and then applying an offset based on the direction of motion. That then compensates for the lost motion when changing directions. Depending on your reference and application, this might be a symmetric offset (+/- backlash/2) or an asymmetric (-0/+backlash or -backlash/+0) .]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/mechanical-backlash.html</link><guid isPermaLink="false">Misc/Mechanical Backlash.md</guid><pubDate>Sun, 29 Jun 2025 08:05:48 GMT</pubDate><enclosure url="https://stormbots.github.io/KnowledgeBase/lib/media/gear-backlash.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src="https://stormbots.github.io/KnowledgeBase/lib/media/gear-backlash.gif"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Refactoring]]></title><description><![CDATA[ 
 <br>Refactoring is the process of re-structuring your code without notably altering the actual behavior of your code. <br>Refactoring is a very common programming practice, serving purposes from performance, readability, maintainability, de-duplication, and as preparation for further work. <br><br>Refactoring tends to focus on how you manage complexity across your program. The way you represent your problem space in code is commonly called an "Abstraction". <br>A good abstraction enables you to do complicated things easily and focus on solving problems, without having to think too hard on how they're being solved.<br>Without a good abstraction, the programmer will often trip over this complexity time and time again, distracting from the bigger picture problems.<br>A bad abstraction does more harm than good. This can range from being misleading, adding more complexity than it reduces, or just restricting you without good cause.   <br>Refactoring is, in a nutshell, finding a better abstraction. <br><br>You'll often times hear the term "code smell" when it comes to identifying this type of issue. Just like a weird smell in your house, you can probably ignore it for a bit, but the longer you do, the harder it is to avoid. And, like a smell, the first sign is usually not the actual problem, but a symptom. You have to track it to the source, and once dealt with, the impact is bigger than it might first seem.<br>Creating this type of problem isn't a programmer failing though. Whenever a codebase grows in complexity, there's going to be little rough edges, quirks, and special cases left over. Left unchecked, you can easily build on these until they grow into major pitfalls that can completely stop progress.<br>Part of being a good programmer is learning how to identify such issues, form a corrective plan, and tidy up while it's still manageable. <br><br>Duplication tends to be the re-use of small bits of code just here and there. Eventually you might notice that this same bit of code is all over the place, sometimes slightly adjusted or modified. Importantly, you're probably suddenly seeing it because there's a bug in one copy.... that's probably in many of them. <br><br>Readability tends to refer to the simple things in your code: Having good, clear naming conventions, having good indentation, and consistent bracket use.<br>It can also dip a bit into consistent writing patterns. Do your boolean functions swap between isSystemLoaded and isSystemClear ? Do different subsystems have different units?<br>These things don't strictly impact the way the code actually works, but can significantly impact the productivity of programmers working on it! In a multi-user setting, it's easy to tell if readability is off, because you'll probably have just as hard of a time reading their code as they do yours. <br><br>Somewhat tied to the above, maintainability issues dip into the underlying structure a bit more. This normally shows up that the code just breaks more often than you think it should. Little changes cause random other problems, especially on parts of the code unrelated to what you're working on. <br>This can also show up in noticing that the way your code is structured requires a lot of repetitive syntax to deal with, or functions that are not particularly useful in the current state.<br><br>Very much a vibe check; Is your code just feeling difficult to add new code into? Is getting it to do what you want requiring a lot of mental overhead that's not related to solving bigger problems? <br><br>With a need for a refactor identified, it's time to actually do it. There's no hard-and-fast routine, but here's a good starting point <br><br><br><a data-tooltip-position="top" aria-label="Git Basics" data-href="Git Basics" href="https://stormbots.github.io/KnowledgeBase/misc/git-basics.html" class="internal-link" target="_self" rel="noopener nofollow">git</a> is your friend! Git makes it easier to see big, sweeping changes, and see what bits you changed. It also, critically, ensures that if you get it wrong, you can easily start over and try again. Once you have a known good restore point, be fearless! Rip it apart!<br><br>Get your code to a working state. Sometimes it means powering through what whatever code you were trying to add. Sometimes it's pulling your code out and putting it off for a bit.<br>
Basically, If your code doesn't work when you start the refactor, it's harder to judge if the refactor did what it was supposed to: Be cleaner, nicer, and work as it did before. <br><br>This is the hard part. You've gotten a whiff of the problem, but probably don't yet know how deep it goes, and you might not have a full picture of the solution solution quite yet. That's OK. <br>One way to do it is find one of the spots that seem off, and just fix it. This will probably break something else, but that's alright. Fix that up too. Tidy it up. Sometimes doing this simple process leads you a good solution.<br>In the case that some simple poking didn't fix things, you may need to zoom out, and look at the big picture a bit more. Not just lines of code, but where whole functions and processes are kept. Sometimes you back yourself into a corner. Find the biggest problem you're dealing with, and just fix it in the quickest way possible, move things around, and see if that sparks any ideas for how to organize it. Be fearless! you always have <a data-tooltip-position="top" aria-label="Git Basics" data-href="Git Basics" href="https://stormbots.github.io/KnowledgeBase/misc/git-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Git</a> at your disposal to get back to your starting point. <br><br>With luck, poking around at the problems has led you to a better way to model your problems in code, and gotten you a few game plans. <br>Now, you just have to do the legwork of tidying it up, making your cleanup routine the "new standard" for the project, and seeing if it brings up any new problems. <br>If you see any new problems, consider trying to plan ahead. Often, just a few minutes of planning can help avoid a refactor down the line, or at least make it easier. <br><br>A common error we've run into before is setting up <a data-tooltip-position="top" aria-label="Subsystems" data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystem</a> -&gt; Robotcontainer interfaces in the wrong convention. These looked like so.<br>//A custom subsystem class
ExampleRollers extends subsystem base

	public void runMotor(double power){/*code to run motor*/}
	public boolean thingLoaded(){/*checks a sensor*/}
}
<br>//in robot container
joystick.a().whileTrue(Commands.run(exampleRollers.runMotor(1),exampleRollers));
joystick.b().whileTrue(Commands.run(exampleRollers.runMotor(-1),exampleRollers));
<br>With just a few lines, we're able to start seeing some weird structural problems. <br>
<br>Duplication: We're typing out that Commands.run(...,...) bit a whole lot. We also don't seem to be using runMotor in any other way either.
<br>Maintainability: You have to remember the requires every time you run one of these commands! That's a booby trap waiting to happen. 
<br>Readability: It's unclear what directions 1 and -1 mean. It's probably guessable, but no the code doesn't make it clear, or provide guidelines.  
<br>Code Pushback: Let's say you want to have runMotor stop automatically when running forward, and do a quick jolt when running backwards to fix a jamming issue. You might rightly assume this should be in the subsystem.... but the structure doesn't support it. You have to put it in RobotContainer, creating a bunch of new commands. And if there's another use of the eject or intake added later, you're duplicating all this!
<br>Let's walk through and check some specific problems and potential solutions:<br>
<br>We want to remove the unnecessary syntax headaches when trying to run the subsystem
<br>We want to clear up the Requires mess, and make that automatic as part of our function call
<br>We want to make the actual actions read clearer, and avoid arbitrary values
<br>We want to be set up to to build more complex sequences easily.
<br>Let's start with the first one. We can do this by just shoving those inside the subsystem.<br>//A custom subsystem class
ExampleRollers extends subsystem base
	public void runMotor(double power){/*code to run motor*/}
	public boolean thingLoaded(){/*checks a sensor*/}

	public Command runMotorCommand(double power){
		return Commands.run(this.runMotor(1),this);
	}
}
<br>//in robot container
joystick.a().whileTrue(exampleRollers.runMotorCommand(1));
joystick.b().whileTrue(exampleRollers.runMotorCommand(-1));
<br>So far so good! This shortens the robotContainer up quite a bit. We also notice that this handily cleans up the risk of a forgotten Requires.<br>Next, we want to clarify the actions. Unfortunately, the action is tied to the value we provide. So we need to avoid passing in a value. This means we can't use the same function in both places, but that's OK. Let's just assign names and shortcuts and keep going. <br>//A custom subsystem class
ExampleRollers extends subsystem base
	public void runMotor(double power){/*code to run motor*/}
	public boolean thingLoaded(){/*checks a sensor*/}

	public Command runMotorCommand(double power){
		return Commands.run(this.runMotor(1),this);
	}
	public Command intake(){return runMotorCommand(1);}
	public Command eject(){return runMotorCommand(-1);}
}
<br>//in robot container
joystick.a().whileTrue(exampleRollers.intake());
joystick.b().whileTrue(exampleRollers.eject());
<br>This is looking good! Our RobotContainer now looks super clean! The subsystem is also pretty good. We're slowly building more complicated bits on top of each other, and we're not duplicating code in the process.<br>At this point, nothing we've done changes how the code works. We've just shuffled things around, and changed where we manage various details. A good refactor! <br>Now, we're ready to tackle what we wanted to do: Add some features to stop the intake once it's loaded, and jostle things a bit before ejecting them. Fortunately, this is now really easy; We're well set up for it. <br>//A custom subsystem class
ExampleRollers extends subsystem base
	public void runMotor(double power){/*code to run motor*/}
	public boolean isThingLoaded(){/*checks a sensor*/}

	public Command runMotorCommand(double power){
		return Commands.run(this.runMotor(1),this);
	}
	public Command intake(){return runMotorCommand(1);}
	public Command eject(){
		//Jolt the system because it jams or something!
		return Commands.sequence(
			runMotorCommand(1).withTimeout(0.1), 
			runMotorCommand(-1),
		);
	}
}
<br>//in robot container
joystick.a().whileTrue(exampleRollers.intake().until(example::isThingLoaded));
joystick.b().whileTrue(exampleRollers.eject());
<br>Without getting to the weeds of  <a data-href="Subsystems" href="https://stormbots.github.io/KnowledgeBase/misc/subsystems.html" class="internal-link" target="_self" rel="noopener nofollow">Subsystems</a> and <a data-href="Commands" href="https://stormbots.github.io/KnowledgeBase/level-1/commands.html" class="internal-link" target="_self" rel="noopener nofollow">Commands</a> best practices, part of the problem was solved by modifying a created command in RobotContainer, and part of it the base command created in the subsystem. The important detail is that we can fix things easily and properly. ]]></description><link>https://stormbots.github.io/KnowledgeBase/misc/refactoring.html</link><guid isPermaLink="false">Misc/Refactoring.md</guid><pubDate>Sat, 28 Jun 2025 19:31:24 GMT</pubDate></item><item><title><![CDATA[README]]></title><description><![CDATA[ 
 <br>Placeholder file to make sure that the directory exists. <br>This folder is just used to keep images in, so they don't clutter up other documentation. ]]></description><link>assets/readme.html</link><guid isPermaLink="false">assets/README.md</guid><pubDate>Thu, 05 Jun 2025 03:01:08 GMT</pubDate></item><item><title><![CDATA[Coding Basics]]></title><description><![CDATA[ 
 <br><br>
<br>variables
<br>classes
<br>Functions
<br>"structs" or data classes
<br>Introduce enums (don't need to impliment)
<br>Explaining inherited classes as interfaces (because we deal with them).
<br>"null" objects -&gt; initialization (mostly avoided by minimizing indefinite declarations)
<br><br>
<br>Complex stuff involving inheritence or extending classes. Aside from creating new commands or triggers (which mostly act as an interface), we don't do anything with this, and the few places we could it creates confusion because of hidden, unexpected behaviors.
<br>Implimenting/using Arrays/Lists: Not especially common in simpler tasks, and java makes interacting messy. Handle as needed later.
<br>Error handling. Super gross in java, and we mostly need basics. Cover if necessary (mostly Lasercan), but prefer converting errors to Optionals and doing type checking instead of bubbling up (which lasercan also does).
<br><br>
<br>
Teach the "command/robotcontainer/subsystem" model early. If you do a ton of bot development before getting to "typical bot structure", code structure becomes a mess and it becomes harder to use any advanced features and reason through more complex tasks. It also gets the wrong habits engrained, which becomes an unlearning process later. It's OK to say "We'll get into the details of why this is" later, they'll figure things out.

<br>
Putting complex logic into a command is a great way to prototype all sorts of bot ideas, and should help them when doing "upgrades" to older code.

<br>
Consider one "trial project" for subsystems to house a single, simple system, and learn the basic java education. No need to get too deep beyond helping set up. Then, once they have it after a project or two, move into modelling "complex work" with commands.

<br>
It's helpful when "prototyping" complex things using "commands" because you can cycle through different ways of prototyping it easily by swapping out commands being selected.

<br>Subsystems

<br>Robot nouns.
<br>Containers for a single actuator or "resource"
<br>Allows "locks" and requires
<br>Organized place to keep associated code.


<br>Commands

<br>The robot "verbs", and actions systems can take.
<br>Can be basic and stil be useful when decorated
<br>Typical commands shouldn't end; Decorate or make shortcuts for ones that do




Coding Basics]]></description><link>level-0/coding-basics.html</link><guid isPermaLink="false">Level 0/Coding Basics.canvas</guid><pubDate>Sun, 01 Jun 2025 19:51:11 GMT</pubDate></item><item><title><![CDATA[AdvantageKit]]></title><description><![CDATA[ 
 <br><br>
<br>??? Do we need or want this here? 
<br>Need to find a way to actually use it efficiently in beneficial way
<br><br>
<br>Understand how to set up Advantagekit
<br><a rel="noopener nofollow" class="external-link" href="https://docs.advantagekit.org/getting-started/what-is-advantagekit/" target="_blank">https://docs.advantagekit.org/getting-started/what-is-advantagekit/</a>]]></description><link>level-2/advantagekit.html</link><guid isPermaLink="false">Level 2/AdvantageKit.md</guid><pubDate>Mon, 02 Jun 2025 05:03:21 GMT</pubDate></item><item><title><![CDATA[Code Structuring]]></title><description><![CDATA[ 
 <br><br>
<br>Set up a mock project  with a nominal, standard code structure
<br>Project should have a subsystem that<br>
<br>Is in a subsystem folder
<br>Has 3 components in a (logic, <a data-href="Physics Simulation" href="level-2/physics-simulation.html" class="internal-link" target="_self" rel="noopener nofollow">Physics Simulation</a>, <a data-href="Mechanism2d" href="level-2/mechanism2d.html" class="internal-link" target="_self" rel="noopener nofollow">Mechanism2d</a>)
<br>Has a factory method to get a control command (can be mocked up)
<br>Has a trigger that indicates a mechanism state (can be mocked up based on timers)<br>
Has an additional sensor subsystem system that
<br>Provides a trigger for a condition (can be mocked up)<br>
Has a controller and<br>
Has an Autos class to hold autos
<br>With an auto chooser initialization 
<br>A single basic auto using subsystem and sensor
]]></description><link>level-2/code-structuring.html</link><guid isPermaLink="false">Level 2/Code Structuring.md</guid><pubDate>Mon, 02 Jun 2025 04:51:22 GMT</pubDate></item><item><title><![CDATA[Flight Trajectory Calculations]]></title><description><![CDATA[ 
 <br><br>
<br>


<br>Advanced computation for calculating optimal shot angles and rpms]]></description><link>level-2/flight-trajectory-calculations.html</link><guid isPermaLink="false">Level 2/Flight Trajectory Calculations.md</guid><pubDate>Mon, 02 Jun 2025 05:03:32 GMT</pubDate></item><item><title><![CDATA[Forward Kinematics]]></title><description><![CDATA[ 
 <br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/forwardkinematics" target="_blank">https://robotics-explained.com/forwardkinematics</a>]]></description><link>level-2/forward-kinematics.html</link><guid isPermaLink="false">Level 2/Forward Kinematics.md</guid><pubDate>Wed, 04 Jun 2025 23:23:21 GMT</pubDate></item><item><title><![CDATA[Inverse Kinematics]]></title><description><![CDATA[ 
 <br><br>
<br>Do the thing
<br><a rel="noopener nofollow" class="external-link" href="https://robotics-explained.com/inversekinematics" target="_blank">https://robotics-explained.com/inversekinematics</a>]]></description><link>level-2/inverse-kinematics.html</link><guid isPermaLink="false">Level 2/Inverse Kinematics.md</guid><pubDate>Wed, 04 Jun 2025 23:22:09 GMT</pubDate></item><item><title><![CDATA[Lookup Tables]]></title><description><![CDATA[ 
 <br><br>
<br>


<br><br>A pre-computed list of input and output values.<br>Can be used to help model non-trivial conditions where mathematical models are complicated, or don't apply effectively to the problem at hand. <br>Commonly used for modelling <a data-href="Superstructure Shooter" href="level-2/superstructure-shooter.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Shooter</a> ]]></description><link>level-2/lookup-tables.html</link><guid isPermaLink="false">Level 2/Lookup Tables.md</guid><pubDate>Mon, 02 Jun 2025 05:04:06 GMT</pubDate></item><item><title><![CDATA[Superstructure Shooter]]></title><description><![CDATA[ 
 <br>A shooter is simply a flywheel and supporting infrastructure for making game pieces fly from a robot<br><br>
<br>


<br>Typically a "shooter" consists of <br>
<br>a <a data-href="SuperStructure Flywheel" href="level-2/superstructure-flywheel.html" class="internal-link" target="_self" rel="noopener nofollow">SuperStructure Flywheel</a> to serve as a mechanical means to maintain momentum
<br>A <a data-href="Superstructure Indexer" href="level-2/superstructure-indexer.html" class="internal-link" target="_self" rel="noopener nofollow">Superstructure Indexer</a> to time shots and ensure the shooter is at the indended speed
<br>A targeting system, often using Odometry or Vision
<br>A trajectory evaluation to control target RPM. This can be fixed targets, <a data-href="Lookup Tables" href="level-2/lookup-tables.html" class="internal-link" target="_self" rel="noopener nofollow">Lookup Tables</a>, or more complex trajectory calculations
]]></description><link>level-2/superstructure-shooter.html</link><guid isPermaLink="false">Level 2/Superstructure Shooter.md</guid><pubDate>Mon, 02 Jun 2025 04:56:29 GMT</pubDate></item><item><title><![CDATA[Swerve Basics]]></title><description><![CDATA[ 
 <br><br>
<br>Understand how swerve works
<br>Teleop Interactions for existing swerve
<br>Reading odometry
<br>Reset/Initialize odometry 
<br><br>
<br>Use an existing Swerve configuration
<br>
]]></description><link>level-2/swerve-basics.html</link><guid isPermaLink="false">Level 2/Swerve Basics.md</guid><pubDate>Mon, 02 Jun 2025 04:56:56 GMT</pubDate></item><item><title><![CDATA[Swerve Bringup]]></title><description><![CDATA[ 
 <br><br>
<br>Create new drive subsystem 
<br>Create and configure a YAGSL drivetain
<br>Tune Yagsl drivetrain and controls for manual driving
<br>Adjust parameters to ensure accurate auto driving and odometry tracking
<br>
]]></description><link>level-2/swerve-bringup.html</link><guid isPermaLink="false">Level 2/Swerve Bringup.md</guid><pubDate>Mon, 02 Jun 2025 04:57:01 GMT</pubDate></item><item><title><![CDATA[Swerve Motion]]></title><description><![CDATA[ 
 <br><br>Interface with swerve for autos and non-trivial teleop interactions<br><br>
<br>Changing point of rotation in real time
<br>Move from Point to Point using a PID
<br>Move from point to point using a motion profile
<br>Create a command that allows translation while aimed at a bearing
<br>Create a command that allows translation while aimed at a Pose2d
]]></description><link>level-2/swerve-motion.html</link><guid isPermaLink="false">Level 2/Swerve Motion.md</guid><pubDate>Mon, 02 Jun 2025 04:57:24 GMT</pubDate></item><item><title><![CDATA[Swerve Odometry]]></title><description><![CDATA[ 
 ]]></description><link>level-2/swerve-odometry.html</link><guid isPermaLink="false">Level 2/Swerve Odometry.md</guid><pubDate>Sat, 31 May 2025 09:11:52 GMT</pubDate></item><item><title><![CDATA[Robot Radio]]></title><description><![CDATA[ 
 <br>See Official Documentation
The official radio documentation is complete and detailed, and should serve as your primary resource.<br>
<a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/" target="_blank">https://frc-radio.vivid-hosting.net/</a>
However, It's not always obvious what you need to look up to get moving. Consider this document just a simple guide and jumping-off point to find the right documentation elsewhere
<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/quick-start-guide" target="_blank">https://frc-radio.vivid-hosting.net/overview/quick-start-guide</a><br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html" target="_blank">https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-3/radio-programming.html</a><br><br>You don't! The Field Technicians at competitions will program the radio  for competitions. <br>When configured for competition play, you cannot connect to the radio via wifi. Instead, use an ethernet cable, or <br><br>The home radio configuration is a common pain point<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview" target="_blank">https://frc-radio.vivid-hosting.net/overview/programming-your-radio-at-home#overview</a><br><br>This option is the simplest: Just connect the robot via an ethernet or USB, and do whatever you need to do. For quick checks, this makes sense, but obviously is suboptimal for things like driving around. <br><br>The radio does have a 2.4ghz wifi hotspot, albeit with some limitations. This mode is suitable for many practices, and is generally the recommended approach for most every-day practices due to ease of use.<br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions" target="_blank">https://frc-radio.vivid-hosting.net/access-points/setting-vh-109-to-access-point-mode#instructions</a><br>Note, this option requires access to the tiny DIP switches on the back of the radio! You'll want to make sure that your hardware teams don't mount the radio in a way that makes this impossible to access. <br><br>This option uses a second radio to connect your laptop to the robot. This is the most cumbersome and limited way to connect to a robot, and makes swapping who's using the bot a bit more tricky. <br>However, this is also the most performant and reliable connection method. This is recommended when doing extended driving sessions, final performance tuning, and  other scenarios where you're trying to simulate competition-ready environments. <br>This option has a normal robot on one end, and your driver-station setup will look the following image.  See <a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/overview/practicing-at-home" target="_blank">https://frc-radio.vivid-hosting.net/overview/practicing-at-home</a> for full setup directions<br>
<img alt="vidid-radio-wifi-bridge.png.png" src="lib/media/vidid-radio-wifi-bridge.png.png"><br><br><br>Port forwarding allows you to bridge networks across different interfaces. <br>The practical application in FRC is being able to access network devices via the USB interface! This is mostly useful for quickly interfacing with Vision hardware like the <a data-tooltip-position="top" aria-label="Limelight Basics" data-href="Limelight Basics" href="level-1/limelight-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Limelight</a> or <a data-tooltip-position="top" aria-label="PhotonVision Basics" data-href="PhotonVision Basics" href="level-2/photonvision-basics.html" class="internal-link" target="_self" rel="noopener nofollow">Photonvision</a> at competitions.<br>//Add in the constructor in Robot.java or RobotContainer.java

// If you're using a Limelight
PortForwarder.add(5800, "limelight.local", 5800);
// If you're using PhotonVision
PortForwarder.add(5800, "photonvision.local", 5800);
<br><a rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html" target="_blank">https://docs.wpilib.org/ja/latest/docs/networking/networking-utilities/portforwarding.html</a><br><br>The radio has some scriptable interfaces, allowing programmatic access to quickly change or read settings. <br><a rel="noopener nofollow" class="external-link" href="https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced" target="_blank">https://frc-radio.vivid-hosting.net/advanced-topics/programming-your-radio-advanced</a>]]></description><link>misc/robot-radio.html</link><guid isPermaLink="false">Misc/Robot Radio.md</guid><pubDate>Thu, 19 Jun 2025 01:55:19 GMT</pubDate><enclosure url="lib/media/vidid-radio-wifi-bridge.png.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib/media/vidid-radio-wifi-bridge.png.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slew Rate Limiting]]></title><description><![CDATA[ 
 <br><br>Slew Rate Limiting is a simple numerical filter that constrains the rate of change of some value. This can be very useful in multiple situations to prevent unexpected sharp motions<br>SlewRateLimiter limit = new SlewRate(maxRatePerSecond)
// ...
var constrainedOutput = limit.calculate(unconstrainedInput)
<br><a data-tooltip-position="top" aria-label="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/slew-rate-limiter.html" rel="noopener nofollow" class="external-link" href="https://docs.wpilib.org/en/stable/docs/software/advanced-controls/filters/slew-rate-limiter.html" target="_blank">WPILIb Slew Rate Limiter</a><br><br><br>By far the most helpful use case on everyday robots. This helps drivers get reliable, steady control of the robot, preventing sharp jerky motions. It also has the lowest risk of quirky side effects.<br>// Ordinary call with no ramping applied
drivetrain.arcadeDrive(forward, turn);
// Slew-rate limits the forward/backward input, limiting forward/backward acceleration
drivetrain.arcadeDrive(limit.calculate(forward), turn);
<br><br>In some cases it can be helpful to contain motor outputs directly. <br>In fact, this use case is so common that Rev controllers have two variants of this built in<br>// Applies the slew rate on outputs generated by
// motor.set(...) 
motorconfig.openLoopRampRate(rate);
// Applies the slew rate on outputs generated by
// motor.setReference(...) 
motorconfig.closedLoopRampRate(rate);
<br>The closedLoopRampRate can help mitigate sharp oscillations around setpoints caused by imperfect <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> tunings, and harsh transitions on setpoint changes. This can a lot of stability to simple systems, as well as make tuning easier. <br>The openLoopRampRate is valuable for preventing harsh transitions between power levels, commonly encountered for simple button-actuated motions on rollers.<br>This application of slew rate limiting is most common earlier in your robotics career. Eventually, this simple method will be replaced with more advanced <a data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Motion Profiles</a>.<br><br>Applying slew rate limits to <a data-href="PID" href="level-1/pid.html" class="internal-link" target="_self" rel="noopener nofollow">PID</a> setpoints can significantly improve ease of tuning and reduce many issues with setpoint jumps creating large error terms. <br>This application of slew-rates effectively creates a limited version of a <a data-tooltip-position="top" aria-label="Motion Profiles" data-href="Motion Profiles" href="level-2/motion-profiles.html" class="internal-link" target="_self" rel="noopener nofollow">Trapezoidal Motion Profile</a> , but with some extra constraints and caveats.<br><br>A common surprise you might encounter with slew rate limiters is that they constrain limits in both up and down. This makes perfect mathematical sense, but the effect is that heavily rate-limited things may not stop when you expect them to. This can cause them to feel "unresponsive" or "floating". This is most common with things like buttons or joysticks; Stuff won't stop moving when you release, because it'll slowly coast down.<br>The internal implementation accounts for "change per time interval", with "time interval" being defined as the current and previous runs of the calculate() method. If your system stops calculating for a time, the time interval is very large, which means the allowed change in the current iteration is also very large! This can permit the very problems you wanted to solve. If you're restarting a slew rate process, you'll need to reset it by creating a new instance of the SlewRate limiter and over-riding the old one. ]]></description><link>misc/slew-rate-limiting.html</link><guid isPermaLink="false">Misc/Slew Rate Limiting.md</guid><pubDate>Tue, 10 Jun 2025 22:08:48 GMT</pubDate></item></channel></rss>